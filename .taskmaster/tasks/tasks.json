{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Project Foundation and Infrastructure Setup",
        "description": "Set up the complete development environment including Docker Compose for Elasticsearch 9.3.0, FastAPI backend project structure, and React+Vite+TypeScript frontend scaffold with Tailwind CSS configuration.",
        "details": "1. Create `docker-compose.yml` with Elasticsearch 9.3.0 service:\n   ```yaml\n   version: '3.8'\n   services:\n     elasticsearch:\n       image: docker.elastic.co/elasticsearch/elasticsearch:9.3.0\n       container_name: clinical-trials-es\n       environment:\n         - discovery.type=single-node\n         - xpack.security.enabled=false\n         - ES_JAVA_OPTS=-Xms512m -Xmx512m\n       ports:\n         - \"9200:9200\"\n       volumes:\n         - esdata:/usr/share/elasticsearch/data\n   volumes:\n     esdata:\n   ```\n\n2. Create backend structure:\n   ```\n   backend/\n   ├── app/\n   │   ├── __init__.py\n   │   ├── main.py           # FastAPI app entry\n   │   ├── config.py         # Pydantic Settings\n   │   ├── routers/\n   │   │   ├── __init__.py\n   │   │   └── search.py\n   │   ├── services/\n   │   │   ├── __init__.py\n   │   │   ├── llm_service.py\n   │   │   ├── es_service.py\n   │   │   └── suggestion.py\n   │   ├── models/\n   │   │   ├── __init__.py\n   │   │   ├── schemas.py\n   │   │   └── entities.py\n   │   └── utils/\n   │       ├── __init__.py\n   │       └── synonyms.py\n   ├── scripts/\n   │   ├── ingest.py\n   │   └── create_index.py\n   └── requirements.txt\n   ```\n\n3. Create `backend/requirements.txt`:\n   ```\n   fastapi==0.115.12\n   uvicorn[standard]==0.34.0\n   elasticsearch==9.0.1\n   anthropic==0.52.0\n   pydantic==2.11.4\n   pydantic-settings==2.8.1\n   python-dotenv==1.1.0\n   httpx==0.28.1\n   ```\n\n4. Create `backend/app/config.py` with Pydantic Settings:\n   ```python\n   from pydantic_settings import BaseSettings\n   from functools import lru_cache\n\n   class Settings(BaseSettings):\n       es_url: str = \"http://localhost:9200\"\n       es_index: str = \"clinical_trials\"\n       anthropic_api_key: str\n       log_level: str = \"INFO\"\n\n       class Config:\n           env_file = \".env\"\n\n   @lru_cache()\n   def get_settings() -> Settings:\n       return Settings()\n   ```\n\n5. Initialize frontend with Vite + React + TypeScript:\n   ```bash\n   npm create vite@latest frontend -- --template react-ts\n   cd frontend && npm install\n   npm install -D tailwindcss@4.0.5 @tailwindcss/vite\n   ```\n\n6. Configure Tailwind CSS in `frontend/vite.config.ts`:\n   ```typescript\n   import { defineConfig } from 'vite'\n   import react from '@vitejs/plugin-react'\n   import tailwindcss from '@tailwindcss/vite'\n\n   export default defineConfig({\n     plugins: [react(), tailwindcss()],\n   })\n   ```\n\n7. Set up custom theme in `frontend/src/index.css` with CSS variables:\n   - Primary: #0D4F4F (deep teal)\n   - Accent: #D4A843 (warm amber)\n   - Background: #F8F6F3\n   - Status colors for badges\n   - Import Google Fonts (Fraunces for display, Outfit for body)\n\n8. Create `.env` file at project root with required API keys.",
        "testStrategy": "1. Verify Docker Compose starts Elasticsearch: `docker-compose up -d && curl http://localhost:9200`\n2. Verify backend dependencies install: `cd backend && pip install -r requirements.txt`\n3. Verify frontend builds: `cd frontend && npm run dev`\n4. Check Tailwind CSS compiles with custom theme\n5. Verify config.py loads environment variables correctly",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Docker Compose Configuration for Elasticsearch 9.3.0",
            "description": "Create the docker-compose.yml file at project root with Elasticsearch 9.3.0 service configured for single-node development mode with proper memory settings and persistent volume.",
            "dependencies": [],
            "details": "Create `docker-compose.yml` in the project root directory with the following configuration:\n- Use Elasticsearch 9.3.0 official image from docker.elastic.co\n- Set container name to 'clinical-trials-es'\n- Configure single-node discovery mode for local development\n- Disable xpack security for development simplicity\n- Set JVM heap to 512MB min/max via ES_JAVA_OPTS\n- Map port 9200:9200 for REST API access\n- Create named volume 'esdata' for data persistence\n- Add healthcheck command to verify cluster is ready\n\nVerification steps:\n1. Run `docker-compose up -d` to start the container\n2. Wait 30 seconds for Elasticsearch to initialize\n3. Execute `curl -s http://localhost:9200` and verify JSON response with cluster name\n4. Check `curl -s http://localhost:9200/_cluster/health` returns status 'green' or 'yellow'\n5. Run `docker-compose down` to clean up",
            "status": "done",
            "testStrategy": "Run `docker-compose up -d && sleep 30 && curl -s http://localhost:9200 | grep -q 'cluster_name' && echo 'SUCCESS' || echo 'FAILED'`. Verify Elasticsearch responds on port 9200 with valid cluster information. Test volume persistence by indexing a document, restarting container, and verifying document exists.",
            "updatedAt": "2026-02-07T17:17:03.188Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Backend Python Project Directory Structure",
            "description": "Set up the complete FastAPI backend directory structure with all required subdirectories and __init__.py files for proper Python package organization.",
            "dependencies": [
              1
            ],
            "details": "Create the following directory structure under `backend/`:\n```\nbackend/\n├── app/\n│   ├── __init__.py\n│   ├── main.py           # FastAPI app entry point (placeholder)\n│   ├── config.py         # Will be populated in subtask 4\n│   ├── routers/\n│   │   ├── __init__.py\n│   │   └── search.py     # Placeholder for search routes\n│   ├── services/\n│   │   ├── __init__.py\n│   │   ├── llm_service.py    # Placeholder\n│   │   ├── es_service.py     # Placeholder\n│   │   └── suggestion.py     # Placeholder\n│   ├── models/\n│   │   ├── __init__.py\n│   │   ├── schemas.py    # Placeholder\n│   │   └── entities.py   # Placeholder\n│   └── utils/\n│       ├── __init__.py\n│       └── synonyms.py   # Placeholder\n├── scripts/\n│   ├── ingest.py         # Placeholder\n│   └── create_index.py   # Placeholder\n└── requirements.txt      # Will be populated in subtask 3\n```\n\nEach __init__.py should be empty initially. main.py should contain a minimal FastAPI app:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI(title=\"Clinical Trials Search API\")\n\n@app.get(\"/health\")\ndef health():\n    return {\"status\": \"healthy\"}\n```\n\nVerification: Run `python -c \"from app.main import app; print(app.title)\"` from backend directory.",
            "status": "done",
            "testStrategy": "Verify all directories exist with `find backend -type d | sort`. Verify all __init__.py files exist with `find backend -name '__init__.py' | wc -l` (should be 5). Test Python import with `cd backend && python -c 'from app.main import app'` succeeds without errors.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T17:17:03.198Z"
          },
          {
            "id": 3,
            "title": "Create Backend requirements.txt with All Dependencies",
            "description": "Create the requirements.txt file with all necessary Python dependencies including FastAPI, Uvicorn, Elasticsearch client, Anthropic SDK, and Pydantic with exact version pinning.",
            "dependencies": [
              2
            ],
            "details": "Create `backend/requirements.txt` with the following pinned dependencies:\n```\nfastapi==0.115.12\nuvicorn[standard]==0.34.0\nelasticsearch==9.0.1\nanthropic==0.52.0\npydantic==2.11.4\npydantic-settings==2.8.1\npython-dotenv==1.1.0\nhttpx==0.28.1\n```\n\nDependency purposes:\n- fastapi: Web framework for API\n- uvicorn[standard]: ASGI server with uvloop and httptools\n- elasticsearch: Official ES Python client compatible with ES 9.x\n- anthropic: Claude API SDK for LLM entity extraction\n- pydantic/pydantic-settings: Data validation and settings management\n- python-dotenv: Environment variable loading\n- httpx: Async HTTP client (used by anthropic SDK)\n\nVerification steps:\n1. Create a virtual environment: `python -m venv venv`\n2. Activate it: `source venv/bin/activate` (Unix) or `venv\\Scripts\\activate` (Windows)\n3. Install dependencies: `pip install -r requirements.txt`\n4. Verify installations: `pip list | grep -E 'fastapi|elasticsearch|anthropic'`\n5. Test imports: `python -c \"import fastapi, elasticsearch, anthropic; print('All imports successful')\"`",
            "status": "done",
            "testStrategy": "Create fresh virtual environment and run `pip install -r backend/requirements.txt`. Verify exit code is 0 and no version conflicts. Run `python -c 'import fastapi; import elasticsearch; import anthropic; import pydantic_settings; print(\"OK\")'` to confirm all packages are importable.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T17:17:03.201Z"
          },
          {
            "id": 4,
            "title": "Implement Pydantic Settings Configuration Module",
            "description": "Create the config.py module with Pydantic Settings for environment-based configuration including Elasticsearch URL, index name, Anthropic API key, and logging level with caching.",
            "dependencies": [
              3
            ],
            "details": "Create `backend/app/config.py` with the following implementation:\n```python\nfrom pydantic_settings import BaseSettings\nfrom functools import lru_cache\nfrom typing import Optional\n\nclass Settings(BaseSettings):\n    # Elasticsearch configuration\n    es_url: str = \"http://localhost:9200\"\n    es_index: str = \"clinical_trials\"\n    \n    # API Keys\n    anthropic_api_key: str\n    \n    # Application settings\n    log_level: str = \"INFO\"\n    \n    # Optional: for future extensions\n    cors_origins: str = \"http://localhost:5173\"\n    \n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n        case_sensitive = False\n\n@lru_cache()\ndef get_settings() -> Settings:\n    \"\"\"Cached settings instance to avoid re-reading .env on every call.\"\"\"\n    return Settings()\n```\n\nUpdate `backend/app/main.py` to use settings:\n```python\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom app.config import get_settings\n\nsettings = get_settings()\napp = FastAPI(title=\"Clinical Trials Search API\")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[settings.cors_origins],\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n@app.get(\"/health\")\ndef health():\n    return {\"status\": \"healthy\", \"es_url\": settings.es_url}\n```\n\nVerification: Create a test .env and verify settings load correctly.",
            "status": "done",
            "testStrategy": "Create a temporary .env file with `echo 'ANTHROPIC_API_KEY=test-key-123' > backend/.env`. Run `cd backend && python -c \"from app.config import get_settings; s = get_settings(); print(s.es_url, s.anthropic_api_key)\"`. Verify output shows default es_url and the test API key. Test that missing required fields raise ValidationError.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T17:17:03.203Z"
          },
          {
            "id": 5,
            "title": "Initialize Frontend with Vite, React, and TypeScript",
            "description": "Create the frontend project using Vite with React and TypeScript template, install all base dependencies, and verify the development server runs correctly.",
            "dependencies": [
              1
            ],
            "details": "Execute the following commands to initialize the frontend:\n\n1. Create Vite project with React TypeScript template:\n```bash\nnpm create vite@latest frontend -- --template react-ts\n```\n\n2. Navigate to frontend and install dependencies:\n```bash\ncd frontend\nnpm install\n```\n\n3. Install Tailwind CSS 4.0 and Vite plugin:\n```bash\nnpm install -D tailwindcss@4.0.5 @tailwindcss/vite\n```\n\n4. Verify project structure includes:\n- frontend/src/main.tsx (entry point)\n- frontend/src/App.tsx (root component)\n- frontend/vite.config.ts (build configuration)\n- frontend/tsconfig.json (TypeScript config)\n- frontend/package.json (dependencies)\n\n5. Clean up default Vite boilerplate:\n- Remove default App.css content\n- Simplify App.tsx to basic component\n- Remove Vite/React logos from assets if present\n\nVerification:\n1. Run `npm run dev` and verify server starts on port 5173\n2. Open http://localhost:5173 in browser\n3. Verify hot module replacement works by editing App.tsx",
            "status": "done",
            "testStrategy": "Run `cd frontend && npm run dev -- --port 5173 &` to start dev server in background. Wait 5 seconds, then `curl -s http://localhost:5173 | grep -q 'vite' && echo 'SUCCESS'`. Run `npm run build` to verify TypeScript compilation succeeds with no errors. Kill the background server after tests.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T17:17:03.205Z"
          },
          {
            "id": 6,
            "title": "Configure Tailwind CSS 4.0 with Custom Theme",
            "description": "Set up Tailwind CSS 4.0 configuration in Vite, create custom theme with project-specific colors (deep teal, warm amber), import Google Fonts (Fraunces, Outfit), and define CSS custom properties.",
            "dependencies": [
              5
            ],
            "details": "1. Update `frontend/vite.config.ts`:\n```typescript\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport tailwindcss from '@tailwindcss/vite'\n\nexport default defineConfig({\n  plugins: [react(), tailwindcss()],\n  server: {\n    proxy: {\n      '/api': 'http://localhost:8000'\n    }\n  }\n})\n```\n\n2. Replace `frontend/src/index.css` with custom theme:\n```css\n@import url('https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,400;9..144,600;9..144,700&family=Outfit:wght@400;500;600&display=swap');\n@import 'tailwindcss';\n\n:root {\n  /* Primary colors */\n  --color-primary: #0D4F4F;\n  --color-primary-light: #1A6B6B;\n  --color-primary-dark: #083838;\n  \n  /* Accent colors */\n  --color-accent: #D4A843;\n  --color-accent-light: #E5C06A;\n  --color-accent-dark: #B8902E;\n  \n  /* Background */\n  --color-bg: #F8F6F3;\n  --color-bg-card: #FFFFFF;\n  \n  /* Text */\n  --color-text: #1F2937;\n  --color-text-muted: #6B7280;\n  \n  /* Status badge colors */\n  --color-status-recruiting: #059669;\n  --color-status-completed: #6366F1;\n  --color-status-active: #0EA5E9;\n  --color-status-terminated: #DC2626;\n}\n\nbody {\n  font-family: 'Outfit', sans-serif;\n  background-color: var(--color-bg);\n  color: var(--color-text);\n}\n\n.font-display {\n  font-family: 'Fraunces', serif;\n}\n```\n\n3. Update `frontend/src/App.tsx` to test theme:\n```tsx\nfunction App() {\n  return (\n    <div className=\"min-h-screen bg-[var(--color-bg)] p-8\">\n      <h1 className=\"font-display text-4xl text-[var(--color-primary)] mb-4\">\n        Clinical Trials Search\n      </h1>\n      <p className=\"text-[var(--color-text-muted)]\">\n        Theme configured successfully\n      </p>\n      <button className=\"mt-4 px-4 py-2 bg-[var(--color-accent)] text-white rounded\">\n        Test Button\n      </button>\n    </div>\n  )\n}\nexport default App\n```",
            "status": "done",
            "testStrategy": "Run `npm run dev` and visually verify: 1) Background is cream/off-white (#F8F6F3), 2) Heading uses Fraunces serif font in deep teal (#0D4F4F), 3) Button shows warm amber (#D4A843). Inspect elements in browser DevTools to confirm CSS variables are applied. Run `npm run build` to ensure Tailwind purges unused styles correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T17:17:03.207Z"
          },
          {
            "id": 7,
            "title": "Create Environment File with Required API Keys",
            "description": "Set up the .env file at project root with all required environment variables, create .env.example template for documentation, and configure .gitignore to exclude sensitive files.",
            "dependencies": [
              4,
              6
            ],
            "details": "1. Create `.env` at project root with required variables:\n```\n# Elasticsearch Configuration\nES_URL=http://localhost:9200\nES_INDEX=clinical_trials\n\n# Anthropic API (required for LLM entity extraction)\nANTHROPIC_API_KEY=your-anthropic-api-key-here\n\n# Application Settings\nLOG_LEVEL=INFO\nCORS_ORIGINS=http://localhost:5173\n```\n\n2. Create `.env.example` for documentation (safe to commit):\n```\n# Copy this file to .env and fill in your values\n# Elasticsearch Configuration\nES_URL=http://localhost:9200\nES_INDEX=clinical_trials\n\n# Anthropic API (get from https://console.anthropic.com/)\nANTHROPIC_API_KEY=\n\n# Application Settings\nLOG_LEVEL=INFO\nCORS_ORIGINS=http://localhost:5173\n```\n\n3. Ensure `.gitignore` includes (create if not exists or append):\n```\n# Environment files\n.env\n.env.local\n.env.*.local\n\n# Python\n__pycache__/\n*.py[cod]\nvenv/\n.venv/\n\n# Node\nnode_modules/\ndist/\n\n# Elasticsearch data\nesdata/\n\n# IDE\n.idea/\n.vscode/\n*.swp\n```\n\n4. Create symlink or copy .env to backend directory for Python access:\n```bash\nln -s ../.env backend/.env\n# Or simply: cp .env backend/.env\n```\n\nVerification:\n1. Check .env is not tracked: `git status | grep -v '.env'`\n2. Verify backend can read settings: `cd backend && python -c \"from app.config import get_settings; print(get_settings().es_url)\"`\n3. Confirm .env.example is tracked: `git add .env.example`",
            "status": "done",
            "testStrategy": "Verify .env file exists with `test -f .env && echo 'EXISTS'`. Verify .gitignore excludes .env with `git check-ignore .env && echo 'IGNORED'`. Test backend config loads by running `cd backend && python -c \"from app.config import get_settings; s = get_settings(); assert s.es_url == 'http://localhost:9200'\"`. Verify .env.example is trackable with `git add --dry-run .env.example`.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T17:17:03.209Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Break down the project foundation setup into: 1) Docker Compose configuration for Elasticsearch 9.3.0 with proper settings, 2) Backend Python project structure creation with all directories, 3) requirements.txt with all dependencies and versions, 4) Pydantic Settings configuration in config.py, 5) Frontend Vite+React+TypeScript project initialization, 6) Tailwind CSS 4.0 configuration with custom theme (colors, fonts via CSS variables), 7) Environment file setup with required API keys. Each subtask should include verification steps.",
        "updatedAt": "2026-02-07T17:17:03.209Z"
      },
      {
        "id": "2",
        "title": "Pydantic Data Models and Type Definitions",
        "description": "Define comprehensive Pydantic models for entity extraction, API request/response schemas, and corresponding TypeScript interfaces for the frontend.",
        "details": "1. Create `backend/app/models/entities.py`:\n   ```python\n   from pydantic import BaseModel, Field\n   from typing import Optional, List\n   from enum import Enum\n\n   class PhaseEnum(str, Enum):\n       PHASE1 = \"PHASE1\"\n       PHASE2 = \"PHASE2\"\n       PHASE3 = \"PHASE3\"\n       PHASE4 = \"PHASE4\"\n       EARLY_PHASE1 = \"EARLY_PHASE1\"\n       NA = \"NA\"\n\n   class StatusEnum(str, Enum):\n       RECRUITING = \"RECRUITING\"\n       NOT_YET_RECRUITING = \"NOT_YET_RECRUITING\"\n       COMPLETED = \"COMPLETED\"\n       ACTIVE_NOT_RECRUITING = \"ACTIVE_NOT_RECRUITING\"\n       TERMINATED = \"TERMINATED\"\n       WITHDRAWN = \"WITHDRAWN\"\n       SUSPENDED = \"SUSPENDED\"\n\n   class LocationFilter(BaseModel):\n       city: Optional[str] = None\n       state: Optional[str] = None\n       country: Optional[str] = None\n\n   class ExtractedEntities(BaseModel):\n       phase: Optional[str] = Field(None, description=\"Clinical trial phase\")\n       condition: Optional[str] = Field(None, description=\"Medical condition/disease\")\n       status: Optional[str] = Field(None, description=\"Trial recruitment status\")\n       location: Optional[LocationFilter] = Field(None, description=\"Geographic location\")\n       sponsor: Optional[str] = Field(None, description=\"Sponsoring organization\")\n       keyword: Optional[str] = Field(None, description=\"Gene, drug, or specific term\")\n       age_group: Optional[str] = Field(None, description=\"Target age group\")\n       enrollment_min: Optional[int] = Field(None, description=\"Minimum enrollment\")\n       enrollment_max: Optional[int] = Field(None, description=\"Maximum enrollment\")\n       confidence: float = Field(default=0.8, ge=0.0, le=1.0)\n       clarification: Optional[str] = Field(None, description=\"Follow-up question\")\n   ```\n\n2. Create `backend/app/models/schemas.py`:\n   ```python\n   from pydantic import BaseModel\n   from typing import List, Optional, Any, Dict\n   from .entities import ExtractedEntities\n\n   class Sponsor(BaseModel):\n       name: str\n       agency_class: Optional[str] = None\n       lead_or_collaborator: Optional[str] = None\n\n   class Facility(BaseModel):\n       name: Optional[str] = None\n       city: Optional[str] = None\n       state: Optional[str] = None\n       country: Optional[str] = None\n\n   class TrialResult(BaseModel):\n       nct_id: str\n       brief_title: str\n       official_title: Optional[str] = None\n       phase: Optional[str] = None\n       overall_status: Optional[str] = None\n       enrollment: Optional[int] = None\n       sponsors: List[Sponsor] = []\n       facilities: List[Facility] = []\n       brief_summaries_description: Optional[str] = None\n       start_date: Optional[str] = None\n       age: List[Dict[str, str]] = []\n\n   class SearchResponse(BaseModel):\n       query_interpretation: ExtractedEntities\n       results: List[TrialResult]\n       total: int\n       page: int\n       page_size: int\n       clarification: Optional[str] = None\n\n   class SuggestionResponse(BaseModel):\n       suggestions: List[str]\n\n   class ErrorResponse(BaseModel):\n       error: str\n       detail: str\n   ```\n\n3. Create `frontend/src/types/index.ts`:\n   ```typescript\n   export interface LocationFilter {\n     city?: string;\n     state?: string;\n     country?: string;\n   }\n\n   export interface ExtractedEntities {\n     phase?: string;\n     condition?: string;\n     status?: string;\n     location?: LocationFilter;\n     sponsor?: string;\n     keyword?: string;\n     age_group?: string;\n     enrollment_min?: number;\n     enrollment_max?: number;\n     confidence: number;\n     clarification?: string;\n   }\n\n   export interface Sponsor {\n     name: string;\n     agency_class?: string;\n     lead_or_collaborator?: string;\n   }\n\n   export interface Facility {\n     name?: string;\n     city?: string;\n     state?: string;\n     country?: string;\n   }\n\n   export interface TrialResult {\n     nct_id: string;\n     brief_title: string;\n     official_title?: string;\n     phase?: string;\n     overall_status?: string;\n     enrollment?: number;\n     sponsors: Sponsor[];\n     facilities: Facility[];\n     brief_summaries_description?: string;\n     start_date?: string;\n     age: { age_category: string }[];\n   }\n\n   export interface SearchResponse {\n     query_interpretation: ExtractedEntities;\n     results: TrialResult[];\n     total: number;\n     page: number;\n     page_size: number;\n     clarification?: string;\n   }\n\n   export interface SuggestionResponse {\n     suggestions: string[];\n   }\n   ```",
        "testStrategy": "1. Unit test Pydantic model validation with sample data from clinical_trials.json\n2. Test optional field handling with partial data\n3. Test enum validation for phase and status fields\n4. Verify TypeScript types compile without errors\n5. Test round-trip serialization/deserialization",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create entities.py with ExtractedEntities, Enums, and LocationFilter",
            "description": "Create the backend/app/models/entities.py file containing PhaseEnum, StatusEnum, LocationFilter, and ExtractedEntities Pydantic models with complete Field definitions, validation rules, and docstrings.",
            "dependencies": [],
            "details": "Create backend/app/models/entities.py with:\n1. PhaseEnum(str, Enum) with values: PHASE1, PHASE2, PHASE3, PHASE4, EARLY_PHASE1, NA\n2. StatusEnum(str, Enum) with values: RECRUITING, NOT_YET_RECRUITING, COMPLETED, ACTIVE_NOT_RECRUITING, TERMINATED, WITHDRAWN, SUSPENDED\n3. LocationFilter(BaseModel) with optional city, state, country string fields\n4. ExtractedEntities(BaseModel) with:\n   - phase: Optional[str] with Field description\n   - condition: Optional[str] for medical condition/disease\n   - status: Optional[str] for trial recruitment status\n   - location: Optional[LocationFilter] for geographic filtering\n   - sponsor: Optional[str] for sponsoring organization\n   - keyword: Optional[str] for gene, drug, or specific term\n   - age_group: Optional[str] for target age group\n   - enrollment_min/max: Optional[int] for enrollment range\n   - confidence: float with Field(default=0.8, ge=0.0, le=1.0)\n   - clarification: Optional[str] for follow-up questions\n5. Add __init__.py to models directory with proper exports",
            "status": "pending",
            "testStrategy": "Test PhaseEnum and StatusEnum contain all expected values. Test LocationFilter accepts partial data (city only, country only). Test ExtractedEntities validation: confidence must be 0.0-1.0, optional fields accept None, all Field descriptions are set correctly.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create schemas.py with API Request/Response Models",
            "description": "Create the backend/app/models/schemas.py file containing Sponsor, Facility, TrialResult, SearchResponse, SuggestionResponse, and ErrorResponse Pydantic models for API serialization.",
            "dependencies": [
              1
            ],
            "details": "Create backend/app/models/schemas.py with:\n1. Sponsor(BaseModel): name (str, required), agency_class (Optional[str]), lead_or_collaborator (Optional[str])\n2. Facility(BaseModel): name, city, state, country (all Optional[str])\n3. TrialResult(BaseModel):\n   - nct_id: str (required)\n   - brief_title: str (required)\n   - official_title: Optional[str]\n   - phase: Optional[str]\n   - overall_status: Optional[str]\n   - enrollment: Optional[int]\n   - sponsors: List[Sponsor] = []\n   - facilities: List[Facility] = []\n   - brief_summaries_description: Optional[str]\n   - start_date: Optional[str]\n   - age: List[Dict[str, str]] = []\n4. SearchResponse(BaseModel): query_interpretation (ExtractedEntities), results (List[TrialResult]), total (int), page (int), page_size (int), clarification (Optional[str])\n5. SuggestionResponse(BaseModel): suggestions (List[str])\n6. ErrorResponse(BaseModel): error (str), detail (str)\n7. Import ExtractedEntities from entities module",
            "status": "pending",
            "testStrategy": "Test TrialResult requires nct_id and brief_title. Test SearchResponse serialization with nested ExtractedEntities and List[TrialResult]. Test Sponsor and Facility with partial data. Verify empty list defaults for sponsors, facilities, and age fields.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create Frontend TypeScript Interfaces Matching Pydantic Models",
            "description": "Create the frontend/src/types/index.ts file with TypeScript interfaces that exactly mirror all Pydantic models for type-safe API communication.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create frontend/src/types/index.ts with:\n1. LocationFilter interface: city?, state?, country? (all optional strings)\n2. ExtractedEntities interface: phase?, condition?, status?, location?: LocationFilter, sponsor?, keyword?, age_group? (optional strings), enrollment_min?, enrollment_max? (optional numbers), confidence: number (required), clarification?: string\n3. Sponsor interface: name: string (required), agency_class?: string, lead_or_collaborator?: string\n4. Facility interface: name?, city?, state?, country? (all optional strings)\n5. TrialResult interface: nct_id: string, brief_title: string (required), optional fields for official_title, phase, overall_status, enrollment (number), sponsors: Sponsor[], facilities: Facility[], brief_summaries_description?, start_date?, age: { age_category: string }[]\n6. SearchResponse interface: query_interpretation: ExtractedEntities, results: TrialResult[], total: number, page: number, page_size: number, clarification?: string\n7. SuggestionResponse interface: suggestions: string[]\n8. Export all interfaces",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation succeeds with no errors. Test interface usage by creating sample objects matching each interface. Verify optional fields compile correctly. Test that TrialResult[] can be assigned to SearchResponse.results.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Unit Tests for Model Validation with Clinical Trials Sample Data",
            "description": "Create comprehensive unit tests for all Pydantic models using sample data from clinical_trials.json to verify validation rules, optional field handling, and serialization.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create backend/tests/test_models.py with:\n1. Import pytest and all models from entities.py and schemas.py\n2. Load sample data from clinical_trials.json for realistic test cases\n3. Test ExtractedEntities:\n   - Test confidence validation (valid: 0.0, 0.5, 1.0; invalid: -0.1, 1.5)\n   - Test all optional fields accept None\n   - Test LocationFilter nested validation\n4. Test PhaseEnum and StatusEnum:\n   - Verify all enum values are accessible\n   - Test enum string serialization\n5. Test TrialResult:\n   - Test with complete data from clinical_trials.json\n   - Test with minimal required fields only (nct_id, brief_title)\n   - Test sponsors and facilities as empty lists\n6. Test SearchResponse:\n   - Test with nested ExtractedEntities and List[TrialResult]\n   - Test pagination fields (total, page, page_size)\n7. Test round-trip serialization: model.model_dump() -> Model(**data)\n8. Test ErrorResponse with error and detail strings\n9. Add conftest.py with sample data fixtures",
            "status": "pending",
            "testStrategy": "Run pytest with coverage to ensure all model branches are tested. Verify tests pass with valid data and raise ValidationError for invalid data. Test edge cases: empty strings, zero values, boundary values for confidence (0.0, 1.0). Ensure tests are isolated and deterministic.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down data models creation into: 1) Create entities.py with ExtractedEntities model including all enums (PhaseEnum, StatusEnum), LocationFilter, and proper Field definitions with descriptions, 2) Create schemas.py with Sponsor, Facility, TrialResult, SearchResponse, SuggestionResponse, and ErrorResponse models, 3) Create frontend TypeScript interfaces in types/index.ts matching all Pydantic models exactly, 4) Add unit tests for model validation with sample data from clinical_trials.json. Each subtask should include type hints and validation rules."
      },
      {
        "id": "3",
        "title": "Elasticsearch Index Mapping and Bulk Ingestion",
        "description": "Create the Elasticsearch index with optimized field mappings for clinical trials data and implement bulk indexing script to load all 1000 documents.",
        "details": "1. Create `backend/scripts/create_index.py`:\n   ```python\n   from elasticsearch import Elasticsearch\n   import sys\n   sys.path.append('..')\n   from app.config import get_settings\n\n   def create_index():\n       settings = get_settings()\n       es = Elasticsearch([settings.es_url])\n       \n       mapping = {\n           \"settings\": {\n               \"number_of_shards\": 1,\n               \"number_of_replicas\": 0,\n               \"analysis\": {\n                   \"analyzer\": {\n                       \"clinical_analyzer\": {\n                           \"type\": \"custom\",\n                           \"tokenizer\": \"standard\",\n                           \"filter\": [\"lowercase\", \"asciifolding\"]\n                       }\n                   }\n               }\n           },\n           \"mappings\": {\n               \"properties\": {\n                   \"nct_id\": {\"type\": \"keyword\"},\n                   \"brief_title\": {\n                       \"type\": \"text\",\n                       \"analyzer\": \"clinical_analyzer\",\n                       \"fields\": {\n                           \"suggest\": {\"type\": \"search_as_you_type\"}\n                       }\n                   },\n                   \"official_title\": {\n                       \"type\": \"text\",\n                       \"analyzer\": \"clinical_analyzer\",\n                       \"fields\": {\n                           \"suggest\": {\"type\": \"search_as_you_type\"}\n                       }\n                   },\n                   \"phase\": {\"type\": \"keyword\"},\n                   \"overall_status\": {\"type\": \"keyword\"},\n                   \"enrollment\": {\"type\": \"integer\"},\n                   \"gender\": {\"type\": \"keyword\"},\n                   \"study_type\": {\"type\": \"keyword\"},\n                   \"intervention_model\": {\"type\": \"keyword\"},\n                   \"primary_purpose\": {\"type\": \"keyword\"},\n                   \"start_date\": {\"type\": \"date\"},\n                   \"completion_date\": {\"type\": \"date\"},\n                   \"primary_completion_date\": {\"type\": \"date\"},\n                   \"age\": {\n                       \"type\": \"nested\",\n                       \"properties\": {\n                           \"age_category\": {\"type\": \"keyword\"}\n                       }\n                   },\n                   \"sponsors\": {\n                       \"type\": \"nested\",\n                       \"properties\": {\n                           \"name\": {\n                               \"type\": \"text\",\n                               \"fields\": {\"keyword\": {\"type\": \"keyword\"}}\n                           },\n                           \"agency_class\": {\"type\": \"keyword\"},\n                           \"lead_or_collaborator\": {\"type\": \"keyword\"}\n                       }\n                   },\n                   \"facilities\": {\n                       \"type\": \"nested\",\n                       \"properties\": {\n                           \"name\": {\"type\": \"text\"},\n                           \"city\": {\"type\": \"keyword\"},\n                           \"state\": {\"type\": \"keyword\"},\n                           \"country\": {\"type\": \"keyword\"}\n                       }\n                   },\n                   \"design_outcomes\": {\n                       \"type\": \"nested\",\n                       \"properties\": {\n                           \"outcome_type\": {\"type\": \"keyword\"},\n                           \"measure\": {\"type\": \"text\"},\n                           \"time_frame\": {\"type\": \"text\"},\n                           \"description\": {\"type\": \"text\"}\n                       }\n                   },\n                   \"brief_summaries_description\": {\"type\": \"text\", \"analyzer\": \"clinical_analyzer\"},\n                   \"detailed_description\": {\"type\": \"text\", \"analyzer\": \"clinical_analyzer\"},\n                   \"source\": {\"type\": \"keyword\"},\n                   \"acronym\": {\"type\": \"keyword\"}\n               }\n           }\n       }\n       \n       if es.indices.exists(index=settings.es_index):\n           es.indices.delete(index=settings.es_index)\n       \n       es.indices.create(index=settings.es_index, body=mapping)\n       print(f\"Index '{settings.es_index}' created successfully\")\n\n   if __name__ == \"__main__\":\n       create_index()\n   ```\n\n2. Create `backend/scripts/ingest.py`:\n   ```python\n   import json\n   from elasticsearch import Elasticsearch\n   from elasticsearch.helpers import bulk\n   import sys\n   sys.path.append('..')\n   from app.config import get_settings\n\n   def transform_document(doc):\n       \"\"\"Transform document for ES indexing\"\"\"\n       # Convert enrollment from string to int\n       if doc.get('enrollment'):\n           try:\n               doc['enrollment'] = int(doc['enrollment'])\n           except (ValueError, TypeError):\n               doc['enrollment'] = None\n       \n       # Ensure nested arrays are properly structured\n       doc['sponsors'] = doc.get('sponsors') or []\n       doc['facilities'] = doc.get('facilities') or []\n       doc['design_outcomes'] = doc.get('design_outcomes') or []\n       doc['age'] = doc.get('age') or []\n       \n       return doc\n\n   def generate_bulk_actions(data, index_name):\n       for doc in data:\n           transformed = transform_document(doc)\n           yield {\n               \"_index\": index_name,\n               \"_id\": doc['nct_id'],\n               \"_source\": transformed\n           }\n\n   def ingest_data(filepath):\n       settings = get_settings()\n       es = Elasticsearch([settings.es_url])\n       \n       with open(filepath, 'r') as f:\n           data = json.load(f)\n       \n       success, failed = bulk(es, generate_bulk_actions(data, settings.es_index))\n       print(f\"Indexed {success} documents, {len(failed)} failed\")\n       \n       # Refresh index for immediate searchability\n       es.indices.refresh(index=settings.es_index)\n\n   if __name__ == \"__main__\":\n       ingest_data('../../clinical_trials.json')\n   ```",
        "testStrategy": "1. Verify index creation: `curl -X GET 'localhost:9200/clinical_trials/_mapping?pretty'`\n2. Run ingestion and verify count: `curl -X GET 'localhost:9200/clinical_trials/_count'` should return 1000\n3. Test sample queries:\n   - `curl -X GET 'localhost:9200/clinical_trials/_search?q=phase:PHASE2'`\n   - Nested query for facilities by country\n   - Range query on enrollment\n4. Verify search_as_you_type works with prefix queries\n5. Test enrollment type conversion with edge cases",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create create_index.py with complete Elasticsearch field mappings",
            "description": "Implement the create_index.py script with optimized field mappings for all clinical trial fields including keyword types (nct_id, phase, overall_status, gender, study_type), text fields with clinical_analyzer for searchable content (brief_title, official_title, descriptions), and search_as_you_type sub-fields for title autocomplete functionality.",
            "dependencies": [],
            "details": "Create backend/scripts/create_index.py with: 1) Custom 'clinical_analyzer' using standard tokenizer with lowercase and asciifolding filters. 2) Keyword mappings for: nct_id, phase, overall_status, gender, study_type, intervention_model, primary_purpose, source, acronym. 3) Text fields with clinical_analyzer for: brief_title, official_title, brief_summaries_description, detailed_description. 4) Add search_as_you_type sub-field for brief_title and official_title to enable autocomplete suggestions. 5) Integer mapping for enrollment field. 6) Date mappings for start_date, completion_date, primary_completion_date. 7) Include index settings with number_of_shards=1 and number_of_replicas=0 for development. 8) Add logic to delete existing index before recreation to allow re-running the script. Handle Elasticsearch connection errors gracefully.",
            "status": "pending",
            "testStrategy": "Verify index creation with `curl -X GET 'localhost:9200/clinical_trials/_mapping?pretty'`. Check that all fields have correct types. Test that clinical_analyzer is properly configured by analyzing sample text. Verify search_as_you_type fields exist under brief_title.suggest and official_title.suggest.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Define nested mappings for complex data structures",
            "description": "Add nested field mappings for sponsors, facilities, design_outcomes, and age arrays with appropriate field types for each property to support nested queries in Elasticsearch.",
            "dependencies": [
              1
            ],
            "details": "Extend create_index.py mapping to include: 1) 'sponsors' nested type with: name (text with keyword sub-field), agency_class (keyword), lead_or_collaborator (keyword). 2) 'facilities' nested type with: name (text), city (keyword), state (keyword), country (keyword), zip (keyword), status (keyword). 3) 'design_outcomes' nested type with: outcome_type (keyword), measure (text), time_frame (text), description (text). 4) 'age' nested type with: age_category (keyword). Nested types are required because these are arrays of objects that need independent querying - using 'object' type would flatten them and cause cross-object matching issues. Ensure proper handling of empty arrays and null values in nested fields.",
            "status": "pending",
            "testStrategy": "Create test documents with nested data and verify with nested queries. Test query: `{\"query\": {\"nested\": {\"path\": \"sponsors\", \"query\": {\"match\": {\"sponsors.name\": \"AstraZeneca\"}}}}}`. Verify facilities can be filtered by country. Test that empty arrays don't cause indexing errors.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement ingest.py with document transformation logic",
            "description": "Create the ingest.py script with robust document transformation including enrollment string-to-integer conversion, null value handling for optional fields, and proper date format handling for Elasticsearch compatibility.",
            "dependencies": [
              1
            ],
            "details": "Create backend/scripts/ingest.py with transform_document() function that: 1) Converts 'enrollment' from string to integer, handling 'None', empty strings, and invalid values by setting to None. 2) Ensures nested arrays (sponsors, facilities, design_outcomes, age) default to empty arrays [] if null or missing. 3) Handles date fields (start_date, completion_date, primary_completion_date) - data shows ISO format with 'T00:00:00.000Z' which ES should accept directly. 4) Cleans string fields by stripping whitespace. 5) Handles 'None' string values in fields like number_of_groups by converting to null. 6) Preserves all other fields as-is. Add validation logging to identify problematic documents during development.",
            "status": "pending",
            "testStrategy": "Unit test transform_document with edge cases: enrollment='540' -> 540, enrollment='None' -> None, enrollment='' -> None. Test nested array defaults. Test with actual sample document from clinical_trials.json. Verify all 1000 documents pass transformation without errors.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add bulk indexing with error handling and progress reporting",
            "description": "Implement the bulk indexing functionality using elasticsearch-py helpers.bulk() with proper error handling, progress reporting, and retry logic for failed documents.",
            "dependencies": [
              2,
              3
            ],
            "details": "Enhance ingest.py with: 1) generate_bulk_actions() generator that yields properly formatted bulk action dicts with _index, _id (nct_id), and _source. 2) Use elasticsearch.helpers.bulk() for efficient batching (default 500 docs per batch). 3) Add progress reporting using tqdm or simple print statements showing documents processed. 4) Capture and log failed documents with their nct_id and error reason. 5) Add --dry-run flag to validate transformations without indexing. 6) Implement retry logic for transient ES errors. 7) Call es.indices.refresh() after bulk indexing to make documents immediately searchable. 8) Add command-line argument for filepath with default to '../../clinical_trials.json'. 9) Report final statistics: total docs, successful, failed.",
            "status": "pending",
            "testStrategy": "Run ingestion on full dataset and verify: 'curl -X GET localhost:9200/clinical_trials/_count' returns 1000. Test with intentionally malformed document to verify error handling. Verify progress output shows batch completion. Test dry-run mode doesn't modify index.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create verification script with sample queries for each field type",
            "description": "Implement a verification script that tests the indexed data with sample queries covering term queries for keywords, nested queries for complex fields, range queries for dates/numbers, and full-text search for analyzed fields.",
            "dependencies": [
              4
            ],
            "details": "Create backend/scripts/verify_index.py with: 1) Term query tests: search phase=PHASE2, overall_status=NOT_YET_RECRUITING, nct_id exact match. 2) Nested query tests: find trials by sponsor name (AstraZeneca), filter by facility country (United States), search design_outcomes by outcome_type=primary. 3) Range query tests: filter by enrollment >= 100, date range query for start_date. 4) Full-text search tests: multi_match query on brief_title and official_title, search brief_summaries_description for medical terms. 5) Autocomplete test: search_as_you_type query on brief_title.suggest. 6) Aggregation test: get counts by phase, status distribution. Each test should print expected vs actual results and pass/fail status. Exit with non-zero code if any test fails.",
            "status": "pending",
            "testStrategy": "Run verify_index.py after successful ingestion. All 6 query type tests should pass. Verify aggregations return expected phase distribution. Test should complete within 5 seconds. Manual spot-check results against raw JSON data to confirm accuracy.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down ES setup into: 1) Create create_index.py with complete field mapping including keyword fields (phase, overall_status, nct_id), text fields with clinical_analyzer, and search_as_you_type sub-fields for titles, 2) Define nested mappings for sponsors, facilities, design_outcomes, and age arrays with proper field types, 3) Implement ingest.py with document transformation (enrollment string-to-int, null handling, date parsing), 4) Add bulk indexing using elasticsearch-py helpers with error handling and progress reporting, 5) Create verification script with sample queries for each field type (term, nested, range). Each subtask should handle edge cases in the data."
      },
      {
        "id": "4",
        "title": "Claude API LLM Service for Entity Extraction",
        "description": "Implement the LLM service using Claude API (anthropic SDK) to extract structured entities from natural language queries, including domain synonym handling and clarification detection.",
        "details": "1. Create `backend/app/services/llm_service.py`:\n   ```python\n   import anthropic\n   import json\n   from typing import Optional\n   from ..config import get_settings\n   from ..models.entities import ExtractedEntities, LocationFilter\n\n   SYSTEM_PROMPT = '''You are a clinical trials search assistant. Extract structured filters from natural language queries about clinical trials.\n\n   Available fields to extract:\n   - phase: One of PHASE1, PHASE2, PHASE3, PHASE4, EARLY_PHASE1, NA\n   - condition: The medical condition or disease (e.g., \"Breast Cancer\", \"Diabetes\", \"Asthma\")\n   - status: One of RECRUITING, NOT_YET_RECRUITING, COMPLETED, ACTIVE_NOT_RECRUITING, TERMINATED, WITHDRAWN, SUSPENDED\n   - location: Object with city, state, and/or country fields\n   - sponsor: Organization name (e.g., \"AstraZeneca\", \"Pfizer\")\n   - keyword: Specific terms like gene names (BRCA1, EGFR), drug names, or technical terms\n   - age_group: One of \"adult\", \"child\", \"older-adults\"\n   - enrollment_min: Minimum number of participants\n   - enrollment_max: Maximum number of participants\n\n   Domain synonym mappings (translate these automatically):\n   - \"open\", \"recruiting\", \"active\", \"enrolling\" -> status: RECRUITING\n   - \"closed\", \"finished\", \"completed\", \"done\" -> status: COMPLETED\n   - \"upcoming\", \"not started\", \"planned\" -> status: NOT_YET_RECRUITING\n   - \"running\", \"ongoing\" -> status: RECRUITING or ACTIVE_NOT_RECRUITING\n   - \"phase 1\", \"phase I\", \"P1\" -> phase: PHASE1\n   - \"phase 2\", \"phase II\", \"P2\" -> phase: PHASE2\n   - \"phase 3\", \"phase III\", \"P3\" -> phase: PHASE3\n   - \"phase 4\", \"phase IV\", \"P4\" -> phase: PHASE4\n   - \"USA\", \"US\", \"United States\", \"America\" -> location.country: \"United States\"\n   - \"large trials\", \"big studies\" -> enrollment_min: 500\n\n   Output JSON format:\n   {\n     \"phase\": \"PHASE2\" or null,\n     \"condition\": \"disease name\" or null,\n     \"status\": \"RECRUITING\" or null,\n     \"location\": {\"city\": \"\", \"state\": \"\", \"country\": \"\"} or null,\n     \"sponsor\": \"company name\" or null,\n     \"keyword\": \"gene/drug name\" or null,\n     \"age_group\": \"adult\" or null,\n     \"enrollment_min\": 500 or null,\n     \"enrollment_max\": null,\n     \"confidence\": 0.0-1.0,\n     \"clarification\": \"question to ask user\" or null\n   }\n\n   Rules:\n   1. Only extract entities that are clearly stated or strongly implied\n   2. Set confidence based on how clear the query is (1.0 = very clear, 0.5 = ambiguous)\n   3. If the query is ambiguous, misspelled, or too broad, set clarification with a helpful question\n   4. Return null for fields not mentioned in the query\n   5. Always respond with valid JSON only, no explanations'''\n\n   async def extract_entities(query: str) -> ExtractedEntities:\n       \"\"\"Extract structured entities from natural language query using Claude API\"\"\"\n       settings = get_settings()\n       client = anthropic.Anthropic(api_key=settings.anthropic_api_key)\n       \n       try:\n           message = client.messages.create(\n               model=\"claude-sonnet-4-20250514\",\n               max_tokens=1024,\n               system=SYSTEM_PROMPT,\n               messages=[\n                   {\"role\": \"user\", \"content\": f\"Extract entities from this clinical trials search query: \\\"{query}\\\"\"}\n               ]\n           )\n           \n           response_text = message.content[0].text\n           # Parse JSON response\n           data = json.loads(response_text)\n           \n           # Convert location dict to LocationFilter if present\n           if data.get('location'):\n               data['location'] = LocationFilter(**data['location'])\n           \n           return ExtractedEntities(**data)\n           \n       except json.JSONDecodeError:\n           # Fallback if LLM returns invalid JSON\n           return ExtractedEntities(\n               confidence=0.3,\n               clarification=\"I had trouble understanding your query. Could you rephrase it?\"\n           )\n       except Exception as e:\n           return ExtractedEntities(\n               confidence=0.0,\n               clarification=f\"An error occurred. Please try again.\"\n           )\n   ```\n\n2. Add domain constants in `backend/app/utils/synonyms.py` for reference (used in prompt):\n   ```python\n   STATUS_SYNONYMS = {\n       \"open\": \"RECRUITING\",\n       \"recruiting\": \"RECRUITING\",\n       \"closed\": \"COMPLETED\",\n       \"finished\": \"COMPLETED\",\n       \"upcoming\": \"NOT_YET_RECRUITING\",\n       \"running\": \"RECRUITING\",\n   }\n\n   PHASE_MAPPINGS = {\n       \"phase 1\": \"PHASE1\",\n       \"phase i\": \"PHASE1\",\n       \"phase 2\": \"PHASE2\",\n       \"phase ii\": \"PHASE2\",\n       \"phase 3\": \"PHASE3\",\n       \"phase iii\": \"PHASE3\",\n       \"phase 4\": \"PHASE4\",\n       \"phase iv\": \"PHASE4\",\n   }\n   ```",
        "testStrategy": "1. Test with various query types:\n   - \"Phase 3 lung cancer trials in the USA\" -> should extract phase=PHASE3, condition=lung cancer, location.country=United States\n   - \"recruiting diabetes trials\" -> status=RECRUITING, condition=diabetes\n   - \"open melanoma trials\" -> status=RECRUITING (synonym), condition=melanoma\n   - \"List all Phase 2 trials for Breast Cancer associated with BRCA1\" -> phase=PHASE2, condition=Breast Cancer, keyword=BRCA1\n2. Test confidence scoring with clear vs ambiguous queries\n3. Test clarification generation for misspelled conditions\n4. Test edge cases: empty query, gibberish input, only stop words\n5. Verify JSON parsing error handling",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create LLM Service Module with Claude API Client Setup",
            "description": "Create the backend/app/services/llm_service.py module with anthropic SDK client initialization, async patterns, and configuration integration using the Pydantic Settings from config.py.",
            "dependencies": [],
            "details": "Create the llm_service.py file with proper imports (anthropic, json, typing). Initialize the Anthropic client using settings.anthropic_api_key from get_settings(). Implement the async extract_entities() function signature that accepts a query string and returns ExtractedEntities. Use proper async/await patterns for non-blocking I/O. Handle client initialization failures gracefully with appropriate error logging. Ensure the client is created fresh per request or use connection pooling best practices for the anthropic SDK.",
            "status": "pending",
            "testStrategy": "Test client initialization with valid API key from environment. Verify get_settings() is called correctly. Test that missing API key raises appropriate error. Mock the anthropic client to verify proper instantiation parameters. Test async function signature is properly awaitable.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Design Comprehensive System Prompt with Field Definitions and JSON Schema",
            "description": "Create the SYSTEM_PROMPT constant with complete field definitions for all extractable entities (phase, condition, status, location, sponsor, keyword, age_group, enrollment_min/max), valid enum values, and expected JSON output schema.",
            "dependencies": [
              1
            ],
            "details": "Define the SYSTEM_PROMPT as a multi-line string with: 1) Role definition as clinical trials search assistant, 2) Complete list of extractable fields with their types and valid enum values (PHASE1-PHASE4, EARLY_PHASE1, NA for phase; RECRUITING, NOT_YET_RECRUITING, COMPLETED, etc. for status), 3) LocationFilter structure with city/state/country fields, 4) Confidence scoring rules (1.0 = very clear, 0.5 = ambiguous, lower for unclear), 5) JSON output schema with all fields including optional clarification field, 6) Clear rules about only extracting clearly stated entities and returning null for unmentioned fields. Include example output format in the prompt.",
            "status": "pending",
            "testStrategy": "Verify prompt is valid string with no syntax errors. Manually test prompt with Claude API playground to ensure it produces valid JSON. Verify all enum values match the ExtractedEntities model. Test prompt clarity by checking if example queries produce expected structured output.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Domain Synonym Mappings in System Prompt",
            "description": "Add comprehensive domain synonym mappings to the system prompt including status synonyms (open->RECRUITING, closed->COMPLETED), phase variations (phase I/P1->PHASE1), location normalizations (USA/US->United States), and enrollment interpretations (large trials->enrollment_min: 500).",
            "dependencies": [
              2
            ],
            "details": "Extend SYSTEM_PROMPT with detailed synonym mappings section: 1) Status synonyms: open/recruiting/active/enrolling->RECRUITING, closed/finished/completed/done->COMPLETED, upcoming/not started/planned->NOT_YET_RECRUITING, running/ongoing->RECRUITING or ACTIVE_NOT_RECRUITING, 2) Phase mappings: phase 1/phase I/P1->PHASE1 through phase 4/phase IV/P4->PHASE4, 3) Location normalization: USA/US/United States/America->location.country: United States, UK/Britain/England->United Kingdom, 4) Enrollment interpretations: large trials/big studies->enrollment_min: 500, small studies->enrollment_max: 100. Also create backend/app/utils/synonyms.py with STATUS_SYNONYMS and PHASE_MAPPINGS dictionaries for reference and potential server-side validation.",
            "status": "pending",
            "testStrategy": "Test each synonym category with sample queries: 'open cancer trials' should map to status=RECRUITING, 'phase I studies' to phase=PHASE1, 'trials in the US' to location.country='United States'. Verify both common and edge case synonyms work correctly. Test that original enum values still work (RECRUITING should still work directly).",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Clarification Detection Logic for Ambiguous Queries",
            "description": "Implement clarification detection within the system prompt for ambiguous, misspelled, overly broad, or gibberish queries, including confidence scoring logic and helpful clarification question generation.",
            "dependencies": [
              2,
              3
            ],
            "details": "Enhance SYSTEM_PROMPT with clarification rules: 1) Set confidence based on query clarity (1.0 = all terms recognized and unambiguous, 0.7-0.9 = mostly clear with minor uncertainty, 0.5-0.7 = some ambiguity, below 0.5 = significant issues), 2) Trigger clarification for: misspelled medical terms that can't be auto-corrected, overly broad queries like just 'trials' or 'medicine', gibberish or unrelated queries, conflicting filters (e.g., completed AND recruiting), 3) Generate helpful clarification questions: 'Did you mean [suggestion]?', 'Which condition are you interested in?', 'Could you specify a phase or status?', 4) Handle edge cases: empty queries, single-word queries, queries with only stop words. The clarification field should be null when query is clear enough (confidence >= 0.7).",
            "status": "pending",
            "testStrategy": "Test with ambiguous queries: 'trials' should return low confidence with clarification asking for condition. Test misspellings: 'diabeties' should still extract diabetes with slight confidence reduction. Test gibberish: 'asdfasdf' should return confidence near 0 with clarification. Test conflicting: 'completed recruiting trials' should ask for clarification. Verify clear queries have null clarification.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement JSON Response Parsing with Robust Error Handling",
            "description": "Implement the complete extract_entities() function with Claude API message creation, JSON response parsing, LocationFilter conversion, and comprehensive error handling for malformed LLM output, API failures, and edge cases.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Complete the extract_entities() async function: 1) Call client.messages.create() with model='claude-sonnet-4-20250514', max_tokens=1024, system=SYSTEM_PROMPT, and user message with query, 2) Extract response text from message.content[0].text, 3) Parse JSON with json.loads() wrapped in try/except, 4) Convert location dict to LocationFilter object if present, 5) Construct and return ExtractedEntities using **data unpacking, 6) Handle JSONDecodeError with fallback ExtractedEntities(confidence=0.3, clarification='I had trouble understanding your query...'), 7) Handle anthropic.APIError with appropriate fallback and logging, 8) Handle unexpected exceptions with generic fallback, 9) Add input validation for empty/whitespace-only queries returning immediate fallback. Consider using regex to extract JSON from response if LLM includes extra text.",
            "status": "pending",
            "testStrategy": "Test successful parsing with mock valid JSON response. Test JSONDecodeError handling by mocking malformed response. Test API error handling by mocking anthropic.APIError. Test empty query returns appropriate fallback. Test location dict conversion to LocationFilter. Verify all ExtractedEntities fields are properly populated. Test response with extra text around JSON is handled gracefully.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create Unit Tests with Diverse Query Types",
            "description": "Create comprehensive unit tests in backend/tests/test_llm_service.py covering simple queries, complex multi-filter queries, ambiguous queries, misspelled queries, gibberish input, and edge cases with proper mocking of the Claude API.",
            "dependencies": [
              5
            ],
            "details": "Create test file with pytest fixtures for mocking anthropic client. Test categories: 1) Simple queries: 'Phase 3 cancer trials' -> phase=PHASE3, condition=cancer; 'recruiting diabetes studies' -> status=RECRUITING, condition=diabetes, 2) Complex queries: 'Phase 2 lung cancer trials in California sponsored by Pfizer' -> all fields extracted correctly, 3) Synonym handling: 'open melanoma trials' -> status=RECRUITING; 'P1 studies' -> phase=PHASE1, 4) Ambiguous queries: 'trials' -> low confidence, has clarification; 'medicine studies' -> asks for specifics, 5) Misspellings: 'diabeties trials' -> still extracts diabetes with confidence < 1.0, 6) Gibberish: 'asdfghjkl' -> confidence near 0, has clarification, 7) Edge cases: empty string, whitespace only, very long query, SQL injection attempt, 8) Error handling: test JSONDecodeError fallback, API error fallback. Use unittest.mock.patch or pytest-mock to mock anthropic.Anthropic client.",
            "status": "pending",
            "testStrategy": "Run pytest with coverage to ensure >90% code coverage on llm_service.py. Verify all test cases pass. Test isolation by ensuring no actual API calls are made (all mocked). Verify fixtures properly reset between tests. Run tests multiple times to ensure deterministic behavior. Check test execution time is under 5 seconds (no real API calls).",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down LLM service into: 1) Create llm_service.py with Claude API client setup using anthropic SDK and proper async patterns, 2) Design comprehensive system prompt with field definitions, valid enum values, and expected JSON output schema, 3) Implement domain synonym mappings within the prompt (open->RECRUITING, phase variations, country normalizations), 4) Add clarification detection logic for ambiguous/misspelled/broad queries with confidence scoring, 5) Implement JSON response parsing with error handling for malformed LLM output, 6) Create unit tests with diverse query types (simple, complex, ambiguous, gibberish). Each subtask should handle edge cases and fallback scenarios."
      },
      {
        "id": "5",
        "title": "Elasticsearch Query Builder Service",
        "description": "Implement the service that converts extracted entities into optimized Elasticsearch Query DSL with proper handling of nested fields, term queries, and multi-match searches.",
        "details": "1. Create `backend/app/services/es_service.py`:\n   ```python\n   from elasticsearch import Elasticsearch\n   from typing import Optional, Dict, Any, List\n   from ..config import get_settings\n   from ..models.entities import ExtractedEntities\n   from ..models.schemas import TrialResult, Sponsor, Facility\n\n   class ElasticsearchService:\n       def __init__(self):\n           settings = get_settings()\n           self.es = Elasticsearch([settings.es_url])\n           self.index = settings.es_index\n\n       def build_query(self, entities: ExtractedEntities) -> Dict[str, Any]:\n           \"\"\"Build Elasticsearch query DSL from extracted entities\"\"\"\n           must_clauses = []\n           filter_clauses = []\n           should_clauses = []\n\n           # Phase - exact match filter\n           if entities.phase:\n               filter_clauses.append({\"term\": {\"phase\": entities.phase}})\n\n           # Status - exact match filter\n           if entities.status:\n               filter_clauses.append({\"term\": {\"overall_status\": entities.status}})\n\n           # Condition - text match across title and description\n           if entities.condition:\n               must_clauses.append({\n                   \"multi_match\": {\n                       \"query\": entities.condition,\n                       \"fields\": [\"brief_title^3\", \"official_title^2\", \"brief_summaries_description\"],\n                       \"type\": \"best_fields\",\n                       \"fuzziness\": \"AUTO\"\n                   }\n               })\n\n           # Location - nested query on facilities\n           if entities.location:\n               location_filters = []\n               if entities.location.country:\n                   location_filters.append({\"term\": {\"facilities.country\": entities.location.country}})\n               if entities.location.state:\n                   location_filters.append({\"term\": {\"facilities.state\": entities.location.state}})\n               if entities.location.city:\n                   location_filters.append({\"term\": {\"facilities.city\": entities.location.city}})\n               \n               if location_filters:\n                   filter_clauses.append({\n                       \"nested\": {\n                           \"path\": \"facilities\",\n                           \"query\": {\"bool\": {\"must\": location_filters}}\n                       }\n                   })\n\n           # Sponsor - nested query\n           if entities.sponsor:\n               filter_clauses.append({\n                   \"nested\": {\n                       \"path\": \"sponsors\",\n                       \"query\": {\n                           \"match\": {\"sponsors.name\": entities.sponsor}\n                       }\n                   }\n               })\n\n           # Keyword/Gene - multi-match across all text fields\n           if entities.keyword:\n               must_clauses.append({\n                   \"multi_match\": {\n                       \"query\": entities.keyword,\n                       \"fields\": [\n                           \"brief_title^2\",\n                           \"official_title^2\",\n                           \"brief_summaries_description\",\n                           \"detailed_description\"\n                       ],\n                       \"type\": \"phrase_prefix\"\n                   }\n               })\n\n           # Age group - nested query on age array\n           if entities.age_group:\n               filter_clauses.append({\n                   \"nested\": {\n                       \"path\": \"age\",\n                       \"query\": {\"term\": {\"age.age_category\": entities.age_group}}\n                   }\n               })\n\n           # Enrollment range\n           if entities.enrollment_min or entities.enrollment_max:\n               range_query = {}\n               if entities.enrollment_min:\n                   range_query[\"gte\"] = entities.enrollment_min\n               if entities.enrollment_max:\n                   range_query[\"lte\"] = entities.enrollment_max\n               filter_clauses.append({\"range\": {\"enrollment\": range_query}})\n\n           # Build final query\n           query = {\"bool\": {}}\n           if must_clauses:\n               query[\"bool\"][\"must\"] = must_clauses\n           if filter_clauses:\n               query[\"bool\"][\"filter\"] = filter_clauses\n           if should_clauses:\n               query[\"bool\"][\"should\"] = should_clauses\n\n           # If no clauses, match all\n           if not must_clauses and not filter_clauses:\n               query = {\"match_all\": {}}\n\n           return query\n\n       async def search(self, entities: ExtractedEntities, page: int = 1, page_size: int = 10) -> tuple[List[TrialResult], int]:\n           \"\"\"Execute search and return results with total count\"\"\"\n           query = self.build_query(entities)\n           \n           response = self.es.search(\n               index=self.index,\n               body={\n                   \"query\": query,\n                   \"from\": (page - 1) * page_size,\n                   \"size\": page_size,\n                   \"sort\": [{\"_score\": \"desc\"}, {\"enrollment\": \"desc\"}],\n                   \"_source\": [\n                       \"nct_id\", \"brief_title\", \"official_title\", \"phase\",\n                       \"overall_status\", \"enrollment\", \"sponsors\", \"facilities\",\n                       \"brief_summaries_description\", \"start_date\", \"age\"\n                   ]\n               }\n           )\n           \n           results = []\n           for hit in response[\"hits\"][\"hits\"]:\n               source = hit[\"_source\"]\n               results.append(TrialResult(\n                   nct_id=source[\"nct_id\"],\n                   brief_title=source[\"brief_title\"],\n                   official_title=source.get(\"official_title\"),\n                   phase=source.get(\"phase\"),\n                   overall_status=source.get(\"overall_status\"),\n                   enrollment=source.get(\"enrollment\"),\n                   sponsors=[Sponsor(**s) for s in source.get(\"sponsors\", [])],\n                   facilities=[Facility(**f) for f in source.get(\"facilities\", [])[:3]],\n                   brief_summaries_description=source.get(\"brief_summaries_description\"),\n                   start_date=source.get(\"start_date\"),\n                   age=source.get(\"age\", [])\n               ))\n           \n           total = response[\"hits\"][\"total\"][\"value\"]\n           return results, total\n\n   es_service = ElasticsearchService()\n   ```",
        "testStrategy": "1. Unit test query building with mock entities:\n   - Phase only -> term filter\n   - Condition only -> multi_match\n   - Location with nested query\n   - Combined filters\n2. Integration test against live ES:\n   - Search for \"Phase 2 Asthma\" and verify relevant results\n   - Verify pagination works correctly\n   - Test enrollment range queries\n3. Verify nested query syntax for facilities, sponsors, and age\n4. Test empty entities returns match_all query\n5. Benchmark query performance on full dataset",
        "priority": "high",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create es_service.py with Elasticsearch Client Initialization",
            "description": "Set up the ElasticsearchService class with proper client initialization, connection handling, and configuration loading from settings.",
            "dependencies": [],
            "details": "Create `backend/app/services/es_service.py` with the ElasticsearchService class. Initialize the Elasticsearch client using settings from `get_settings()` including `es_url` and `es_index`. Implement proper imports for Elasticsearch, typing modules, config, and model dependencies (ExtractedEntities, TrialResult, Sponsor, Facility). Add connection error handling and ensure the service can gracefully handle connection failures. Create a module-level singleton instance `es_service = ElasticsearchService()` for dependency injection.",
            "status": "pending",
            "testStrategy": "Test client initialization with valid and invalid ES URLs. Verify connection handling by mocking Elasticsearch client. Test that settings are properly loaded and applied to the client configuration.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement build_query Method with Bool Query Construction",
            "description": "Create the core build_query method that constructs Elasticsearch bool queries with must, filter, and should clause arrays.",
            "dependencies": [
              1
            ],
            "details": "Implement `build_query(self, entities: ExtractedEntities) -> Dict[str, Any]` method that initializes empty lists for must_clauses, filter_clauses, and should_clauses. Build the final bool query structure by conditionally adding these arrays to the query dict only when they contain clauses. Handle the edge case where no entities are provided by returning a `match_all` query. Ensure proper typing with Dict[str, Any] return type. The method should gracefully handle None/missing values for all entity fields.",
            "status": "pending",
            "testStrategy": "Unit test with empty ExtractedEntities returns match_all query. Test that bool query structure is correctly formed with various clause combinations. Verify None values don't cause errors.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Query Clause Builders for Simple Entity Types",
            "description": "Implement query clause builders for phase, status (term filters), condition/keyword (multi_match), and enrollment (range queries).",
            "dependencies": [
              2
            ],
            "details": "Within build_query, add clause builders: 1) Phase - term filter on 'phase' field added to filter_clauses, 2) Status - term filter on 'overall_status' field, 3) Condition - multi_match query on brief_title^3, official_title^2, brief_summaries_description with type='best_fields' and fuzziness='AUTO' added to must_clauses, 4) Keyword - multi_match with phrase_prefix type on title and description fields, 5) Enrollment range - range query with optional gte/lte bounds based on enrollment_min/enrollment_max. Each builder should check for None before adding clauses.",
            "status": "pending",
            "testStrategy": "Test each clause builder independently: phase='PHASE2' produces correct term filter, condition='asthma' produces multi_match with boosted fields, enrollment range with min-only, max-only, and both bounds. Verify query structure matches expected Elasticsearch DSL format.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Nested Queries for Location, Sponsor, and Age Group",
            "description": "Create nested query builders for facilities (location), sponsors, and age arrays with proper path handling.",
            "dependencies": [
              2
            ],
            "details": "Implement nested queries: 1) Location - build nested query on 'facilities' path with bool/must containing term filters for country, state, city (only include filters for non-None values), 2) Sponsor - nested query on 'sponsors' path with match query on 'sponsors.name', 3) Age group - nested query on 'age' path with term filter on 'age.age_category'. Each nested query must specify the correct path and handle partial data (e.g., location with only country specified). Add location_filters list construction that only includes non-None location components.",
            "status": "pending",
            "testStrategy": "Test location nested query with all combinations: country-only, state+country, city+state+country. Test sponsor nested query produces correct path and match structure. Test age_group nested query. Verify nested query structure matches ES nested query requirements.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create Search Method with Pagination and Result Mapping",
            "description": "Implement the async search method with pagination, sorting, _source field selection, and result mapping to TrialResult models.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement `async def search(self, entities: ExtractedEntities, page: int = 1, page_size: int = 10) -> tuple[List[TrialResult], int]`. Calculate 'from' offset as (page-1)*page_size. Execute search with: query from build_query, from/size for pagination, sort by _score desc then enrollment desc, _source limited to required fields (nct_id, brief_title, official_title, phase, overall_status, enrollment, sponsors, facilities, brief_summaries_description, start_date, age). Map response hits to TrialResult objects, converting sponsors to Sponsor models and limiting facilities to first 3 entries as Facility models. Return tuple of results list and total count from response['hits']['total']['value'].",
            "status": "pending",
            "testStrategy": "Test pagination calculates correct from/size values. Mock ES response and verify result mapping to TrialResult is correct. Test facilities are limited to 3. Test empty response returns empty list with 0 total. Verify sorting parameters are correctly applied.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Add Unit Tests for Query DSL Output",
            "description": "Create comprehensive unit tests for query building with various entity combinations and edge cases.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Create `backend/tests/test_es_service.py` with unit tests covering: 1) Empty entities -> match_all, 2) Single field extraction (phase only, condition only, location only), 3) Multiple combined fields, 4) All nested query types (location with partial data, sponsor, age_group), 5) Range queries with min-only, max-only, both bounds, 6) Verify multi_match field boosting and fuzziness settings, 7) Test search method pagination offset calculation, 8) Test result mapping with mock ES responses. Use pytest fixtures for ExtractedEntities with various configurations. Mock Elasticsearch client for search tests.",
            "status": "pending",
            "testStrategy": "Run pytest on test_es_service.py. Verify 100% coverage of build_query paths. Test each query type produces valid Elasticsearch DSL that can be validated against ES query structure. Integration test against local ES instance if available.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down ES query builder into: 1) Create es_service.py with Elasticsearch client initialization and connection handling, 2) Implement build_query method with bool query construction (must/filter/should clauses), 3) Add query clause builders for each entity type: term filters for phase/status, multi_match for condition/keyword, range for enrollment, 4) Implement nested queries for location (facilities), sponsor, and age_group with proper path handling, 5) Create search method with pagination, sorting, and _source field selection, 6) Add unit tests for query DSL output with various entity combinations. Each subtask should handle null/missing entity values gracefully."
      },
      {
        "id": "6",
        "title": "Auto-Suggestion Service Implementation",
        "description": "Implement the suggestion service using Elasticsearch search_as_you_type fields to provide type-ahead suggestions as users type their queries.",
        "details": "1. Create `backend/app/services/suggestion.py`:\n   ```python\n   from elasticsearch import Elasticsearch\n   from typing import List\n   from ..config import get_settings\n\n   class SuggestionService:\n       def __init__(self):\n           settings = get_settings()\n           self.es = Elasticsearch([settings.es_url])\n           self.index = settings.es_index\n\n       async def get_suggestions(self, prefix: str, limit: int = 10) -> List[str]:\n           \"\"\"Get type-ahead suggestions using search_as_you_type\"\"\"\n           if not prefix or len(prefix) < 2:\n               return []\n\n           response = self.es.search(\n               index=self.index,\n               body={\n                   \"size\": 0,\n                   \"query\": {\n                       \"bool\": {\n                           \"should\": [\n                               {\n                                   \"multi_match\": {\n                                       \"query\": prefix,\n                                       \"type\": \"bool_prefix\",\n                                       \"fields\": [\n                                           \"brief_title.suggest\",\n                                           \"brief_title.suggest._2gram\",\n                                           \"brief_title.suggest._3gram\"\n                                       ]\n                                   }\n                               }\n                           ]\n                       }\n                   },\n                   \"aggs\": {\n                       \"unique_conditions\": {\n                           \"terms\": {\n                               \"field\": \"phase\",\n                               \"size\": 5\n                           }\n                       },\n                       \"title_suggestions\": {\n                           \"significant_text\": {\n                               \"field\": \"brief_title\",\n                               \"filter_duplicate_text\": True,\n                               \"size\": limit\n                           }\n                       }\n                   }\n               }\n           )\n\n           # Extract suggestions from aggregations\n           suggestions = []\n           \n           # Get significant terms from titles\n           if \"aggregations\" in response:\n               sig_terms = response[\"aggregations\"].get(\"title_suggestions\", {}).get(\"buckets\", [])\n               for bucket in sig_terms:\n                   suggestions.append(bucket[\"key\"])\n\n           # Fallback: simple prefix search on titles\n           if not suggestions:\n               prefix_response = self.es.search(\n                   index=self.index,\n                   body={\n                       \"size\": limit,\n                       \"query\": {\n                           \"multi_match\": {\n                               \"query\": prefix,\n                               \"type\": \"phrase_prefix\",\n                               \"fields\": [\"brief_title\", \"official_title\"]\n                           }\n                       },\n                       \"_source\": [\"brief_title\"]\n                   }\n               )\n               \n               seen = set()\n               for hit in prefix_response[\"hits\"][\"hits\"]:\n                   title = hit[\"_source\"].get(\"brief_title\", \"\")\n                   # Extract first few words as suggestion\n                   words = title.split()[:6]\n                   suggestion = \" \".join(words)\n                   if suggestion.lower() not in seen:\n                       seen.add(suggestion.lower())\n                       suggestions.append(suggestion)\n\n           return suggestions[:limit]\n\n   suggestion_service = SuggestionService()\n   ```\n\n2. Enhance for condition-specific suggestions:\n   ```python\n   async def get_condition_suggestions(self, prefix: str) -> List[str]:\n       \"\"\"Get common condition names matching prefix\"\"\"\n       # Pre-defined common conditions for fast suggestions\n       common_conditions = [\n           \"Breast Cancer\", \"Lung Cancer\", \"Diabetes\", \"Asthma\",\n           \"COVID-19\", \"Heart Disease\", \"Alzheimer's\", \"Melanoma\",\n           \"Leukemia\", \"Rheumatoid Arthritis\", \"Multiple Sclerosis\"\n       ]\n       \n       matching = [c for c in common_conditions \n                   if c.lower().startswith(prefix.lower())]\n       return matching[:5]\n   ```",
        "testStrategy": "1. Test with various prefixes: \"can\" -> Cancer suggestions, \"dia\" -> Diabetes\n2. Verify minimum character requirement (2 chars)\n3. Test response time is under 100ms for type-ahead UX\n4. Verify deduplication of similar suggestions\n5. Test empty prefix returns empty list\n6. Integration test with frontend debounced input",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create suggestion.py with Elasticsearch client and index configuration",
            "description": "Set up the base SuggestionService class with Elasticsearch connection, index configuration, and core initialization logic including settings integration.",
            "dependencies": [],
            "details": "Create `backend/app/services/suggestion.py` with the SuggestionService class. Initialize Elasticsearch client using settings from get_settings() (es_url and es_index). Include proper imports for elasticsearch, typing (List), and config module. Set up the singleton instance pattern with `suggestion_service = SuggestionService()`. Ensure the class follows the same patterns established in other services (es_service.py). Add minimum prefix length constant (MIN_PREFIX_LENGTH = 2) and default limit constant (DEFAULT_LIMIT = 10) for performance optimization.",
            "status": "pending",
            "testStrategy": "Verify module imports correctly without errors. Test that SuggestionService initializes with valid Elasticsearch connection. Confirm settings are properly loaded from config. Test that the singleton instance is accessible from other modules.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement get_suggestions method with search_as_you_type and bool_prefix multi_match",
            "description": "Implement the primary get_suggestions method using Elasticsearch search_as_you_type field type with bool_prefix multi_match query on brief_title.suggest fields including _2gram and _3gram analyzers.",
            "dependencies": [
              1
            ],
            "details": "Implement `async def get_suggestions(self, prefix: str, limit: int = 10) -> List[str]` method. Add early return for empty prefix or prefix < 2 characters to optimize performance. Build Elasticsearch query using multi_match with type='bool_prefix' targeting 'brief_title.suggest', 'brief_title.suggest._2gram', and 'brief_title.suggest._3gram' fields. Use aggregations with 'significant_text' on 'brief_title' field with filter_duplicate_text=True for deduplication. Set size=0 on main query since we only need aggregations. Extract suggestions from aggregations buckets. Apply limit parameter to final results.",
            "status": "pending",
            "testStrategy": "Test with prefix 'can' returns Cancer-related suggestions. Test with prefix 'dia' returns Diabetes suggestions. Verify empty string returns empty list. Verify single character returns empty list. Test response time is under 100ms for acceptable type-ahead UX. Verify no duplicate suggestions in results.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add fallback logic with phrase_prefix query and title extraction",
            "description": "Implement fallback mechanism using phrase_prefix query when the primary search_as_you_type approach returns no results, including intelligent title word extraction and deduplication.",
            "dependencies": [
              1,
              2
            ],
            "details": "Extend get_suggestions method with fallback logic triggered when primary aggregation returns empty results. Implement secondary Elasticsearch query using multi_match with type='phrase_prefix' on 'brief_title' and 'official_title' fields. Set _source to only return 'brief_title' for performance. Extract first 6 words from matching titles as suggestion text. Implement case-insensitive deduplication using a seen set (convert to lowercase for comparison). Ensure fallback respects the same limit parameter. Add the fallback results to suggestions list only if primary approach yielded no results.",
            "status": "pending",
            "testStrategy": "Test fallback triggers when primary query returns empty. Verify deduplication works (same title different case not duplicated). Test that fallback respects limit parameter. Verify extracted suggestions contain meaningful partial titles (first 6 words). Test edge cases like very short titles.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create get_condition_suggestions helper with common condition names",
            "description": "Implement a fast condition-specific suggestion helper method using a predefined list of common medical conditions for instant matching without Elasticsearch queries.",
            "dependencies": [
              1
            ],
            "details": "Implement `async def get_condition_suggestions(self, prefix: str) -> List[str]` method. Define a constant list of common clinical trial conditions: 'Breast Cancer', 'Lung Cancer', 'Diabetes', 'Asthma', 'COVID-19', 'Heart Disease', 'Alzheimer\\'s', 'Melanoma', 'Leukemia', 'Rheumatoid Arthritis', 'Multiple Sclerosis'. Use case-insensitive prefix matching with str.lower().startswith(). Return maximum 5 matching conditions for fast response. This provides instant suggestions without Elasticsearch latency for common conditions. Consider adding this list as a class constant for maintainability.",
            "status": "pending",
            "testStrategy": "Test 'brea' returns 'Breast Cancer'. Test 'lung' returns 'Lung Cancer'. Test case insensitivity ('DIA' matches 'Diabetes'). Verify maximum 5 results returned. Test no matches returns empty list. Verify response time is near-instant (no ES query).",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down suggestion service into: 1) Create suggestion.py with ES client and index configuration, 2) Implement get_suggestions method using search_as_you_type with bool_prefix multi_match on title suggest fields, 3) Add fallback logic with phrase_prefix query and title extraction for when primary approach returns no results, 4) Create get_condition_suggestions helper with common condition names for fast matching. Each subtask should include deduplication and performance optimization (limit, minimum prefix length)."
      },
      {
        "id": "7",
        "title": "FastAPI Search and Suggestion Endpoints",
        "description": "Implement the main FastAPI application with /search and /suggest endpoints, CORS configuration, error handling middleware, and proper dependency injection.",
        "details": "1. Create `backend/app/routers/search.py`:\n   ```python\n   from fastapi import APIRouter, Query, HTTPException\n   from typing import Optional\n   from ..services.llm_service import extract_entities\n   from ..services.es_service import es_service\n   from ..services.suggestion import suggestion_service\n   from ..models.schemas import SearchResponse, SuggestionResponse, ErrorResponse\n\n   router = APIRouter(prefix=\"/api\", tags=[\"search\"])\n\n   @router.get(\"/search/{query}\", response_model=SearchResponse)\n   async def search_trials(\n       query: str,\n       page: int = Query(default=1, ge=1),\n       page_size: int = Query(default=10, ge=1, le=100)\n   ):\n       \"\"\"Search clinical trials using natural language query\"\"\"\n       try:\n           # Extract entities using LLM\n           entities = await extract_entities(query)\n           \n           # Search Elasticsearch\n           results, total = await es_service.search(entities, page, page_size)\n           \n           return SearchResponse(\n               query_interpretation=entities,\n               results=results,\n               total=total,\n               page=page,\n               page_size=page_size,\n               clarification=entities.clarification\n           )\n       except Exception as e:\n           raise HTTPException(status_code=500, detail=str(e))\n\n   @router.get(\"/suggest\", response_model=SuggestionResponse)\n   async def get_suggestions(\n       q: str = Query(..., min_length=2, description=\"Partial query text\")\n   ):\n       \"\"\"Get type-ahead suggestions for partial query\"\"\"\n       try:\n           suggestions = await suggestion_service.get_suggestions(q)\n           return SuggestionResponse(suggestions=suggestions)\n       except Exception as e:\n           raise HTTPException(status_code=500, detail=str(e))\n   ```\n\n2. Create `backend/app/main.py`:\n   ```python\n   from fastapi import FastAPI, Request\n   from fastapi.middleware.cors import CORSMiddleware\n   from fastapi.responses import JSONResponse\n   from .routers import search\n   from .config import get_settings\n\n   app = FastAPI(\n       title=\"Clinical Trials Search API\",\n       description=\"Natural language search for clinical trials\",\n       version=\"1.0.0\"\n   )\n\n   # CORS middleware for frontend\n   app.add_middleware(\n       CORSMiddleware,\n       allow_origins=[\n           \"http://localhost:5173\",  # Vite dev server\n           \"http://localhost:3000\",\n           \"http://127.0.0.1:5173\"\n       ],\n       allow_credentials=True,\n       allow_methods=[\"*\"],\n       allow_headers=[\"*\"],\n   )\n\n   # Global exception handler\n   @app.exception_handler(Exception)\n   async def global_exception_handler(request: Request, exc: Exception):\n       return JSONResponse(\n           status_code=500,\n           content={\"error\": \"Internal server error\", \"detail\": str(exc)}\n       )\n\n   # Include routers\n   app.include_router(search.router)\n\n   @app.get(\"/health\")\n   async def health_check():\n       return {\"status\": \"healthy\"}\n\n   if __name__ == \"__main__\":\n       import uvicorn\n       uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n   ```\n\n3. Verify OpenAPI documentation at /docs endpoint",
        "testStrategy": "1. Manual API testing with curl:\n   - `curl 'http://localhost:8000/api/search/Phase%203%20lung%20cancer'`\n   - `curl 'http://localhost:8000/api/suggest?q=can'`\n2. Test CORS headers are present in response\n3. Test pagination: page=2, page_size=5\n4. Test error handling with invalid queries\n5. Verify health endpoint returns 200\n6. Test OpenAPI docs at /docs\n7. Load test with multiple concurrent requests",
        "priority": "high",
        "dependencies": [
          "4",
          "5",
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create main.py with FastAPI App Initialization and CORS Configuration",
            "description": "Implement the main FastAPI application entry point with proper app initialization, CORS middleware configured for Vite dev server origins, and global exception handler for consistent error responses.",
            "dependencies": [],
            "details": "Create `backend/app/main.py` with FastAPI app instance configured with title='Clinical Trials Search API', description, and version. Add CORSMiddleware with allow_origins for localhost:5173, localhost:3000, and 127.0.0.1:5173. Set allow_credentials=True, allow_methods=['*'], allow_headers=['*']. Implement global exception handler using @app.exception_handler(Exception) that returns JSONResponse with status_code=500 and structured error content including 'error' and 'detail' fields. Add uvicorn runner in __main__ block with host='0.0.0.0' and port=8000. Import get_settings from config for environment-based configuration.",
            "status": "pending",
            "testStrategy": "Test CORS headers by making requests from different origins using curl with -H 'Origin: http://localhost:5173'. Verify Access-Control-Allow-Origin header in response. Test global exception handler by triggering an error and verifying JSON error response format with correct status code.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Search Router with /api/search/{query} Endpoint and Pagination",
            "description": "Implement the search.py router file with the /api/search/{query} GET endpoint that accepts pagination parameters with proper validation constraints.",
            "dependencies": [
              1
            ],
            "details": "Create `backend/app/routers/search.py` with APIRouter configured with prefix='/api' and tags=['search']. Define the search_trials endpoint at GET '/search/{query}' with path parameter query (str) and Query parameters: page (int, default=1, ge=1) and page_size (int, default=10, ge=1, le=100). Set response_model=SearchResponse. Add proper docstring explaining the endpoint purpose. Import required dependencies: APIRouter, Query, HTTPException from fastapi, and the service modules (llm_service, es_service) and schema models (SearchResponse). Include the router in main.py using app.include_router(search.router).",
            "status": "pending",
            "testStrategy": "Test endpoint with curl: GET /api/search/cancer?page=1&page_size=10. Verify pagination validation by testing page=0 (should fail), page_size=101 (should fail), and valid values. Check OpenAPI schema at /docs shows correct parameter constraints.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Search Endpoint Logic with Entity Extraction and ES Query Pipeline",
            "description": "Complete the search endpoint implementation by wiring together the LLM entity extraction, Elasticsearch query building, and result formatting into a coherent pipeline.",
            "dependencies": [
              2
            ],
            "details": "Inside the search_trials endpoint function: 1) Call await extract_entities(query) from llm_service to get ExtractedEntities object, 2) Pass entities to await es_service.search(entities, page, page_size) which returns (results, total) tuple, 3) Construct and return SearchResponse with query_interpretation=entities, results=results, total=total, page=page, page_size=page_size, clarification=entities.clarification. Wrap entire logic in try/except block, catching Exception and raising HTTPException(status_code=500, detail=str(e)). Add logging using Python logging module to log incoming queries and any errors for debugging purposes.",
            "status": "pending",
            "testStrategy": "Test full pipeline with curl: GET /api/search/Phase%203%20lung%20cancer. Verify response contains query_interpretation with extracted entities, results array, total count, and pagination info. Test error handling by mocking service failures and verifying 500 response with error details.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add /api/suggest Endpoint with Query Validation",
            "description": "Implement the suggestion endpoint that provides type-ahead suggestions for partial query text with proper input validation.",
            "dependencies": [
              1
            ],
            "details": "Add get_suggestions endpoint to search.py router at GET '/suggest' with response_model=SuggestionResponse. Accept query parameter q using Query(..., min_length=2, description='Partial query text') where ... makes it required. Call await suggestion_service.get_suggestions(q) to fetch suggestions. Return SuggestionResponse(suggestions=suggestions). Implement try/except block with HTTPException(status_code=500, detail=str(e)) for error handling. Import suggestion_service from services and SuggestionResponse from schemas. Add logging for suggestion requests.",
            "status": "pending",
            "testStrategy": "Test with curl: GET /api/suggest?q=can and verify suggestions returned. Test min_length validation with q=a (should fail with 422). Test empty query parameter (should fail). Verify response time is acceptable for type-ahead UX (<100ms target).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Health Check Endpoint and OpenAPI Documentation Configuration",
            "description": "Implement the health check endpoint for service monitoring and configure OpenAPI documentation with proper metadata and examples.",
            "dependencies": [
              1
            ],
            "details": "Add health_check endpoint at GET '/health' in main.py that returns {'status': 'healthy'}. This endpoint should be simple and not include complex logic to ensure reliable health checking. Enhance FastAPI app initialization with additional OpenAPI metadata: contact info, license, terms_of_service if applicable. Add response examples to endpoints using response_model_examples or OpenAPI extra schema. Verify /docs (Swagger UI) and /redoc endpoints are accessible and display correct API documentation. Add tags_metadata to describe the 'search' tag. Consider adding a /ready endpoint that checks ES connectivity for Kubernetes-style readiness probes.",
            "status": "pending",
            "testStrategy": "Verify health endpoint: curl http://localhost:8000/health returns {\"status\": \"healthy\"}. Access /docs in browser and verify Swagger UI loads with correct API title, description, and version. Test all endpoints appear with proper documentation including parameters, response schemas, and examples.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down FastAPI endpoints into: 1) Create main.py with FastAPI app initialization, CORS middleware configuration for Vite dev server origins, and global exception handler, 2) Create search.py router with /api/search/{query} endpoint accepting pagination params (page, page_size with validation), 3) Implement search endpoint logic: call extract_entities -> build_query -> search -> return SearchResponse, 4) Add /api/suggest endpoint with query param validation (min_length=2) calling suggestion_service, 5) Add health check endpoint and OpenAPI documentation configuration. Each subtask should include proper error handling and logging."
      },
      {
        "id": "8",
        "title": "Frontend API Client and Core Components",
        "description": "Implement the React frontend API client service and core UI components including SearchBar with debounced suggestions, QueryInterpretation display, and result card components.",
        "details": "1. Create `frontend/src/services/api.ts`:\n   ```typescript\n   import type { SearchResponse, SuggestionResponse } from '../types';\n\n   const API_BASE = 'http://localhost:8000/api';\n\n   export async function searchTrials(\n     query: string,\n     page: number = 1,\n     pageSize: number = 10\n   ): Promise<SearchResponse> {\n     const response = await fetch(\n       `${API_BASE}/search/${encodeURIComponent(query)}?page=${page}&page_size=${pageSize}`\n     );\n     if (!response.ok) {\n       throw new Error(`Search failed: ${response.statusText}`);\n     }\n     return response.json();\n   }\n\n   export async function getSuggestions(prefix: string): Promise<string[]> {\n     if (prefix.length < 2) return [];\n     const response = await fetch(\n       `${API_BASE}/suggest?q=${encodeURIComponent(prefix)}`\n     );\n     if (!response.ok) return [];\n     const data: SuggestionResponse = await response.json();\n     return data.suggestions;\n   }\n   ```\n\n2. Create `frontend/src/components/SearchBar.tsx`:\n   ```tsx\n   import { useState, useCallback, useRef, useEffect } from 'react';\n   import { getSuggestions } from '../services/api';\n\n   interface SearchBarProps {\n     onSearch: (query: string) => void;\n     isLoading: boolean;\n   }\n\n   const EXAMPLE_QUERIES = [\n     \"Phase 3 lung cancer trials in the USA\",\n     \"recruiting diabetes trials near Boston\",\n     \"BRCA1 breast cancer studies\",\n     \"open melanoma trials for adults\"\n   ];\n\n   export function SearchBar({ onSearch, isLoading }: SearchBarProps) {\n     const [query, setQuery] = useState('');\n     const [suggestions, setSuggestions] = useState<string[]>([]);\n     const [showSuggestions, setShowSuggestions] = useState(false);\n     const [placeholderIndex, setPlaceholderIndex] = useState(0);\n     const debounceRef = useRef<NodeJS.Timeout>();\n\n     // Cycle through example placeholders\n     useEffect(() => {\n       const interval = setInterval(() => {\n         setPlaceholderIndex((i) => (i + 1) % EXAMPLE_QUERIES.length);\n       }, 4000);\n       return () => clearInterval(interval);\n     }, []);\n\n     const handleInputChange = useCallback((value: string) => {\n       setQuery(value);\n       \n       // Debounce suggestions\n       if (debounceRef.current) clearTimeout(debounceRef.current);\n       debounceRef.current = setTimeout(async () => {\n         if (value.length >= 2) {\n           const results = await getSuggestions(value);\n           setSuggestions(results);\n           setShowSuggestions(results.length > 0);\n         } else {\n           setSuggestions([]);\n           setShowSuggestions(false);\n         }\n       }, 300);\n     }, []);\n\n     const handleSubmit = (e: React.FormEvent) => {\n       e.preventDefault();\n       if (query.trim()) {\n         onSearch(query.trim());\n         setShowSuggestions(false);\n       }\n     };\n\n     return (\n       <form onSubmit={handleSubmit} className=\"relative w-full max-w-3xl\">\n         <div className=\"relative\">\n           <input\n             type=\"text\"\n             value={query}\n             onChange={(e) => handleInputChange(e.target.value)}\n             placeholder={EXAMPLE_QUERIES[placeholderIndex]}\n             className=\"w-full px-6 py-4 text-lg rounded-xl border-2 border-teal-200\n                        focus:border-amber-400 focus:ring-4 focus:ring-amber-100\n                        placeholder:text-gray-400 placeholder:font-serif placeholder:italic\n                        transition-all duration-200\"\n           />\n           <button\n             type=\"submit\"\n             disabled={isLoading}\n             className=\"absolute right-2 top-1/2 -translate-y-1/2 px-6 py-2\n                        bg-teal-700 text-white rounded-lg hover:bg-teal-800\n                        disabled:opacity-50 transition-colors\"\n           >\n             {isLoading ? 'Searching...' : 'Search'}\n           </button>\n         </div>\n         \n         {/* Suggestions dropdown */}\n         {showSuggestions && (\n           <ul className=\"absolute z-10 w-full mt-2 bg-white rounded-lg shadow-lg\n                          border border-gray-200 animate-slideDown\">\n             {suggestions.map((s, i) => (\n               <li\n                 key={i}\n                 onClick={() => { setQuery(s); onSearch(s); setShowSuggestions(false); }}\n                 className=\"px-4 py-3 cursor-pointer hover:bg-teal-50\n                            border-b border-gray-100 last:border-0\"\n               >\n                 {s}\n               </li>\n             ))}\n           </ul>\n         )}\n       </form>\n     );\n   }\n   ```\n\n3. Create `frontend/src/components/QueryInterpretation.tsx`:\n   ```tsx\n   import type { ExtractedEntities } from '../types';\n\n   interface Props {\n     entities: ExtractedEntities;\n   }\n\n   const ENTITY_COLORS: Record<string, string> = {\n     phase: 'bg-indigo-100 text-indigo-800 border-indigo-200',\n     condition: 'bg-teal-100 text-teal-800 border-teal-200',\n     status: 'bg-emerald-100 text-emerald-800 border-emerald-200',\n     location: 'bg-slate-100 text-slate-800 border-slate-200',\n     keyword: 'bg-amber-100 text-amber-800 border-amber-200',\n     sponsor: 'bg-purple-100 text-purple-800 border-purple-200',\n     age_group: 'bg-rose-100 text-rose-800 border-rose-200',\n   };\n\n   export function QueryInterpretation({ entities }: Props) {\n     const chips: { label: string; value: string; type: string }[] = [];\n\n     if (entities.phase) chips.push({ label: 'Phase', value: entities.phase, type: 'phase' });\n     if (entities.condition) chips.push({ label: 'Condition', value: entities.condition, type: 'condition' });\n     if (entities.status) chips.push({ label: 'Status', value: entities.status.replace('_', ' '), type: 'status' });\n     if (entities.location) {\n       const loc = [entities.location.city, entities.location.state, entities.location.country]\n         .filter(Boolean).join(', ');\n       if (loc) chips.push({ label: 'Location', value: loc, type: 'location' });\n     }\n     if (entities.keyword) chips.push({ label: 'Keyword', value: entities.keyword, type: 'keyword' });\n     if (entities.sponsor) chips.push({ label: 'Sponsor', value: entities.sponsor, type: 'sponsor' });\n     if (entities.age_group) chips.push({ label: 'Age Group', value: entities.age_group, type: 'age_group' });\n\n     if (chips.length === 0) return null;\n\n     return (\n       <div className=\"w-full py-4 px-6 bg-gray-50 border-y border-gray-200\">\n         <span className=\"text-sm text-gray-500 mr-3\">We understood:</span>\n         <div className=\"inline-flex flex-wrap gap-2\">\n           {chips.map((chip, i) => (\n             <span\n               key={i}\n               className={`px-3 py-1 rounded-full text-sm font-medium border\n                          ${ENTITY_COLORS[chip.type]} animate-fadeIn`}\n               style={{ animationDelay: `${i * 100}ms` }}\n             >\n               <span className=\"font-semibold\">{chip.label}:</span> {chip.value}\n             </span>\n           ))}\n         </div>\n       </div>\n     );\n   }\n   ```\n\n4. Create `frontend/src/components/ResultCard.tsx`:\n   ```tsx\n   import { useState } from 'react';\n   import type { TrialResult } from '../types';\n\n   interface Props {\n     trial: TrialResult;\n     index: number;\n   }\n\n   const STATUS_COLORS: Record<string, string> = {\n     RECRUITING: 'bg-green-100 text-green-800 border-green-300',\n     NOT_YET_RECRUITING: 'bg-amber-100 text-amber-800 border-amber-300',\n     COMPLETED: 'bg-gray-100 text-gray-800 border-gray-300',\n     TERMINATED: 'bg-red-100 text-red-800 border-red-300',\n     ACTIVE_NOT_RECRUITING: 'bg-blue-100 text-blue-800 border-blue-300',\n   };\n\n   const STATUS_BORDER: Record<string, string> = {\n     RECRUITING: 'border-l-green-500',\n     NOT_YET_RECRUITING: 'border-l-amber-500',\n     COMPLETED: 'border-l-gray-400',\n     TERMINATED: 'border-l-red-500',\n     ACTIVE_NOT_RECRUITING: 'border-l-blue-500',\n   };\n\n   export function ResultCard({ trial, index }: Props) {\n     const [expanded, setExpanded] = useState(false);\n     const statusColor = STATUS_COLORS[trial.overall_status || ''] || STATUS_COLORS.COMPLETED;\n     const borderColor = STATUS_BORDER[trial.overall_status || ''] || 'border-l-gray-300';\n     const sponsor = trial.sponsors[0]?.name || 'Unknown';\n\n     return (\n       <div\n         className={`bg-white rounded-lg shadow-sm border border-gray-200 border-l-4\n                    ${borderColor} p-5 hover:shadow-md transition-shadow cursor-pointer\n                    animate-fadeIn`}\n         style={{ animationDelay: `${index * 50}ms` }}\n         onClick={() => setExpanded(!expanded)}\n       >\n         <div className=\"flex justify-between items-start gap-4\">\n           <div className=\"flex-1\">\n             <h3 className=\"font-serif text-lg font-semibold text-gray-900 leading-snug\">\n               {trial.brief_title}\n             </h3>\n             <p className=\"text-xs text-gray-400 font-mono mt-1\">{trial.nct_id}</p>\n           </div>\n           <span className={`px-2 py-1 text-xs rounded border ${statusColor} whitespace-nowrap`}>\n             {trial.overall_status?.replace(/_/g, ' ')}\n           </span>\n         </div>\n\n         <div className=\"mt-3 flex flex-wrap gap-4 text-sm text-gray-600\">\n           {trial.phase && <span>Phase: <strong>{trial.phase.replace('PHASE', '')}</strong></span>}\n           <span>Sponsor: <strong>{sponsor}</strong></span>\n           {trial.enrollment && <span>Enrollment: <strong>{trial.enrollment.toLocaleString()}</strong></span>}\n         </div>\n\n         {expanded && trial.brief_summaries_description && (\n           <div className=\"mt-4 pt-4 border-t border-gray-100\">\n             <p className=\"text-sm text-gray-600 leading-relaxed\">\n               {trial.brief_summaries_description}\n             </p>\n             {trial.facilities.length > 0 && (\n               <div className=\"mt-3\">\n                 <span className=\"text-xs font-semibold text-gray-500\">Locations: </span>\n                 <span className=\"text-xs text-gray-600\">\n                   {trial.facilities.map(f => [f.city, f.state, f.country].filter(Boolean).join(', ')).join(' | ')}\n                 </span>\n               </div>\n             )}\n           </div>\n         )}\n       </div>\n     );\n   }\n   ```",
        "testStrategy": "1. Test SearchBar debouncing - verify suggestions API called after 300ms delay\n2. Test placeholder cycling animation\n3. Test QueryInterpretation renders all entity types with correct colors\n4. Test ResultCard expansion toggle\n5. Test status color mapping for all status types\n6. Verify animations render smoothly\n7. Test mobile responsive behavior\n8. Test keyboard navigation in suggestions dropdown",
        "priority": "high",
        "dependencies": [
          "2",
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create API Client Service with Type-Safe Fetch Functions",
            "description": "Implement frontend/src/services/api.ts with searchTrials and getSuggestions functions using the Fetch API with proper error handling, TypeScript generics, and response type validation.",
            "dependencies": [],
            "details": "Create the API client module at frontend/src/services/api.ts. Define API_BASE constant pointing to localhost:8000/api. Implement searchTrials function that accepts query string, optional page (default 1), and optional pageSize (default 10) parameters, returning Promise<SearchResponse>. Use encodeURIComponent for query parameter encoding. Implement getSuggestions function that returns empty array for prefixes under 2 characters, otherwise fetches from /suggest endpoint and returns string array. Add proper error handling with descriptive error messages for failed requests. Ensure the module exports are properly typed to match backend response schemas (SearchResponse, SuggestionResponse types from ../types). Add request timeout handling and consider adding retry logic for transient failures.",
            "status": "pending",
            "testStrategy": "Unit test searchTrials with mocked fetch responses for success and error cases. Test getSuggestions returns empty array for short prefixes. Test URL encoding works correctly for special characters in queries. Verify TypeScript types match expected backend response structure.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build SearchBar Component with Debounced Input and Cycling Placeholders",
            "description": "Create the SearchBar component with debounced suggestion fetching (300ms), cycling example placeholder text animation (4s interval), and amber focus ring styling.",
            "dependencies": [
              1
            ],
            "details": "Create frontend/src/components/SearchBar.tsx with useState hooks for query, suggestions, showSuggestions, and placeholderIndex. Define EXAMPLE_QUERIES array with 4 example queries (Phase 3 lung cancer, recruiting diabetes, BRCA1 breast cancer, open melanoma). Implement useEffect with setInterval for 4-second placeholder cycling. Create handleInputChange with useRef for debounce timer, clearing previous timeout and setting new 300ms delayed suggestion fetch. Implement handleSubmit preventing default, validating non-empty query, calling onSearch prop, and hiding suggestions. Style input with Tailwind: w-full, px-6 py-4, text-lg, rounded-xl, border-2 border-teal-200, focus:border-amber-400 focus:ring-4 focus:ring-amber-100, italic serif placeholder. Add disabled submit button styling with opacity-50 when isLoading. Ensure mobile responsiveness with proper max-width constraints.",
            "status": "pending",
            "testStrategy": "Test debounce timing with jest.useFakeTimers - verify getSuggestions not called until 300ms after typing stops. Test placeholder cycling changes text every 4 seconds. Test form submission calls onSearch with trimmed query. Verify focus states apply correct amber ring styling.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Suggestion Dropdown with Animations and Click Handling",
            "description": "Add the suggestions dropdown to SearchBar with smooth slideDown animation, click-to-select functionality, hover states, and outside-click dismissal behavior.",
            "dependencies": [
              2
            ],
            "details": "Extend SearchBar component to render suggestion dropdown conditionally when showSuggestions is true and suggestions array is not empty. Style dropdown ul with absolute positioning, z-10, full width, mt-2, white background, rounded-lg, shadow-lg, border border-gray-200, and animate-slideDown class. Render each suggestion as li with px-4 py-3 padding, cursor-pointer, hover:bg-teal-50 hover state, border-b border-gray-100 dividers (except last item). Implement onClick handler that sets query value, calls onSearch, and hides suggestions. Add useEffect with click event listener on document to detect outside clicks and close dropdown. Add keyboard navigation support with arrow keys for accessibility - track selectedIndex state, handle ArrowUp/ArrowDown to change selection, Enter to select. Ensure dropdown is mobile-friendly with touch-friendly tap targets (minimum 44px height).",
            "status": "pending",
            "testStrategy": "Test dropdown appears when suggestions array populated and showSuggestions true. Test clicking suggestion updates query and triggers search. Test clicking outside dropdown closes it. Test keyboard navigation with arrow keys changes highlighted item. Test Enter key selects highlighted suggestion.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create QueryInterpretation Component with Color-Coded Entity Chips",
            "description": "Implement QueryInterpretation component displaying extracted entities as color-coded chips with sequential fade-in animations and proper label formatting.",
            "dependencies": [],
            "details": "Create frontend/src/components/QueryInterpretation.tsx accepting entities prop of type ExtractedEntities. Define ENTITY_COLORS mapping object with Tailwind classes: phase (indigo-100/800/200), condition (teal-100/800/200), status (emerald-100/800/200), location (slate-100/800/200), keyword (amber-100/800/200), sponsor (purple-100/800/200), age_group (rose-100/800/200). Build chips array by checking each entity property, formatting location as comma-separated city/state/country, and replacing underscores in status with spaces. Return null if no chips. Render container div with py-4 px-6, bg-gray-50, border-y border-gray-200. Add 'We understood:' prefix span with text-sm text-gray-500 mr-3. Map chips with inline-flex flex-wrap gap-2 container, each chip as span with px-3 py-1 rounded-full text-sm font-medium border, dynamic color class, and animate-fadeIn with staggered animationDelay (i * 100ms). Use font-semibold for label portion.",
            "status": "pending",
            "testStrategy": "Test component renders null when no entities present. Test each entity type renders with correct color class. Test location formatting combines city/state/country correctly. Test status underscore replacement works. Test animation delays are staggered correctly (0ms, 100ms, 200ms, etc.).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Build ResultCard Component with Expandable Details and Status Styling",
            "description": "Create ResultCard component with status-colored left border, serif title styling, expandable summary section, and metadata display for phase/sponsor/enrollment.",
            "dependencies": [],
            "details": "Create frontend/src/components/ResultCard.tsx accepting trial (TrialResult) and index props. Define STATUS_COLORS mapping for RECRUITING (green), NOT_YET_RECRUITING (amber), COMPLETED (gray), TERMINATED (red), ACTIVE_NOT_RECRUITING (blue) with bg/text/border variants. Define STATUS_BORDER mapping for left border colors. Add useState for expanded boolean. Render card div with bg-white rounded-lg shadow-sm border border-gray-200 border-l-4 with dynamic borderColor, p-5, hover:shadow-md transition-shadow, cursor-pointer, animate-fadeIn with staggered delay (index * 50ms). Add onClick toggling expanded state. Display flex header with brief_title in font-serif text-lg font-semibold, nct_id in text-xs text-gray-400 font-mono, and status badge with dynamic statusColor. Show metadata row with phase (formatted without 'PHASE' prefix), sponsor (first from array or 'Unknown'), and enrollment with toLocaleString formatting. Conditionally render expanded section with border-t, brief_summaries_description, and facilities list formatted as city/state/country joined by pipes.",
            "status": "pending",
            "testStrategy": "Test card renders with correct status border color for each status type. Test clicking card toggles expanded state. Test expanded section shows summary and facilities. Test sponsor falls back to 'Unknown' when empty. Test enrollment number formats with commas. Test animation delay based on index prop.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Define TypeScript Types Matching Backend Schemas",
            "description": "Create frontend/src/types/index.ts with complete TypeScript interfaces for SearchResponse, SuggestionResponse, TrialResult, ExtractedEntities, Sponsor, Facility, and Location matching backend Pydantic models.",
            "dependencies": [],
            "details": "Create frontend/src/types/index.ts (or types.ts) with all necessary interfaces. Define Location interface with optional city, state, country string fields. Define ExtractedEntities with optional phase, condition, status, location (Location type), keyword, sponsor, age_group fields. Define Sponsor interface with name string and optional type field. Define Facility interface with optional name, city, state, country fields. Define TrialResult interface with nct_id, brief_title, official_title (optional), brief_summaries_description (optional), overall_status, phase (optional), enrollment (optional number), sponsors (Sponsor array), facilities (Facility array), conditions (string array), and score (optional number). Define SuggestionResponse with suggestions string array. Define SearchResponse with results (TrialResult array), total (number), page (number), page_size (number), total_pages (number), query (string), entities (ExtractedEntities), and optional clarification_needed (string array). Export all types for use across components.",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation succeeds with no type errors. Test that API response types match actual backend responses by making test requests. Ensure all component props correctly use these shared types. Run tsc --noEmit to validate type correctness.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Create CSS Animations and Configure Tailwind Theme Extensions",
            "description": "Add fadeIn and slideDown keyframe animations to frontend/src/index.css and extend Tailwind config with custom animation utilities and theme colors.",
            "dependencies": [],
            "details": "Update frontend/src/index.css with @keyframes fadeIn animation from opacity 0 to 1 with transform translateY(8px) to translateY(0) over 0.3s ease-out. Add @keyframes slideDown from opacity 0, transform translateY(-10px) to opacity 1, translateY(0) over 0.2s ease-out. Define utility classes .animate-fadeIn and .animate-slideDown applying the respective animations with animation-fill-mode: both for proper initial state handling. Update tailwind.config.js (or tailwind.config.ts) to extend theme with custom colors: primary (#0D4F4F teal), accent (#D4A843 amber), background (#F8F6F3 cream). Add animation keyframes to Tailwind config for use with animate-* classes. Ensure animations work with prefers-reduced-motion media query by adding @media (prefers-reduced-motion: reduce) rules that disable or reduce animation duration. Add responsive breakpoint considerations ensuring animations don't cause layout shift on mobile devices.",
            "status": "pending",
            "testStrategy": "Verify animations play correctly by inspecting elements in browser DevTools. Test fadeIn applies to ResultCard components with visible opacity/transform transition. Test slideDown applies to suggestion dropdown. Verify prefers-reduced-motion is respected. Test Tailwind custom colors are accessible via classes like bg-primary, text-accent.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Break down frontend core components into: 1) Create api.ts with searchTrials and getSuggestions functions using fetch API with proper error handling and type safety, 2) Build SearchBar component with debounced input (300ms), cycling placeholder animation, amber focus glow, and suggestion dropdown with keyboard navigation, 3) Implement suggestion dropdown with smooth slide animation, click handling, and outside-click dismissal, 4) Create QueryInterpretation component with color-coded entity chips (indigo/teal/emerald/slate/amber), sequential entrance animation, and 'We understood:' prefix, 5) Build ResultCard component with status-colored left border, expandable details section, serif title, and metadata display, 6) Add proper TypeScript types throughout matching backend schemas, 7) Create CSS animations in index.css (fadeIn, slideDown) and configure Tailwind theme. Each subtask should be mobile-responsive."
      },
      {
        "id": "9",
        "title": "Frontend Results List, Pagination, and State Management",
        "description": "Implement the ResultsList component with staggered animations, Pagination controls, ClarificationBanner for ambiguous queries, EmptyState for no results, and wire up the complete App component with state management.",
        "details": "1. Create `frontend/src/components/Pagination.tsx`:\n   ```tsx\n   interface Props {\n     currentPage: number;\n     totalPages: number;\n     onPageChange: (page: number) => void;\n   }\n\n   export function Pagination({ currentPage, totalPages, onPageChange }: Props) {\n     if (totalPages <= 1) return null;\n\n     const pages = Array.from({ length: Math.min(totalPages, 5) }, (_, i) => {\n       if (totalPages <= 5) return i + 1;\n       if (currentPage <= 3) return i + 1;\n       if (currentPage >= totalPages - 2) return totalPages - 4 + i;\n       return currentPage - 2 + i;\n     });\n\n     return (\n       <div className=\"flex items-center justify-center gap-2 mt-8\">\n         <button\n           onClick={() => onPageChange(currentPage - 1)}\n           disabled={currentPage === 1}\n           className=\"px-3 py-2 rounded-lg border border-gray-300 disabled:opacity-50\n                      hover:bg-gray-50 transition-colors\"\n         >\n           Previous\n         </button>\n         {pages.map((page) => (\n           <button\n             key={page}\n             onClick={() => onPageChange(page)}\n             className={`w-10 h-10 rounded-lg border transition-colors\n                        ${page === currentPage\n                          ? 'bg-teal-700 text-white border-teal-700'\n                          : 'border-gray-300 hover:bg-gray-50'}`}\n           >\n             {page}\n           </button>\n         ))}\n         <button\n           onClick={() => onPageChange(currentPage + 1)}\n           disabled={currentPage === totalPages}\n           className=\"px-3 py-2 rounded-lg border border-gray-300 disabled:opacity-50\n                      hover:bg-gray-50 transition-colors\"\n         >\n           Next\n         </button>\n       </div>\n     );\n   }\n   ```\n\n2. Create `frontend/src/components/ClarificationBanner.tsx`:\n   ```tsx\n   interface Props {\n     question: string;\n     onSelection: (choice: string) => void;\n   }\n\n   export function ClarificationBanner({ question, onSelection }: Props) {\n     // Extract potential options from the question (simplified)\n     const options = extractOptions(question);\n\n     return (\n       <div className=\"w-full py-4 px-6 bg-amber-50 border-y border-amber-200\n                       animate-slideDown\">\n         <p className=\"text-amber-800 font-medium mb-3\">{question}</p>\n         {options.length > 0 && (\n           <div className=\"flex flex-wrap gap-2\">\n             {options.map((opt, i) => (\n               <button\n                 key={i}\n                 onClick={() => onSelection(opt)}\n                 className=\"px-4 py-2 rounded-full bg-white border border-amber-300\n                            text-amber-800 hover:bg-amber-100 transition-colors\"\n               >\n                 {opt}\n               </button>\n             ))}\n           </div>\n         )}\n       </div>\n     );\n   }\n\n   function extractOptions(question: string): string[] {\n     // Simple extraction - could be enhanced\n     const matches = question.match(/'([^']+)'/g);\n     return matches ? matches.map(m => m.replace(/'/g, '')) : [];\n   }\n   ```\n\n3. Create `frontend/src/components/EmptyState.tsx`:\n   ```tsx\n   interface Props {\n     type: 'no-results' | 'error';\n     message?: string;\n     onRetry?: () => void;\n     onSuggestionClick?: (query: string) => void;\n   }\n\n   const SUGGESTED_QUERIES = [\n     \"Phase 3 cancer trials\",\n     \"Recruiting diabetes studies\",\n     \"COVID-19 vaccine trials\"\n   ];\n\n   export function EmptyState({ type, message, onRetry, onSuggestionClick }: Props) {\n     return (\n       <div className=\"flex flex-col items-center justify-center py-16 px-4\">\n         <div className=\"w-24 h-24 mb-6 rounded-full bg-gray-100 flex items-center justify-center\">\n           {type === 'no-results' ? (\n             <svg className=\"w-12 h-12 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n               <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={1.5}\n                     d=\"M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z\" />\n             </svg>\n           ) : (\n             <svg className=\"w-12 h-12 text-red-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n               <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={1.5}\n                     d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z\" />\n             </svg>\n           )}\n         </div>\n         \n         <h2 className=\"font-serif text-2xl text-gray-700 mb-2\">\n           {type === 'no-results' ? 'No trials found' : 'Something went wrong'}\n         </h2>\n         <p className=\"text-gray-500 text-center max-w-md mb-6\">\n           {message || (type === 'no-results'\n             ? \"We couldn't find any clinical trials matching your search criteria.\"\n             : \"There was an error processing your request. Please try again.\")}\n         </p>\n\n         {type === 'error' && onRetry && (\n           <button\n             onClick={onRetry}\n             className=\"px-6 py-2 bg-teal-700 text-white rounded-lg hover:bg-teal-800\n                        transition-colors mb-6\"\n           >\n             Try Again\n           </button>\n         )}\n\n         {type === 'no-results' && onSuggestionClick && (\n           <div className=\"text-center\">\n             <p className=\"text-sm text-gray-500 mb-3\">Try one of these searches:</p>\n             <div className=\"flex flex-wrap justify-center gap-2\">\n               {SUGGESTED_QUERIES.map((q, i) => (\n                 <button\n                   key={i}\n                   onClick={() => onSuggestionClick(q)}\n                   className=\"px-4 py-2 rounded-full border border-teal-300 text-teal-700\n                              hover:bg-teal-50 transition-colors text-sm\"\n                 >\n                   {q}\n                 </button>\n               ))}\n             </div>\n           </div>\n         )}\n       </div>\n     );\n   }\n   ```\n\n4. Create `frontend/src/components/ResultsList.tsx`:\n   ```tsx\n   import type { TrialResult } from '../types';\n   import { ResultCard } from './ResultCard';\n   import { Pagination } from './Pagination';\n\n   interface Props {\n     results: TrialResult[];\n     total: number;\n     page: number;\n     pageSize: number;\n     onPageChange: (page: number) => void;\n   }\n\n   export function ResultsList({ results, total, page, pageSize, onPageChange }: Props) {\n     const totalPages = Math.ceil(total / pageSize);\n\n     return (\n       <div className=\"w-full max-w-4xl mx-auto\">\n         <p className=\"text-sm text-gray-500 mb-4\">\n           Showing {results.length} of {total.toLocaleString()} trials\n         </p>\n         <div className=\"space-y-4\">\n           {results.map((trial, index) => (\n             <ResultCard key={trial.nct_id} trial={trial} index={index} />\n           ))}\n         </div>\n         <Pagination\n           currentPage={page}\n           totalPages={totalPages}\n           onPageChange={onPageChange}\n         />\n       </div>\n     );\n   }\n   ```\n\n5. Update `frontend/src/App.tsx` with complete state management:\n   ```tsx\n   import { useState, useCallback } from 'react';\n   import { SearchBar } from './components/SearchBar';\n   import { QueryInterpretation } from './components/QueryInterpretation';\n   import { ResultsList } from './components/ResultsList';\n   import { ClarificationBanner } from './components/ClarificationBanner';\n   import { EmptyState } from './components/EmptyState';\n   import { searchTrials } from './services/api';\n   import type { SearchResponse } from './types';\n\n   type AppState = 'idle' | 'loading' | 'results' | 'no-results' | 'error';\n\n   export default function App() {\n     const [state, setState] = useState<AppState>('idle');\n     const [response, setResponse] = useState<SearchResponse | null>(null);\n     const [currentQuery, setCurrentQuery] = useState('');\n     const [error, setError] = useState<string | null>(null);\n\n     const handleSearch = useCallback(async (query: string, page = 1) => {\n       setCurrentQuery(query);\n       setState('loading');\n       setError(null);\n\n       try {\n         const result = await searchTrials(query, page);\n         setResponse(result);\n         setState(result.results.length > 0 ? 'results' : 'no-results');\n       } catch (err) {\n         setError(err instanceof Error ? err.message : 'Unknown error');\n         setState('error');\n       }\n     }, []);\n\n     const handlePageChange = useCallback((page: number) => {\n       handleSearch(currentQuery, page);\n       window.scrollTo({ top: 0, behavior: 'smooth' });\n     }, [currentQuery, handleSearch]);\n\n     const handleClarification = useCallback((choice: string) => {\n       handleSearch(`${currentQuery} ${choice}`);\n     }, [currentQuery, handleSearch]);\n\n     return (\n       <div className=\"min-h-screen bg-[#F8F6F3]\">\n         {/* Hero/Header section */}\n         <header className={`transition-all duration-300 ${state === 'idle' ? 'py-32' : 'py-8'}`}>\n           <div className=\"max-w-4xl mx-auto px-4 text-center\">\n             {state === 'idle' && (\n               <>\n                 <h1 className=\"font-serif text-5xl font-bold text-teal-900 mb-4\">\n                   Clinical Trials Search\n                 </h1>\n                 <p className=\"text-gray-600 text-lg mb-8\">\n                   Find clinical trials using natural language\n                 </p>\n               </>\n             )}\n             <SearchBar onSearch={handleSearch} isLoading={state === 'loading'} />\n           </div>\n         </header>\n\n         {/* Query interpretation */}\n         {response && state !== 'idle' && (\n           <QueryInterpretation entities={response.query_interpretation} />\n         )}\n\n         {/* Clarification banner */}\n         {response?.clarification && (\n           <ClarificationBanner\n             question={response.clarification}\n             onSelection={handleClarification}\n           />\n         )}\n\n         {/* Main content */}\n         <main className=\"px-4 py-8\">\n           {state === 'loading' && (\n             <div className=\"max-w-4xl mx-auto space-y-4\">\n               {[...Array(3)].map((_, i) => (\n                 <div key={i} className=\"h-32 bg-white rounded-lg animate-pulse\" />\n               ))}\n             </div>\n           )}\n\n           {state === 'results' && response && (\n             <ResultsList\n               results={response.results}\n               total={response.total}\n               page={response.page}\n               pageSize={response.page_size}\n               onPageChange={handlePageChange}\n             />\n           )}\n\n           {state === 'no-results' && (\n             <EmptyState\n               type=\"no-results\"\n               onSuggestionClick={handleSearch}\n             />\n           )}\n\n           {state === 'error' && (\n             <EmptyState\n               type=\"error\"\n               message={error || undefined}\n               onRetry={() => handleSearch(currentQuery)}\n             />\n           )}\n         </main>\n       </div>\n     );\n   }\n   ```",
        "testStrategy": "1. Test pagination navigation with multi-page results\n2. Test clarification banner rendering and selection\n3. Test empty state with suggestion clicks\n4. Test error state retry functionality\n5. Test loading skeleton display\n6. Test header transition from hero to compact\n7. Test smooth scroll on page change\n8. Test all state transitions: idle -> loading -> results/no-results/error\n9. Mobile responsive testing for all components",
        "priority": "high",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Pagination Component with Dynamic Page Number Generation",
            "description": "Implement the Pagination.tsx component with intelligent page number generation that handles edge cases for first/last pages, ellipsis display for large page counts, and proper disabled states for navigation buttons.",
            "dependencies": [],
            "details": "Create `frontend/src/components/Pagination.tsx` with the following features:\n\n1. **Props interface**: Accept `currentPage`, `totalPages`, and `onPageChange` callback\n2. **Early return**: Return null when `totalPages <= 1` (no pagination needed)\n3. **Dynamic page array generation**:\n   - For 5 or fewer pages: show all pages [1, 2, 3, 4, 5]\n   - When currentPage <= 3: show first 5 pages\n   - When currentPage >= totalPages - 2: show last 5 pages\n   - Otherwise: show currentPage centered with 2 pages on each side\n4. **Previous button**: Disabled when `currentPage === 1`, calls `onPageChange(currentPage - 1)`\n5. **Page number buttons**: Highlight current page with teal-700 background and white text, others have gray border with hover state\n6. **Next button**: Disabled when `currentPage === totalPages`, calls `onPageChange(currentPage + 1)`\n7. **Styling**: Use flex layout with gap-2, centered alignment, mt-8 margin top, rounded-lg buttons with transition-colors\n8. **Accessibility**: Ensure buttons have proper disabled states reflected visually (opacity-50)",
            "status": "pending",
            "testStrategy": "1. Test with totalPages=1: component should return null\n2. Test with totalPages=5, currentPage=1: should show pages [1,2,3,4,5] with 1 highlighted\n3. Test with totalPages=10, currentPage=1: Previous should be disabled, should show [1,2,3,4,5]\n4. Test with totalPages=10, currentPage=10: Next should be disabled, should show [6,7,8,9,10]\n5. Test with totalPages=20, currentPage=10: should show [8,9,10,11,12]\n6. Verify onPageChange callback fires correctly on button clicks",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build ClarificationBanner with Question Parsing and Selection Handling",
            "description": "Create the ClarificationBanner.tsx component with amber styling that displays clarification questions, extracts potential options from the question text using regex, and triggers refined searches when users select an option.",
            "dependencies": [],
            "details": "Create `frontend/src/components/ClarificationBanner.tsx` with:\n\n1. **Props interface**: Accept `question` string and `onSelection` callback that receives the chosen option\n2. **extractOptions helper function**:\n   - Parse question string for quoted text using regex `/'([^']+)'/g`\n   - Return array of extracted strings with quotes removed\n   - Return empty array if no matches found\n3. **Banner styling**:\n   - Full width with py-4 px-6 padding\n   - Amber color scheme: bg-amber-50, border-y border-amber-200\n   - Add `animate-slideDown` class for entrance animation\n4. **Question display**: Show question text in text-amber-800 font-medium with mb-3 margin\n5. **Option buttons** (only render if options.length > 0):\n   - Wrap in flex container with flex-wrap gap-2\n   - Each button: px-4 py-2, rounded-full, bg-white, border border-amber-300\n   - Text in text-amber-800 with hover:bg-amber-100 transition\n   - onClick calls `onSelection(opt)` with the option text\n6. **Add slideDown animation to tailwind.config.js** if not already present:\n   ```js\n   animation: { slideDown: 'slideDown 0.3s ease-out' },\n   keyframes: { slideDown: { from: { opacity: 0, transform: 'translateY(-10px)' }, to: { opacity: 1, transform: 'translateY(0)' } } }\n   ```",
            "status": "pending",
            "testStrategy": "1. Test with question containing quoted options: \"Did you mean 'diabetes' or 'diabetic'?\" should extract ['diabetes', 'diabetic']\n2. Test with question without quotes: should render question but no option buttons\n3. Verify onSelection callback is called with correct option text when button clicked\n4. Verify amber color scheme renders correctly\n5. Test slideDown animation triggers on component mount\n6. Test with multiple options (3+) to verify flex-wrap behavior",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create EmptyState Component with No-Results and Error Variants",
            "description": "Implement the EmptyState.tsx component with two distinct variants: 'no-results' showing suggested queries and 'error' showing retry functionality, each with appropriate icons, messaging, and interactive elements.",
            "dependencies": [],
            "details": "Create `frontend/src/components/EmptyState.tsx` with:\n\n1. **Props interface**: `type: 'no-results' | 'error'`, optional `message`, optional `onRetry` callback, optional `onSuggestionClick` callback\n2. **SUGGESTED_QUERIES constant**: Array of example searches like [\"Phase 3 cancer trials\", \"Recruiting diabetes studies\", \"COVID-19 vaccine trials\"]\n3. **Container styling**: Centered flex column with py-16 px-4\n4. **Icon container**: 24x24 (w-24 h-24) rounded-full bg-gray-100 with centered icon\n   - 'no-results': Search magnifying glass SVG in text-gray-400\n   - 'error': Warning triangle SVG in text-red-400\n5. **Heading**: font-serif text-2xl text-gray-700 mb-2\n   - 'no-results': \"No trials found\"\n   - 'error': \"Something went wrong\"\n6. **Description**: text-gray-500 centered max-w-md mb-6, use message prop or default text\n7. **Error retry button** (only for type='error' when onRetry provided):\n   - px-6 py-2, bg-teal-700 text-white, rounded-lg, hover:bg-teal-800 transition, mb-6\n8. **Suggested queries** (only for type='no-results' when onSuggestionClick provided):\n   - \"Try one of these searches:\" label in text-sm text-gray-500 mb-3\n   - Flex-wrap container with gap-2 and justify-center\n   - Each suggestion: px-4 py-2, rounded-full, border border-teal-300, text-teal-700, hover:bg-teal-50, text-sm",
            "status": "pending",
            "testStrategy": "1. Test 'no-results' variant renders search icon, correct heading, and suggestions\n2. Test 'error' variant renders warning icon, correct heading, and retry button\n3. Test onRetry callback fires when retry button clicked\n4. Test onSuggestionClick callback fires with query text when suggestion clicked\n5. Test custom message prop overrides default text\n6. Test retry button only renders when onRetry is provided\n7. Test suggestions only render when onSuggestionClick is provided",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement ResultsList Component with Staggered Animations",
            "description": "Create the ResultsList.tsx component that composes multiple ResultCard components with staggered entrance animations, displays result count information, and integrates the Pagination component for navigation.",
            "dependencies": [
              1
            ],
            "details": "Create `frontend/src/components/ResultsList.tsx` with:\n\n1. **Imports**: Import TrialResult type, ResultCard component, and Pagination component\n2. **Props interface**: `results: TrialResult[]`, `total: number`, `page: number`, `pageSize: number`, `onPageChange: (page: number) => void`\n3. **Calculate totalPages**: `Math.ceil(total / pageSize)`\n4. **Container**: `w-full max-w-4xl mx-auto`\n5. **Result count display**: \n   - `<p className=\"text-sm text-gray-500 mb-4\">`\n   - Text: \"Showing {results.length} of {total.toLocaleString()} trials\"\n6. **Results container**: `<div className=\"space-y-4\">`\n7. **Map ResultCards**: Pass `trial` and `index` to each ResultCard\n   - The index is used by ResultCard for staggered animation delay\n   - Key should be `trial.nct_id`\n8. **Pagination component**: Pass currentPage={page}, totalPages, onPageChange\n9. **Staggered animation in ResultCard** (verify/update ResultCard.tsx):\n   - Add animation delay based on index: `style={{ animationDelay: `${index * 100}ms` }}`\n   - Add CSS class `animate-fadeInUp` with animation-fill-mode: both\n10. **Add fadeInUp animation to tailwind config** if needed:\n    ```js\n    animation: { fadeInUp: 'fadeInUp 0.4s ease-out' },\n    keyframes: { fadeInUp: { from: { opacity: 0, transform: 'translateY(20px)' }, to: { opacity: 1, transform: 'translateY(0)' } } }\n    ```",
            "status": "pending",
            "testStrategy": "1. Test ResultsList renders correct number of ResultCard components\n2. Test result count shows correct \"Showing X of Y trials\" text with proper formatting\n3. Test staggered animation - first card animates immediately, second after 100ms, etc.\n4. Test Pagination receives correct props (currentPage, totalPages)\n5. Test onPageChange callback propagates to Pagination correctly\n6. Test with empty results array - should render empty container with Pagination\n7. Test with large total (1000+) formats with toLocaleString()",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Build App.tsx with Complete State Machine and Search Handler",
            "description": "Implement the main App.tsx component with a complete state machine managing idle, loading, results, no-results, and error states, including search functionality with pagination support, clarification handling, and smooth scroll behavior.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Update `frontend/src/App.tsx` with complete state management:\n\n1. **Imports**: useState, useCallback from React; all components (SearchBar, QueryInterpretation, ResultsList, ClarificationBanner, EmptyState); searchTrials from api service; SearchResponse type\n2. **AppState type**: `'idle' | 'loading' | 'results' | 'no-results' | 'error'`\n3. **State variables**:\n   - `state: AppState` initialized to 'idle'\n   - `response: SearchResponse | null` initialized to null\n   - `currentQuery: string` initialized to ''\n   - `error: string | null` initialized to null\n4. **handleSearch callback** (memoized with useCallback):\n   - Accept query string and optional page (default 1)\n   - Set currentQuery, setState to 'loading', clear error\n   - Try/catch block: call searchTrials, setResponse, setState based on results.length\n   - Catch: setError with message, setState to 'error'\n5. **handlePageChange callback**: Call handleSearch with currentQuery and page, then `window.scrollTo({ top: 0, behavior: 'smooth' })`\n6. **handleClarification callback**: Call handleSearch with `${currentQuery} ${choice}`\n7. **JSX structure**:\n   - Root: `min-h-screen bg-[#F8F6F3]`\n   - Header: Dynamic padding `py-32` for idle, `py-8` otherwise, with transition-all duration-300\n   - Conditionally render hero text only in idle state\n   - SearchBar always visible, pass isLoading prop\n   - QueryInterpretation when response exists and not idle\n   - ClarificationBanner when response?.clarification exists\n   - Main content: loading skeletons, ResultsList, or EmptyState based on state",
            "status": "pending",
            "testStrategy": "1. Test initial state is 'idle' with hero text and expanded header\n2. Test search transitions: idle -> loading -> results (with data) or no-results (empty)\n3. Test error state: simulate API failure, verify error message displays\n4. Test header transition: verify py-32 becomes py-8 on search\n5. Test pagination: verify handlePageChange updates results and scrolls to top\n6. Test clarification: verify handleClarification appends choice to query\n7. Test retry from error state returns to loading then appropriate state\n8. Test suggestion click from EmptyState triggers new search",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Add Skeleton Loading States with Shimmer Animation and Header Transition",
            "description": "Implement skeleton loading placeholders with shimmer animation effect during API calls, and ensure the header transition from hero (idle) to compact (active) state animates smoothly with proper CSS transitions.",
            "dependencies": [
              5
            ],
            "details": "Enhance loading states and header transitions in App.tsx and CSS:\n\n1. **Loading skeletons in App.tsx main content**:\n   - When state === 'loading', render 3 skeleton cards\n   - Each skeleton: `h-32 bg-white rounded-lg animate-pulse`\n   - Wrap in `max-w-4xl mx-auto space-y-4`\n\n2. **Enhanced shimmer animation** (update tailwind.config.js or index.css):\n   ```css\n   @keyframes shimmer {\n     0% { background-position: -200% 0; }\n     100% { background-position: 200% 0; }\n   }\n   .animate-shimmer {\n     background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);\n     background-size: 200% 100%;\n     animation: shimmer 1.5s infinite;\n   }\n   ```\n\n3. **Optional: Create SkeletonCard component** for reusability:\n   ```tsx\n   export function SkeletonCard() {\n     return (\n       <div className=\"bg-white rounded-lg p-6 animate-shimmer\">\n         <div className=\"h-4 bg-gray-200 rounded w-3/4 mb-4\" />\n         <div className=\"h-3 bg-gray-200 rounded w-1/2 mb-2\" />\n         <div className=\"h-3 bg-gray-200 rounded w-full\" />\n       </div>\n     );\n   }\n   ```\n\n4. **Header transition refinement**:\n   - Ensure `transition-all duration-300` on header element\n   - Hero content (h1, p) should fade out: add `transition-opacity duration-300` and conditional opacity-0\n   - Consider using `overflow-hidden` with dynamic max-height for smoother collapse\n\n5. **SearchBar position transition**:\n   - Ensure SearchBar smoothly moves from centered (hero) to top position\n   - Use transform or layout animations as needed\n\n6. **Add all required keyframe animations to tailwind.config.js**:\n   - slideDown (for ClarificationBanner)\n   - fadeInUp (for ResultCards)\n   - shimmer (for loading skeletons)",
            "status": "pending",
            "testStrategy": "1. Test loading state displays 3 skeleton cards with shimmer animation\n2. Test shimmer animation runs continuously (infinite loop)\n3. Test header transition timing - should take 300ms to collapse\n4. Test hero text fades out when transitioning from idle state\n5. Test SearchBar position animates smoothly from center to top\n6. Verify no layout shift or jumpy behavior during state transitions\n7. Test rapid state changes (quick searches) don't cause animation glitches\n8. Verify all animations defined in tailwind.config.js compile correctly",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down results and state management into: 1) Create Pagination component with dynamic page number generation, edge-case handling (first/last page), and proper button states, 2) Build ClarificationBanner with amber styling, question parsing to extract options, and selection handling that triggers refined search, 3) Create EmptyState component with two variants (no-results, error), suggestion query buttons, and retry functionality, 4) Implement ResultsList component composing ResultCard with staggered animations and result count display, 5) Build App.tsx with complete state machine (idle/loading/results/no-results/error), search handler with pagination support, and smooth scroll on page change, 6) Add skeleton loading states with shimmer animation and header transition (hero to compact). Each subtask should handle all state transitions gracefully."
      },
      {
        "id": "10",
        "title": "Visual Polish, Animations, and End-to-End Testing",
        "description": "Apply final visual polish including custom animations, font styling, responsive design refinements, and comprehensive end-to-end testing across diverse query types.",
        "details": "1. Update `frontend/src/index.css` with complete styling:\n   ```css\n   @import url('https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,400;9..144,600;9..144,700&family=Outfit:wght@400;500;600&display=swap');\n   @import 'tailwindcss';\n\n   :root {\n     --color-primary: #0D4F4F;\n     --color-accent: #D4A843;\n     --color-bg: #F8F6F3;\n   }\n\n   body {\n     font-family: 'Outfit', sans-serif;\n     background-color: var(--color-bg);\n   }\n\n   .font-serif {\n     font-family: 'Fraunces', serif;\n   }\n\n   /* Custom animations */\n   @keyframes fadeIn {\n     from { opacity: 0; transform: translateY(8px); }\n     to { opacity: 1; transform: translateY(0); }\n   }\n\n   @keyframes slideDown {\n     from { opacity: 0; transform: translateY(-10px); }\n     to { opacity: 1; transform: translateY(0); }\n   }\n\n   @keyframes shimmer {\n     0% { background-position: -200% 0; }\n     100% { background-position: 200% 0; }\n   }\n\n   .animate-fadeIn {\n     animation: fadeIn 0.3s ease-out forwards;\n     opacity: 0;\n   }\n\n   .animate-slideDown {\n     animation: slideDown 0.2s ease-out forwards;\n   }\n\n   .animate-pulse {\n     background: linear-gradient(90deg, #e5e5e5 25%, #f5f5f5 50%, #e5e5e5 75%);\n     background-size: 200% 100%;\n     animation: shimmer 1.5s infinite;\n   }\n\n   /* Focus states */\n   input:focus {\n     box-shadow: 0 0 0 4px rgba(212, 168, 67, 0.2);\n   }\n\n   /* Scrollbar styling */\n   ::-webkit-scrollbar {\n     width: 8px;\n   }\n   ::-webkit-scrollbar-track {\n     background: #f1f1f1;\n   }\n   ::-webkit-scrollbar-thumb {\n     background: #c1c1c1;\n     border-radius: 4px;\n   }\n   ```\n\n2. Update `frontend/tailwind.config.ts`:\n   ```typescript\n   import type { Config } from 'tailwindcss'\n\n   export default {\n     content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],\n     theme: {\n       extend: {\n         colors: {\n           teal: {\n             50: '#f0fdfa',\n             100: '#ccfbf1',\n             200: '#99f6e4',\n             300: '#5eead4',\n             400: '#2dd4bf',\n             500: '#14b8a6',\n             600: '#0d9488',\n             700: '#0D4F4F',\n             800: '#0A3D3D',\n             900: '#082f2f',\n           },\n           amber: {\n             400: '#D4A843',\n             500: '#c99a3a',\n           }\n         },\n         fontFamily: {\n           serif: ['Fraunces', 'serif'],\n           sans: ['Outfit', 'sans-serif'],\n         },\n       },\n     },\n     plugins: [],\n   } satisfies Config\n   ```\n\n3. Update `frontend/index.html` with proper meta tags:\n   ```html\n   <!DOCTYPE html>\n   <html lang=\"en\">\n     <head>\n       <meta charset=\"UTF-8\" />\n       <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n       <meta name=\"description\" content=\"Search clinical trials using natural language\" />\n       <title>Clinical Trials Search</title>\n       <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n       <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n     </head>\n     <body>\n       <div id=\"root\"></div>\n       <script type=\"module\" src=\"/src/main.tsx\"></script>\n     </body>\n   </html>\n   ```\n\n4. End-to-end test scenarios to validate:\n   ```\n   Test Cases:\n   1. \"Phase 3 lung cancer trials in the USA\"\n      Expected: phase=PHASE3, condition=lung cancer, location.country=United States\n      Verify: Results show Phase 3 trials with lung cancer in title/description, US locations\n\n   2. \"recruiting diabetes trials near Boston\"\n      Expected: status=RECRUITING, condition=diabetes, location.city=Boston\n      Verify: All results have RECRUITING status, diabetes-related\n\n   3. \"List all Phase 2 trials for Breast Cancer associated with BRCA1 gene\"\n      Expected: phase=PHASE2, condition=Breast Cancer, keyword=BRCA1\n      Verify: Results mention BRCA1 in descriptions\n\n   4. \"open melanoma trials\" (synonym test)\n      Expected: status=RECRUITING (from \"open\" synonym), condition=melanoma\n      Verify: Synonym mapping works correctly\n\n   5. \"cancer\" (broad query - clarification test)\n      Expected: Low confidence, possibly clarification question\n      Verify: Clarification banner may appear or broad results returned\n\n   6. \"\" (empty query)\n      Expected: Error handling or prompt for input\n      Verify: Graceful handling without crash\n\n   7. \"asdfghjkl\" (gibberish)\n      Expected: No results or clarification\n      Verify: Empty state displayed with suggestions\n\n   8. Pagination test with broad query\n      Verify: Navigate between pages, results update correctly\n\n   9. Mobile responsive test\n      Verify: All components render correctly on mobile viewport\n   ```\n\n5. Performance optimizations:\n   - Verify debounce timing (300ms) provides good UX\n   - Test skeleton loading shows immediately\n   - Verify animations don't cause layout shift\n   - Check network waterfall for optimal loading",
        "testStrategy": "1. Execute all 9 end-to-end test scenarios documented above\n2. Record screenshots of each query result for verification\n3. Test on multiple browsers (Chrome, Firefox, Safari)\n4. Test responsive design at breakpoints: 320px, 768px, 1024px, 1440px\n5. Lighthouse audit for performance, accessibility, SEO\n6. Test with slow network throttling (3G simulation)\n7. Verify keyboard navigation works throughout app\n8. Test screen reader compatibility for accessibility\n9. Cross-browser animation rendering verification\n10. Final visual QA against design specifications",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Complete index.css with Google Fonts and Custom Animations",
            "description": "Create the complete frontend/src/index.css file with Google Fonts imports (Fraunces serif for headings, Outfit sans-serif for body), CSS custom properties for theme colors (teal primary #0D4F4F, amber accent #D4A843, warm gray background #F8F6F3), keyframe animations (fadeIn, slideDown, shimmer), custom scrollbar styling, and focus states with amber glow.",
            "dependencies": [],
            "details": "1. Add Google Fonts import for Fraunces (opsz,wght@9..144,400;600;700) and Outfit (wght@400;500;600) with display=swap for performance\n2. Configure Tailwind CSS import directive\n3. Define CSS custom properties in :root - --color-primary: #0D4F4F, --color-accent: #D4A843, --color-bg: #F8F6F3\n4. Set body font-family to Outfit with background-color using var(--color-bg)\n5. Create .font-serif class using Fraunces for editorial headings\n6. Implement @keyframes fadeIn animation (opacity 0→1, translateY 8px→0, duration 0.3s ease-out)\n7. Implement @keyframes slideDown animation (opacity 0→1, translateY -10px→0, duration 0.2s ease-out)\n8. Implement @keyframes shimmer animation for loading states (background-position -200%→200%, duration 1.5s infinite)\n9. Create utility classes: .animate-fadeIn, .animate-slideDown, .animate-pulse (using shimmer)\n10. Style input:focus with amber box-shadow (0 0 0 4px rgba(212, 168, 67, 0.2))\n11. Add webkit scrollbar styling (8px width, #f1f1f1 track, #c1c1c1 thumb with 4px border-radius)",
            "status": "pending",
            "testStrategy": "Verify Google Fonts load correctly by inspecting network requests for fonts.googleapis.com. Test animations by adding test classes to elements and confirming smooth transitions. Check custom scrollbar appears in webkit browsers. Validate focus states trigger on input focus. Use Chrome DevTools to verify CSS custom properties are applied correctly.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configure tailwind.config.ts with Extended Theme and Custom Fonts",
            "description": "Update frontend/tailwind.config.ts with extended color palette including custom teal shades (50-900 with 700 as primary #0D4F4F), amber accent colors (400 #D4A843, 500 #c99a3a), custom font families (Fraunces for serif, Outfit for sans-serif), and ensure content paths include all source files.",
            "dependencies": [
              1
            ],
            "details": "1. Import Config type from tailwindcss for TypeScript support\n2. Configure content array to include './index.html' and './src/**/*.{js,ts,jsx,tsx}'\n3. Extend theme.colors.teal with full palette: 50 #f0fdfa, 100 #ccfbf1, 200 #99f6e4, 300 #5eead4, 400 #2dd4bf, 500 #14b8a6, 600 #0d9488, 700 #0D4F4F (primary), 800 #0A3D3D, 900 #082f2f\n4. Extend theme.colors.amber with accent shades: 400 #D4A843, 500 #c99a3a\n5. Configure fontFamily.serif as ['Fraunces', 'serif'] for editorial headings\n6. Configure fontFamily.sans as ['Outfit', 'sans-serif'] for body/UI text\n7. Export configuration using 'satisfies Config' for type safety\n8. Verify plugins array is empty (no external dependencies needed)",
            "status": "pending",
            "testStrategy": "Run Tailwind build and verify no configuration errors. Test that teal-700 class applies #0D4F4F correctly. Verify font-serif and font-sans classes apply correct font families. Use browser DevTools to inspect computed styles and confirm extended colors are available.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update index.html with Meta Tags and Font Preconnect Links",
            "description": "Update frontend/index.html with proper HTML5 doctype, language attribute, essential meta tags (charset UTF-8, viewport for responsive design, description for SEO), and font preconnect links to fonts.googleapis.com and fonts.gstatic.com for optimal font loading performance.",
            "dependencies": [],
            "details": "1. Ensure DOCTYPE html is present at the top\n2. Add lang=\"en\" attribute to html element\n3. Add meta charset=\"UTF-8\" in head section\n4. Add meta viewport with 'width=device-width, initial-scale=1.0' for responsive design\n5. Add meta description: 'Search clinical trials using natural language'\n6. Set page title to 'Clinical Trials Search'\n7. Add preconnect link for 'https://fonts.googleapis.com' to establish early connection\n8. Add preconnect link for 'https://fonts.gstatic.com' with crossorigin attribute for font files\n9. Ensure div#root is present in body for React mounting\n10. Verify script tag loads '/src/main.tsx' with type=\"module\"",
            "status": "pending",
            "testStrategy": "Validate HTML using W3C validator. Check network waterfall in DevTools to confirm preconnect reduces font loading time. Verify meta viewport enables proper mobile scaling. Test that description appears in browser tab preview and search engine results simulation.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Execute End-to-End Test Scenarios for Query Processing",
            "description": "Execute comprehensive end-to-end test scenarios covering multi-entity queries, synonym mapping, clarification triggers, empty/gibberish input handling, and pagination. Document results for each test case including expected vs actual behavior.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Test Case 1: 'Phase 3 lung cancer trials in the USA' - Verify phase=PHASE3, condition=lung cancer, location.country=United States are extracted and results contain Phase 3 lung cancer trials in US\nTest Case 2: 'recruiting diabetes trials near Boston' - Verify status=RECRUITING, condition=diabetes, location.city=Boston and all results show RECRUITING status\nTest Case 3: 'List all Phase 2 trials for Breast Cancer associated with BRCA1 gene' - Verify phase=PHASE2, condition=Breast Cancer, keyword=BRCA1 and results mention BRCA1\nTest Case 4: 'open melanoma trials' - Test synonym mapping 'open'->RECRUITING, verify status=RECRUITING for melanoma trials\nTest Case 5: 'cancer' - Test broad query handling, check if low confidence triggers clarification banner or returns broad results gracefully\nTest Case 6: '' (empty query) - Verify graceful error handling without crash, appropriate error message displayed\nTest Case 7: 'asdfghjkl' (gibberish) - Verify empty state with suggestions is displayed\nTest Case 8: Pagination - Submit broad query, navigate between pages, verify results update correctly and page indicators are accurate\nDocument all results with screenshots if applicable",
            "status": "pending",
            "testStrategy": "Execute each test case manually in the browser. Record the query interpretation displayed in the UI and compare with expected entity extraction. Verify result cards match search criteria. Check browser console for JavaScript errors during each test. Document pass/fail status for each scenario.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Test Responsive Design at Key Breakpoints and Fix Layout Issues",
            "description": "Test responsive design at critical breakpoints (320px mobile, 768px tablet, 1024px laptop, 1440px desktop) across all components. Identify and fix any layout issues including overflow, text truncation, spacing problems, and component stacking on narrow viewports.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "1. Test at 320px (small mobile): Verify search bar is full-width with adequate padding, result cards stack vertically, entity chips wrap properly, pagination controls remain accessible, no horizontal scrolling occurs, fonts remain readable at minimum sizes\n2. Test at 768px (tablet): Verify search section has appropriate margins, result cards may be 2-column if designed, query interpretation strip scales properly, clarification banner adapts to width\n3. Test at 1024px (laptop): Verify content is centered with max-width container, proper spacing between search/interpretation/results sections, hover states work correctly\n4. Test at 1440px (desktop): Verify layout uses available space without excessive stretching, typography hierarchy is maintained, generous whitespace as per PRD spec\n5. Fix any identified issues: Update Tailwind responsive classes (sm:, md:, lg:, xl:), adjust grid/flex layouts, ensure touch targets are minimum 44px on mobile, verify images/icons scale appropriately",
            "status": "pending",
            "testStrategy": "Use Chrome DevTools device emulation to test each breakpoint. Test on actual mobile devices if available. Use responsive design mode in Firefox for cross-validation. Check that all interactive elements are accessible at each breakpoint. Verify no content is cut off or overlapping.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Performance Optimization and Animation Quality Verification",
            "description": "Verify and optimize performance characteristics including debounce timing (300ms for search input), skeleton loading immediate display, animation smoothness without layout shift, and network waterfall efficiency. Conduct Lighthouse audits and address any performance issues.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "1. Verify debounce timing: Type in search bar and confirm suggestions API is called after 300ms pause, not on every keystroke. Test that typing continuously does not trigger multiple API calls\n2. Test skeleton loading: Submit search query and verify skeleton cards with shimmer animation appear immediately (within 100ms) before results load\n3. Check layout shift: Use Chrome DevTools Performance panel to record search flow, verify CLS (Cumulative Layout Shift) score is below 0.1, ensure animations don't cause content to jump\n4. Verify animation performance: Check that fadeIn, slideDown, and shimmer animations run at 60fps using DevTools Performance monitor, no jank during card reveal animations\n5. Network waterfall analysis: Check that fonts are loaded with preconnect optimization, API calls are not duplicated, responses are appropriately sized\n6. Run Lighthouse audit: Target Performance score >90, Accessibility score >90, Best Practices >90. Address any flagged issues\n7. Verify staggered card animation doesn't cause visible performance degradation with 10+ results",
            "status": "pending",
            "testStrategy": "Use Chrome DevTools Performance panel to profile search interactions. Run Lighthouse in incognito mode for accurate scores. Test on throttled 3G network to verify skeleton loading behavior. Use requestAnimationFrame timing to verify animation performance. Document any CLS issues with before/after screenshots.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down visual polish and testing into: 1) Complete index.css with Google Fonts import (Fraunces, Outfit), CSS variables for theme colors, keyframe animations (fadeIn, slideDown, shimmer), and custom scrollbar styling, 2) Configure tailwind.config.ts with extended color palette (teal-700 as primary, amber-400 as accent), custom font families, and animation utilities, 3) Update index.html with proper meta tags, font preconnect links, and description, 4) Execute end-to-end test scenarios covering: synonym mapping, complex multi-entity queries, clarification triggers, empty/gibberish input, and pagination, 5) Test responsive design at key breakpoints (320px, 768px, 1024px, 1440px) and fix any layout issues, 6) Performance optimization: verify debounce timing, check animation performance, ensure no layout shift. Each subtask should include verification against the PRD design specs."
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-07T17:17:03.209Z",
      "taskCount": 10,
      "completedCount": 1,
      "tags": [
        "master"
      ]
    }
  }
}