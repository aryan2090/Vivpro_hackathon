{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Foundation and Infrastructure Setup",
        "description": "Set up the complete development environment including Docker Compose for Elasticsearch 9.3.0, FastAPI backend project structure, and React+Vite+TypeScript frontend scaffold with Tailwind CSS configuration.",
        "details": "1. Create `docker-compose.yml` with Elasticsearch 9.3.0 service:\n   ```yaml\n   version: '3.8'\n   services:\n     elasticsearch:\n       image: docker.elastic.co/elasticsearch/elasticsearch:9.3.0\n       container_name: clinical-trials-es\n       environment:\n         - discovery.type=single-node\n         - xpack.security.enabled=false\n         - ES_JAVA_OPTS=-Xms512m -Xmx512m\n       ports:\n         - \"9200:9200\"\n       volumes:\n         - esdata:/usr/share/elasticsearch/data\n   volumes:\n     esdata:\n   ```\n\n2. Create backend structure:\n   ```\n   backend/\n   ├── app/\n   │   ├── __init__.py\n   │   ├── main.py           # FastAPI app entry\n   │   ├── config.py         # Pydantic Settings\n   │   ├── routers/\n   │   │   ├── __init__.py\n   │   │   └── search.py\n   │   ├── services/\n   │   │   ├── __init__.py\n   │   │   ├── llm_service.py\n   │   │   ├── es_service.py\n   │   │   └── suggestion.py\n   │   ├── models/\n   │   │   ├── __init__.py\n   │   │   ├── schemas.py\n   │   │   └── entities.py\n   │   └── utils/\n   │       ├── __init__.py\n   │       └── synonyms.py\n   ├── scripts/\n   │   ├── ingest.py\n   │   └── create_index.py\n   └── requirements.txt\n   ```\n\n3. Create `backend/requirements.txt`:\n   ```\n   fastapi==0.115.12\n   uvicorn[standard]==0.34.0\n   elasticsearch==9.0.1\n   anthropic==0.52.0\n   pydantic==2.11.4\n   pydantic-settings==2.8.1\n   python-dotenv==1.1.0\n   httpx==0.28.1\n   ```\n\n4. Create `backend/app/config.py` with Pydantic Settings:\n   ```python\n   from pydantic_settings import BaseSettings\n   from functools import lru_cache\n\n   class Settings(BaseSettings):\n       es_url: str = \"http://localhost:9200\"\n       es_index: str = \"clinical_trials\"\n       anthropic_api_key: str\n       log_level: str = \"INFO\"\n\n       class Config:\n           env_file = \".env\"\n\n   @lru_cache()\n   def get_settings() -> Settings:\n       return Settings()\n   ```\n\n5. Initialize frontend with Vite + React + TypeScript:\n   ```bash\n   npm create vite@latest frontend -- --template react-ts\n   cd frontend && npm install\n   npm install -D tailwindcss@4.0.5 @tailwindcss/vite\n   ```\n\n6. Configure Tailwind CSS in `frontend/vite.config.ts`:\n   ```typescript\n   import { defineConfig } from 'vite'\n   import react from '@vitejs/plugin-react'\n   import tailwindcss from '@tailwindcss/vite'\n\n   export default defineConfig({\n     plugins: [react(), tailwindcss()],\n   })\n   ```\n\n7. Set up custom theme in `frontend/src/index.css` with CSS variables:\n   - Primary: #0D4F4F (deep teal)\n   - Accent: #D4A843 (warm amber)\n   - Background: #F8F6F3\n   - Status colors for badges\n   - Import Google Fonts (Fraunces for display, Outfit for body)\n\n8. Create `.env` file at project root with required API keys.",
        "testStrategy": "1. Verify Docker Compose starts Elasticsearch: `docker-compose up -d && curl http://localhost:9200`\n2. Verify backend dependencies install: `cd backend && pip install -r requirements.txt`\n3. Verify frontend builds: `cd frontend && npm run dev`\n4. Check Tailwind CSS compiles with custom theme\n5. Verify config.py loads environment variables correctly",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Docker Compose Configuration for Elasticsearch 9.3.0",
            "description": "Create the docker-compose.yml file at project root with Elasticsearch 9.3.0 service configured for single-node development mode with proper memory settings and persistent volume.",
            "dependencies": [],
            "details": "Create `docker-compose.yml` in the project root directory with the following configuration:\n- Use Elasticsearch 9.3.0 official image from docker.elastic.co\n- Set container name to 'clinical-trials-es'\n- Configure single-node discovery mode for local development\n- Disable xpack security for development simplicity\n- Set JVM heap to 512MB min/max via ES_JAVA_OPTS\n- Map port 9200:9200 for REST API access\n- Create named volume 'esdata' for data persistence\n- Add healthcheck command to verify cluster is ready\n\nVerification steps:\n1. Run `docker-compose up -d` to start the container\n2. Wait 30 seconds for Elasticsearch to initialize\n3. Execute `curl -s http://localhost:9200` and verify JSON response with cluster name\n4. Check `curl -s http://localhost:9200/_cluster/health` returns status 'green' or 'yellow'\n5. Run `docker-compose down` to clean up",
            "status": "done",
            "testStrategy": "Run `docker-compose up -d && sleep 30 && curl -s http://localhost:9200 | grep -q 'cluster_name' && echo 'SUCCESS' || echo 'FAILED'`. Verify Elasticsearch responds on port 9200 with valid cluster information. Test volume persistence by indexing a document, restarting container, and verifying document exists.",
            "updatedAt": "2026-02-07T17:17:03.188Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Backend Python Project Directory Structure",
            "description": "Set up the complete FastAPI backend directory structure with all required subdirectories and __init__.py files for proper Python package organization.",
            "dependencies": [
              1
            ],
            "details": "Create the following directory structure under `backend/`:\n```\nbackend/\n├── app/\n│   ├── __init__.py\n│   ├── main.py           # FastAPI app entry point (placeholder)\n│   ├── config.py         # Will be populated in subtask 4\n│   ├── routers/\n│   │   ├── __init__.py\n│   │   └── search.py     # Placeholder for search routes\n│   ├── services/\n│   │   ├── __init__.py\n│   │   ├── llm_service.py    # Placeholder\n│   │   ├── es_service.py     # Placeholder\n│   │   └── suggestion.py     # Placeholder\n│   ├── models/\n│   │   ├── __init__.py\n│   │   ├── schemas.py    # Placeholder\n│   │   └── entities.py   # Placeholder\n│   └── utils/\n│       ├── __init__.py\n│       └── synonyms.py   # Placeholder\n├── scripts/\n│   ├── ingest.py         # Placeholder\n│   └── create_index.py   # Placeholder\n└── requirements.txt      # Will be populated in subtask 3\n```\n\nEach __init__.py should be empty initially. main.py should contain a minimal FastAPI app:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI(title=\"Clinical Trials Search API\")\n\n@app.get(\"/health\")\ndef health():\n    return {\"status\": \"healthy\"}\n```\n\nVerification: Run `python -c \"from app.main import app; print(app.title)\"` from backend directory.",
            "status": "done",
            "testStrategy": "Verify all directories exist with `find backend -type d | sort`. Verify all __init__.py files exist with `find backend -name '__init__.py' | wc -l` (should be 5). Test Python import with `cd backend && python -c 'from app.main import app'` succeeds without errors.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T17:17:03.198Z"
          },
          {
            "id": 3,
            "title": "Create Backend requirements.txt with All Dependencies",
            "description": "Create the requirements.txt file with all necessary Python dependencies including FastAPI, Uvicorn, Elasticsearch client, Anthropic SDK, and Pydantic with exact version pinning.",
            "dependencies": [
              2
            ],
            "details": "Create `backend/requirements.txt` with the following pinned dependencies:\n```\nfastapi==0.115.12\nuvicorn[standard]==0.34.0\nelasticsearch==9.0.1\nanthropic==0.52.0\npydantic==2.11.4\npydantic-settings==2.8.1\npython-dotenv==1.1.0\nhttpx==0.28.1\n```\n\nDependency purposes:\n- fastapi: Web framework for API\n- uvicorn[standard]: ASGI server with uvloop and httptools\n- elasticsearch: Official ES Python client compatible with ES 9.x\n- anthropic: Claude API SDK for LLM entity extraction\n- pydantic/pydantic-settings: Data validation and settings management\n- python-dotenv: Environment variable loading\n- httpx: Async HTTP client (used by anthropic SDK)\n\nVerification steps:\n1. Create a virtual environment: `python -m venv venv`\n2. Activate it: `source venv/bin/activate` (Unix) or `venv\\Scripts\\activate` (Windows)\n3. Install dependencies: `pip install -r requirements.txt`\n4. Verify installations: `pip list | grep -E 'fastapi|elasticsearch|anthropic'`\n5. Test imports: `python -c \"import fastapi, elasticsearch, anthropic; print('All imports successful')\"`",
            "status": "done",
            "testStrategy": "Create fresh virtual environment and run `pip install -r backend/requirements.txt`. Verify exit code is 0 and no version conflicts. Run `python -c 'import fastapi; import elasticsearch; import anthropic; import pydantic_settings; print(\"OK\")'` to confirm all packages are importable.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T17:17:03.201Z"
          },
          {
            "id": 4,
            "title": "Implement Pydantic Settings Configuration Module",
            "description": "Create the config.py module with Pydantic Settings for environment-based configuration including Elasticsearch URL, index name, Anthropic API key, and logging level with caching.",
            "dependencies": [
              3
            ],
            "details": "Create `backend/app/config.py` with the following implementation:\n```python\nfrom pydantic_settings import BaseSettings\nfrom functools import lru_cache\nfrom typing import Optional\n\nclass Settings(BaseSettings):\n    # Elasticsearch configuration\n    es_url: str = \"http://localhost:9200\"\n    es_index: str = \"clinical_trials\"\n    \n    # API Keys\n    anthropic_api_key: str\n    \n    # Application settings\n    log_level: str = \"INFO\"\n    \n    # Optional: for future extensions\n    cors_origins: str = \"http://localhost:5173\"\n    \n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n        case_sensitive = False\n\n@lru_cache()\ndef get_settings() -> Settings:\n    \"\"\"Cached settings instance to avoid re-reading .env on every call.\"\"\"\n    return Settings()\n```\n\nUpdate `backend/app/main.py` to use settings:\n```python\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom app.config import get_settings\n\nsettings = get_settings()\napp = FastAPI(title=\"Clinical Trials Search API\")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[settings.cors_origins],\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n@app.get(\"/health\")\ndef health():\n    return {\"status\": \"healthy\", \"es_url\": settings.es_url}\n```\n\nVerification: Create a test .env and verify settings load correctly.",
            "status": "done",
            "testStrategy": "Create a temporary .env file with `echo 'ANTHROPIC_API_KEY=test-key-123' > backend/.env`. Run `cd backend && python -c \"from app.config import get_settings; s = get_settings(); print(s.es_url, s.anthropic_api_key)\"`. Verify output shows default es_url and the test API key. Test that missing required fields raise ValidationError.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T17:17:03.203Z"
          },
          {
            "id": 5,
            "title": "Initialize Frontend with Vite, React, and TypeScript",
            "description": "Create the frontend project using Vite with React and TypeScript template, install all base dependencies, and verify the development server runs correctly.",
            "dependencies": [
              1
            ],
            "details": "Execute the following commands to initialize the frontend:\n\n1. Create Vite project with React TypeScript template:\n```bash\nnpm create vite@latest frontend -- --template react-ts\n```\n\n2. Navigate to frontend and install dependencies:\n```bash\ncd frontend\nnpm install\n```\n\n3. Install Tailwind CSS 4.0 and Vite plugin:\n```bash\nnpm install -D tailwindcss@4.0.5 @tailwindcss/vite\n```\n\n4. Verify project structure includes:\n- frontend/src/main.tsx (entry point)\n- frontend/src/App.tsx (root component)\n- frontend/vite.config.ts (build configuration)\n- frontend/tsconfig.json (TypeScript config)\n- frontend/package.json (dependencies)\n\n5. Clean up default Vite boilerplate:\n- Remove default App.css content\n- Simplify App.tsx to basic component\n- Remove Vite/React logos from assets if present\n\nVerification:\n1. Run `npm run dev` and verify server starts on port 5173\n2. Open http://localhost:5173 in browser\n3. Verify hot module replacement works by editing App.tsx",
            "status": "done",
            "testStrategy": "Run `cd frontend && npm run dev -- --port 5173 &` to start dev server in background. Wait 5 seconds, then `curl -s http://localhost:5173 | grep -q 'vite' && echo 'SUCCESS'`. Run `npm run build` to verify TypeScript compilation succeeds with no errors. Kill the background server after tests.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T17:17:03.205Z"
          },
          {
            "id": 6,
            "title": "Configure Tailwind CSS 4.0 with Custom Theme",
            "description": "Set up Tailwind CSS 4.0 configuration in Vite, create custom theme with project-specific colors (deep teal, warm amber), import Google Fonts (Fraunces, Outfit), and define CSS custom properties.",
            "dependencies": [
              5
            ],
            "details": "1. Update `frontend/vite.config.ts`:\n```typescript\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport tailwindcss from '@tailwindcss/vite'\n\nexport default defineConfig({\n  plugins: [react(), tailwindcss()],\n  server: {\n    proxy: {\n      '/api': 'http://localhost:8000'\n    }\n  }\n})\n```\n\n2. Replace `frontend/src/index.css` with custom theme:\n```css\n@import url('https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,400;9..144,600;9..144,700&family=Outfit:wght@400;500;600&display=swap');\n@import 'tailwindcss';\n\n:root {\n  /* Primary colors */\n  --color-primary: #0D4F4F;\n  --color-primary-light: #1A6B6B;\n  --color-primary-dark: #083838;\n  \n  /* Accent colors */\n  --color-accent: #D4A843;\n  --color-accent-light: #E5C06A;\n  --color-accent-dark: #B8902E;\n  \n  /* Background */\n  --color-bg: #F8F6F3;\n  --color-bg-card: #FFFFFF;\n  \n  /* Text */\n  --color-text: #1F2937;\n  --color-text-muted: #6B7280;\n  \n  /* Status badge colors */\n  --color-status-recruiting: #059669;\n  --color-status-completed: #6366F1;\n  --color-status-active: #0EA5E9;\n  --color-status-terminated: #DC2626;\n}\n\nbody {\n  font-family: 'Outfit', sans-serif;\n  background-color: var(--color-bg);\n  color: var(--color-text);\n}\n\n.font-display {\n  font-family: 'Fraunces', serif;\n}\n```\n\n3. Update `frontend/src/App.tsx` to test theme:\n```tsx\nfunction App() {\n  return (\n    <div className=\"min-h-screen bg-[var(--color-bg)] p-8\">\n      <h1 className=\"font-display text-4xl text-[var(--color-primary)] mb-4\">\n        Clinical Trials Search\n      </h1>\n      <p className=\"text-[var(--color-text-muted)]\">\n        Theme configured successfully\n      </p>\n      <button className=\"mt-4 px-4 py-2 bg-[var(--color-accent)] text-white rounded\">\n        Test Button\n      </button>\n    </div>\n  )\n}\nexport default App\n```",
            "status": "done",
            "testStrategy": "Run `npm run dev` and visually verify: 1) Background is cream/off-white (#F8F6F3), 2) Heading uses Fraunces serif font in deep teal (#0D4F4F), 3) Button shows warm amber (#D4A843). Inspect elements in browser DevTools to confirm CSS variables are applied. Run `npm run build` to ensure Tailwind purges unused styles correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T17:17:03.207Z"
          },
          {
            "id": 7,
            "title": "Create Environment File with Required API Keys",
            "description": "Set up the .env file at project root with all required environment variables, create .env.example template for documentation, and configure .gitignore to exclude sensitive files.",
            "dependencies": [
              4,
              6
            ],
            "details": "1. Create `.env` at project root with required variables:\n```\n# Elasticsearch Configuration\nES_URL=http://localhost:9200\nES_INDEX=clinical_trials\n\n# Anthropic API (required for LLM entity extraction)\nANTHROPIC_API_KEY=your-anthropic-api-key-here\n\n# Application Settings\nLOG_LEVEL=INFO\nCORS_ORIGINS=http://localhost:5173\n```\n\n2. Create `.env.example` for documentation (safe to commit):\n```\n# Copy this file to .env and fill in your values\n# Elasticsearch Configuration\nES_URL=http://localhost:9200\nES_INDEX=clinical_trials\n\n# Anthropic API (get from https://console.anthropic.com/)\nANTHROPIC_API_KEY=\n\n# Application Settings\nLOG_LEVEL=INFO\nCORS_ORIGINS=http://localhost:5173\n```\n\n3. Ensure `.gitignore` includes (create if not exists or append):\n```\n# Environment files\n.env\n.env.local\n.env.*.local\n\n# Python\n__pycache__/\n*.py[cod]\nvenv/\n.venv/\n\n# Node\nnode_modules/\ndist/\n\n# Elasticsearch data\nesdata/\n\n# IDE\n.idea/\n.vscode/\n*.swp\n```\n\n4. Create symlink or copy .env to backend directory for Python access:\n```bash\nln -s ../.env backend/.env\n# Or simply: cp .env backend/.env\n```\n\nVerification:\n1. Check .env is not tracked: `git status | grep -v '.env'`\n2. Verify backend can read settings: `cd backend && python -c \"from app.config import get_settings; print(get_settings().es_url)\"`\n3. Confirm .env.example is tracked: `git add .env.example`",
            "status": "done",
            "testStrategy": "Verify .env file exists with `test -f .env && echo 'EXISTS'`. Verify .gitignore excludes .env with `git check-ignore .env && echo 'IGNORED'`. Test backend config loads by running `cd backend && python -c \"from app.config import get_settings; s = get_settings(); assert s.es_url == 'http://localhost:9200'\"`. Verify .env.example is trackable with `git add --dry-run .env.example`.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T17:17:03.209Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Break down the project foundation setup into: 1) Docker Compose configuration for Elasticsearch 9.3.0 with proper settings, 2) Backend Python project structure creation with all directories, 3) requirements.txt with all dependencies and versions, 4) Pydantic Settings configuration in config.py, 5) Frontend Vite+React+TypeScript project initialization, 6) Tailwind CSS 4.0 configuration with custom theme (colors, fonts via CSS variables), 7) Environment file setup with required API keys. Each subtask should include verification steps.",
        "updatedAt": "2026-02-07T17:17:03.209Z"
      },
      {
        "id": 2,
        "title": "Pydantic Data Models and Type Definitions",
        "description": "Define comprehensive Pydantic models for entity extraction, API request/response schemas, and corresponding TypeScript interfaces for the frontend.",
        "details": "1. Create `backend/app/models/entities.py`:\n   ```python\n   from pydantic import BaseModel, Field\n   from typing import Optional, List\n   from enum import Enum\n\n   class PhaseEnum(str, Enum):\n       PHASE1 = \"PHASE1\"\n       PHASE2 = \"PHASE2\"\n       PHASE3 = \"PHASE3\"\n       PHASE4 = \"PHASE4\"\n       EARLY_PHASE1 = \"EARLY_PHASE1\"\n       NA = \"NA\"\n\n   class StatusEnum(str, Enum):\n       RECRUITING = \"RECRUITING\"\n       NOT_YET_RECRUITING = \"NOT_YET_RECRUITING\"\n       COMPLETED = \"COMPLETED\"\n       ACTIVE_NOT_RECRUITING = \"ACTIVE_NOT_RECRUITING\"\n       TERMINATED = \"TERMINATED\"\n       WITHDRAWN = \"WITHDRAWN\"\n       SUSPENDED = \"SUSPENDED\"\n\n   class LocationFilter(BaseModel):\n       city: Optional[str] = None\n       state: Optional[str] = None\n       country: Optional[str] = None\n\n   class ExtractedEntities(BaseModel):\n       phase: Optional[str] = Field(None, description=\"Clinical trial phase\")\n       condition: Optional[str] = Field(None, description=\"Medical condition/disease\")\n       status: Optional[str] = Field(None, description=\"Trial recruitment status\")\n       location: Optional[LocationFilter] = Field(None, description=\"Geographic location\")\n       sponsor: Optional[str] = Field(None, description=\"Sponsoring organization\")\n       keyword: Optional[str] = Field(None, description=\"Gene, drug, or specific term\")\n       age_group: Optional[str] = Field(None, description=\"Target age group\")\n       enrollment_min: Optional[int] = Field(None, description=\"Minimum enrollment\")\n       enrollment_max: Optional[int] = Field(None, description=\"Maximum enrollment\")\n       confidence: float = Field(default=0.8, ge=0.0, le=1.0)\n       clarification: Optional[str] = Field(None, description=\"Follow-up question\")\n   ```\n\n2. Create `backend/app/models/schemas.py`:\n   ```python\n   from pydantic import BaseModel\n   from typing import List, Optional, Any, Dict\n   from .entities import ExtractedEntities\n\n   class Sponsor(BaseModel):\n       name: str\n       agency_class: Optional[str] = None\n       lead_or_collaborator: Optional[str] = None\n\n   class Facility(BaseModel):\n       name: Optional[str] = None\n       city: Optional[str] = None\n       state: Optional[str] = None\n       country: Optional[str] = None\n\n   class TrialResult(BaseModel):\n       nct_id: str\n       brief_title: str\n       official_title: Optional[str] = None\n       phase: Optional[str] = None\n       overall_status: Optional[str] = None\n       enrollment: Optional[int] = None\n       sponsors: List[Sponsor] = []\n       facilities: List[Facility] = []\n       brief_summaries_description: Optional[str] = None\n       start_date: Optional[str] = None\n       age: List[Dict[str, str]] = []\n\n   class SearchResponse(BaseModel):\n       query_interpretation: ExtractedEntities\n       results: List[TrialResult]\n       total: int\n       page: int\n       page_size: int\n       clarification: Optional[str] = None\n\n   class SuggestionResponse(BaseModel):\n       suggestions: List[str]\n\n   class ErrorResponse(BaseModel):\n       error: str\n       detail: str\n   ```\n\n3. Create `frontend/src/types/index.ts`:\n   ```typescript\n   export interface LocationFilter {\n     city?: string;\n     state?: string;\n     country?: string;\n   }\n\n   export interface ExtractedEntities {\n     phase?: string;\n     condition?: string;\n     status?: string;\n     location?: LocationFilter;\n     sponsor?: string;\n     keyword?: string;\n     age_group?: string;\n     enrollment_min?: number;\n     enrollment_max?: number;\n     confidence: number;\n     clarification?: string;\n   }\n\n   export interface Sponsor {\n     name: string;\n     agency_class?: string;\n     lead_or_collaborator?: string;\n   }\n\n   export interface Facility {\n     name?: string;\n     city?: string;\n     state?: string;\n     country?: string;\n   }\n\n   export interface TrialResult {\n     nct_id: string;\n     brief_title: string;\n     official_title?: string;\n     phase?: string;\n     overall_status?: string;\n     enrollment?: number;\n     sponsors: Sponsor[];\n     facilities: Facility[];\n     brief_summaries_description?: string;\n     start_date?: string;\n     age: { age_category: string }[];\n   }\n\n   export interface SearchResponse {\n     query_interpretation: ExtractedEntities;\n     results: TrialResult[];\n     total: number;\n     page: number;\n     page_size: number;\n     clarification?: string;\n   }\n\n   export interface SuggestionResponse {\n     suggestions: string[];\n   }\n   ```",
        "testStrategy": "1. Unit test Pydantic model validation with sample data from clinical_trials.json\n2. Test optional field handling with partial data\n3. Test enum validation for phase and status fields\n4. Verify TypeScript types compile without errors\n5. Test round-trip serialization/deserialization",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create entities.py with ExtractedEntities, Enums, and LocationFilter",
            "description": "Create the backend/app/models/entities.py file containing PhaseEnum, StatusEnum, LocationFilter, and ExtractedEntities Pydantic models with complete Field definitions, validation rules, and docstrings.",
            "dependencies": [],
            "details": "Create backend/app/models/entities.py with:\n1. PhaseEnum(str, Enum) with values: PHASE1, PHASE2, PHASE3, PHASE4, EARLY_PHASE1, NA\n2. StatusEnum(str, Enum) with values: RECRUITING, NOT_YET_RECRUITING, COMPLETED, ACTIVE_NOT_RECRUITING, TERMINATED, WITHDRAWN, SUSPENDED\n3. LocationFilter(BaseModel) with optional city, state, country string fields\n4. ExtractedEntities(BaseModel) with:\n   - phase: Optional[str] with Field description\n   - condition: Optional[str] for medical condition/disease\n   - status: Optional[str] for trial recruitment status\n   - location: Optional[LocationFilter] for geographic filtering\n   - sponsor: Optional[str] for sponsoring organization\n   - keyword: Optional[str] for gene, drug, or specific term\n   - age_group: Optional[str] for target age group\n   - enrollment_min/max: Optional[int] for enrollment range\n   - confidence: float with Field(default=0.8, ge=0.0, le=1.0)\n   - clarification: Optional[str] for follow-up questions\n5. Add __init__.py to models directory with proper exports",
            "status": "done",
            "testStrategy": "Test PhaseEnum and StatusEnum contain all expected values. Test LocationFilter accepts partial data (city only, country only). Test ExtractedEntities validation: confidence must be 0.0-1.0, optional fields accept None, all Field descriptions are set correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T17:35:08.019Z"
          },
          {
            "id": 2,
            "title": "Create schemas.py with API Request/Response Models",
            "description": "Create the backend/app/models/schemas.py file containing Sponsor, Facility, TrialResult, SearchResponse, SuggestionResponse, and ErrorResponse Pydantic models for API serialization.",
            "dependencies": [
              1
            ],
            "details": "Create backend/app/models/schemas.py with:\n1. Sponsor(BaseModel): name (str, required), agency_class (Optional[str]), lead_or_collaborator (Optional[str])\n2. Facility(BaseModel): name, city, state, country (all Optional[str])\n3. TrialResult(BaseModel):\n   - nct_id: str (required)\n   - brief_title: str (required)\n   - official_title: Optional[str]\n   - phase: Optional[str]\n   - overall_status: Optional[str]\n   - enrollment: Optional[int]\n   - sponsors: List[Sponsor] = []\n   - facilities: List[Facility] = []\n   - brief_summaries_description: Optional[str]\n   - start_date: Optional[str]\n   - age: List[Dict[str, str]] = []\n4. SearchResponse(BaseModel): query_interpretation (ExtractedEntities), results (List[TrialResult]), total (int), page (int), page_size (int), clarification (Optional[str])\n5. SuggestionResponse(BaseModel): suggestions (List[str])\n6. ErrorResponse(BaseModel): error (str), detail (str)\n7. Import ExtractedEntities from entities module",
            "status": "done",
            "testStrategy": "Test TrialResult requires nct_id and brief_title. Test SearchResponse serialization with nested ExtractedEntities and List[TrialResult]. Test Sponsor and Facility with partial data. Verify empty list defaults for sponsors, facilities, and age fields.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T17:35:08.022Z"
          },
          {
            "id": 3,
            "title": "Create Frontend TypeScript Interfaces Matching Pydantic Models",
            "description": "Create the frontend/src/types/index.ts file with TypeScript interfaces that exactly mirror all Pydantic models for type-safe API communication.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create frontend/src/types/index.ts with:\n1. LocationFilter interface: city?, state?, country? (all optional strings)\n2. ExtractedEntities interface: phase?, condition?, status?, location?: LocationFilter, sponsor?, keyword?, age_group? (optional strings), enrollment_min?, enrollment_max? (optional numbers), confidence: number (required), clarification?: string\n3. Sponsor interface: name: string (required), agency_class?: string, lead_or_collaborator?: string\n4. Facility interface: name?, city?, state?, country? (all optional strings)\n5. TrialResult interface: nct_id: string, brief_title: string (required), optional fields for official_title, phase, overall_status, enrollment (number), sponsors: Sponsor[], facilities: Facility[], brief_summaries_description?, start_date?, age: { age_category: string }[]\n6. SearchResponse interface: query_interpretation: ExtractedEntities, results: TrialResult[], total: number, page: number, page_size: number, clarification?: string\n7. SuggestionResponse interface: suggestions: string[]\n8. Export all interfaces",
            "status": "done",
            "testStrategy": "Verify TypeScript compilation succeeds with no errors. Test interface usage by creating sample objects matching each interface. Verify optional fields compile correctly. Test that TrialResult[] can be assigned to SearchResponse.results.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T17:35:08.024Z"
          },
          {
            "id": 4,
            "title": "Add Unit Tests for Model Validation with Clinical Trials Sample Data",
            "description": "Create comprehensive unit tests for all Pydantic models using sample data from clinical_trials.json to verify validation rules, optional field handling, and serialization.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create backend/tests/test_models.py with:\n1. Import pytest and all models from entities.py and schemas.py\n2. Load sample data from clinical_trials.json for realistic test cases\n3. Test ExtractedEntities:\n   - Test confidence validation (valid: 0.0, 0.5, 1.0; invalid: -0.1, 1.5)\n   - Test all optional fields accept None\n   - Test LocationFilter nested validation\n4. Test PhaseEnum and StatusEnum:\n   - Verify all enum values are accessible\n   - Test enum string serialization\n5. Test TrialResult:\n   - Test with complete data from clinical_trials.json\n   - Test with minimal required fields only (nct_id, brief_title)\n   - Test sponsors and facilities as empty lists\n6. Test SearchResponse:\n   - Test with nested ExtractedEntities and List[TrialResult]\n   - Test pagination fields (total, page, page_size)\n7. Test round-trip serialization: model.model_dump() -> Model(**data)\n8. Test ErrorResponse with error and detail strings\n9. Add conftest.py with sample data fixtures",
            "status": "done",
            "testStrategy": "Run pytest with coverage to ensure all model branches are tested. Verify tests pass with valid data and raise ValidationError for invalid data. Test edge cases: empty strings, zero values, boundary values for confidence (0.0, 1.0). Ensure tests are isolated and deterministic.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T17:35:08.026Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down data models creation into: 1) Create entities.py with ExtractedEntities model including all enums (PhaseEnum, StatusEnum), LocationFilter, and proper Field definitions with descriptions, 2) Create schemas.py with Sponsor, Facility, TrialResult, SearchResponse, SuggestionResponse, and ErrorResponse models, 3) Create frontend TypeScript interfaces in types/index.ts matching all Pydantic models exactly, 4) Add unit tests for model validation with sample data from clinical_trials.json. Each subtask should include type hints and validation rules.",
        "updatedAt": "2026-02-07T17:35:08.026Z"
      },
      {
        "id": 3,
        "title": "Elasticsearch Index Mapping and Bulk Ingestion",
        "description": "Create the Elasticsearch index with optimized field mappings for clinical trials data and implement bulk indexing script to load all 1000 documents.",
        "details": "1. Create `backend/scripts/create_index.py`:\n   ```python\n   from elasticsearch import Elasticsearch\n   import sys\n   sys.path.append('..')\n   from app.config import get_settings\n\n   def create_index():\n       settings = get_settings()\n       es = Elasticsearch([settings.es_url])\n       \n       mapping = {\n           \"settings\": {\n               \"number_of_shards\": 1,\n               \"number_of_replicas\": 0,\n               \"analysis\": {\n                   \"analyzer\": {\n                       \"clinical_analyzer\": {\n                           \"type\": \"custom\",\n                           \"tokenizer\": \"standard\",\n                           \"filter\": [\"lowercase\", \"asciifolding\"]\n                       }\n                   }\n               }\n           },\n           \"mappings\": {\n               \"properties\": {\n                   \"nct_id\": {\"type\": \"keyword\"},\n                   \"brief_title\": {\n                       \"type\": \"text\",\n                       \"analyzer\": \"clinical_analyzer\",\n                       \"fields\": {\n                           \"suggest\": {\"type\": \"search_as_you_type\"}\n                       }\n                   },\n                   \"official_title\": {\n                       \"type\": \"text\",\n                       \"analyzer\": \"clinical_analyzer\",\n                       \"fields\": {\n                           \"suggest\": {\"type\": \"search_as_you_type\"}\n                       }\n                   },\n                   \"phase\": {\"type\": \"keyword\"},\n                   \"overall_status\": {\"type\": \"keyword\"},\n                   \"enrollment\": {\"type\": \"integer\"},\n                   \"gender\": {\"type\": \"keyword\"},\n                   \"study_type\": {\"type\": \"keyword\"},\n                   \"intervention_model\": {\"type\": \"keyword\"},\n                   \"primary_purpose\": {\"type\": \"keyword\"},\n                   \"start_date\": {\"type\": \"date\"},\n                   \"completion_date\": {\"type\": \"date\"},\n                   \"primary_completion_date\": {\"type\": \"date\"},\n                   \"age\": {\n                       \"type\": \"nested\",\n                       \"properties\": {\n                           \"age_category\": {\"type\": \"keyword\"}\n                       }\n                   },\n                   \"sponsors\": {\n                       \"type\": \"nested\",\n                       \"properties\": {\n                           \"name\": {\n                               \"type\": \"text\",\n                               \"fields\": {\"keyword\": {\"type\": \"keyword\"}}\n                           },\n                           \"agency_class\": {\"type\": \"keyword\"},\n                           \"lead_or_collaborator\": {\"type\": \"keyword\"}\n                       }\n                   },\n                   \"facilities\": {\n                       \"type\": \"nested\",\n                       \"properties\": {\n                           \"name\": {\"type\": \"text\"},\n                           \"city\": {\"type\": \"keyword\"},\n                           \"state\": {\"type\": \"keyword\"},\n                           \"country\": {\"type\": \"keyword\"}\n                       }\n                   },\n                   \"design_outcomes\": {\n                       \"type\": \"nested\",\n                       \"properties\": {\n                           \"outcome_type\": {\"type\": \"keyword\"},\n                           \"measure\": {\"type\": \"text\"},\n                           \"time_frame\": {\"type\": \"text\"},\n                           \"description\": {\"type\": \"text\"}\n                       }\n                   },\n                   \"brief_summaries_description\": {\"type\": \"text\", \"analyzer\": \"clinical_analyzer\"},\n                   \"detailed_description\": {\"type\": \"text\", \"analyzer\": \"clinical_analyzer\"},\n                   \"source\": {\"type\": \"keyword\"},\n                   \"acronym\": {\"type\": \"keyword\"}\n               }\n           }\n       }\n       \n       if es.indices.exists(index=settings.es_index):\n           es.indices.delete(index=settings.es_index)\n       \n       es.indices.create(index=settings.es_index, body=mapping)\n       print(f\"Index '{settings.es_index}' created successfully\")\n\n   if __name__ == \"__main__\":\n       create_index()\n   ```\n\n2. Create `backend/scripts/ingest.py`:\n   ```python\n   import json\n   from elasticsearch import Elasticsearch\n   from elasticsearch.helpers import bulk\n   import sys\n   sys.path.append('..')\n   from app.config import get_settings\n\n   def transform_document(doc):\n       \"\"\"Transform document for ES indexing\"\"\"\n       # Convert enrollment from string to int\n       if doc.get('enrollment'):\n           try:\n               doc['enrollment'] = int(doc['enrollment'])\n           except (ValueError, TypeError):\n               doc['enrollment'] = None\n       \n       # Ensure nested arrays are properly structured\n       doc['sponsors'] = doc.get('sponsors') or []\n       doc['facilities'] = doc.get('facilities') or []\n       doc['design_outcomes'] = doc.get('design_outcomes') or []\n       doc['age'] = doc.get('age') or []\n       \n       return doc\n\n   def generate_bulk_actions(data, index_name):\n       for doc in data:\n           transformed = transform_document(doc)\n           yield {\n               \"_index\": index_name,\n               \"_id\": doc['nct_id'],\n               \"_source\": transformed\n           }\n\n   def ingest_data(filepath):\n       settings = get_settings()\n       es = Elasticsearch([settings.es_url])\n       \n       with open(filepath, 'r') as f:\n           data = json.load(f)\n       \n       success, failed = bulk(es, generate_bulk_actions(data, settings.es_index))\n       print(f\"Indexed {success} documents, {len(failed)} failed\")\n       \n       # Refresh index for immediate searchability\n       es.indices.refresh(index=settings.es_index)\n\n   if __name__ == \"__main__\":\n       ingest_data('../../clinical_trials.json')\n   ```",
        "testStrategy": "1. Verify index creation: `curl -X GET 'localhost:9200/clinical_trials/_mapping?pretty'`\n2. Run ingestion and verify count: `curl -X GET 'localhost:9200/clinical_trials/_count'` should return 1000\n3. Test sample queries:\n   - `curl -X GET 'localhost:9200/clinical_trials/_search?q=phase:PHASE2'`\n   - Nested query for facilities by country\n   - Range query on enrollment\n4. Verify search_as_you_type works with prefix queries\n5. Test enrollment type conversion with edge cases",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create create_index.py with complete Elasticsearch field mappings",
            "description": "Implement the create_index.py script with optimized field mappings for all clinical trial fields including keyword types (nct_id, phase, overall_status, gender, study_type), text fields with clinical_analyzer for searchable content (brief_title, official_title, descriptions), and search_as_you_type sub-fields for title autocomplete functionality.",
            "dependencies": [],
            "details": "Create backend/scripts/create_index.py with: 1) Custom 'clinical_analyzer' using standard tokenizer with lowercase and asciifolding filters. 2) Keyword mappings for: nct_id, phase, overall_status, gender, study_type, intervention_model, primary_purpose, source, acronym. 3) Text fields with clinical_analyzer for: brief_title, official_title, brief_summaries_description, detailed_description. 4) Add search_as_you_type sub-field for brief_title and official_title to enable autocomplete suggestions. 5) Integer mapping for enrollment field. 6) Date mappings for start_date, completion_date, primary_completion_date. 7) Include index settings with number_of_shards=1 and number_of_replicas=0 for development. 8) Add logic to delete existing index before recreation to allow re-running the script. Handle Elasticsearch connection errors gracefully.",
            "status": "done",
            "testStrategy": "Verify index creation with `curl -X GET 'localhost:9200/clinical_trials/_mapping?pretty'`. Check that all fields have correct types. Test that clinical_analyzer is properly configured by analyzing sample text. Verify search_as_you_type fields exist under brief_title.suggest and official_title.suggest.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:21:52.605Z"
          },
          {
            "id": 2,
            "title": "Define nested mappings for complex data structures",
            "description": "Add nested field mappings for sponsors, facilities, design_outcomes, and age arrays with appropriate field types for each property to support nested queries in Elasticsearch.",
            "dependencies": [
              1
            ],
            "details": "Extend create_index.py mapping to include: 1) 'sponsors' nested type with: name (text with keyword sub-field), agency_class (keyword), lead_or_collaborator (keyword). 2) 'facilities' nested type with: name (text), city (keyword), state (keyword), country (keyword), zip (keyword), status (keyword). 3) 'design_outcomes' nested type with: outcome_type (keyword), measure (text), time_frame (text), description (text). 4) 'age' nested type with: age_category (keyword). Nested types are required because these are arrays of objects that need independent querying - using 'object' type would flatten them and cause cross-object matching issues. Ensure proper handling of empty arrays and null values in nested fields.\n<info added on 2026-02-07T17:51:18.466Z>\nConfirmed update from Task 2: The Facility model in backend/app/models/schemas.py (lines 16-22) defines exactly 6 fields: name, city, state, zip, country, and status. The clinical_trials.json data confirms facilities contain all 6 fields (status, name, city, state, zip, country). The facilities nested mapping must include: name (text with keyword sub-field for full-text and exact match), city (keyword), state (keyword), zip (keyword), country (keyword), status (keyword). This aligns with the Pydantic Facility model and actual JSON data structure.\n</info added on 2026-02-07T17:51:18.466Z>",
            "status": "done",
            "testStrategy": "Create test documents with nested data and verify with nested queries. Test query: `{\"query\": {\"nested\": {\"path\": \"sponsors\", \"query\": {\"match\": {\"sponsors.name\": \"AstraZeneca\"}}}}}`. Verify facilities can be filtered by country. Test that empty arrays don't cause indexing errors.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:21:52.634Z"
          },
          {
            "id": 3,
            "title": "Implement ingest.py with document transformation logic",
            "description": "Create the ingest.py script with robust document transformation including enrollment string-to-integer conversion, null value handling for optional fields, and proper date format handling for Elasticsearch compatibility.",
            "dependencies": [
              1
            ],
            "details": "Create backend/scripts/ingest.py with transform_document() function that: 1) Converts 'enrollment' from string to integer, handling 'None', empty strings, and invalid values by setting to None. 2) Ensures nested arrays (sponsors, facilities, design_outcomes, age) default to empty arrays [] if null or missing. 3) Handles date fields (start_date, completion_date, primary_completion_date) - data shows ISO format with 'T00:00:00.000Z' which ES should accept directly. 4) Cleans string fields by stripping whitespace. 5) Handles 'None' string values in fields like number_of_groups by converting to null. 6) Preserves all other fields as-is. Add validation logging to identify problematic documents during development.",
            "status": "done",
            "testStrategy": "Unit test transform_document with edge cases: enrollment='540' -> 540, enrollment='None' -> None, enrollment='' -> None. Test nested array defaults. Test with actual sample document from clinical_trials.json. Verify all 1000 documents pass transformation without errors.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:21:52.642Z"
          },
          {
            "id": 4,
            "title": "Add bulk indexing with error handling and progress reporting",
            "description": "Implement the bulk indexing functionality using elasticsearch-py helpers.bulk() with proper error handling, progress reporting, and retry logic for failed documents.",
            "dependencies": [
              2,
              3
            ],
            "details": "Enhance ingest.py with: 1) generate_bulk_actions() generator that yields properly formatted bulk action dicts with _index, _id (nct_id), and _source. 2) Use elasticsearch.helpers.bulk() for efficient batching (default 500 docs per batch). 3) Add progress reporting using tqdm or simple print statements showing documents processed. 4) Capture and log failed documents with their nct_id and error reason. 5) Add --dry-run flag to validate transformations without indexing. 6) Implement retry logic for transient ES errors. 7) Call es.indices.refresh() after bulk indexing to make documents immediately searchable. 8) Add command-line argument for filepath with default to '../../clinical_trials.json'. 9) Report final statistics: total docs, successful, failed.",
            "status": "done",
            "testStrategy": "Run ingestion on full dataset and verify: 'curl -X GET localhost:9200/clinical_trials/_count' returns 1000. Test with intentionally malformed document to verify error handling. Verify progress output shows batch completion. Test dry-run mode doesn't modify index.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:21:52.646Z"
          },
          {
            "id": 5,
            "title": "Create verification script with sample queries for each field type",
            "description": "Implement a verification script that tests the indexed data with sample queries covering term queries for keywords, nested queries for complex fields, range queries for dates/numbers, and full-text search for analyzed fields.",
            "dependencies": [
              4
            ],
            "details": "Create backend/scripts/verify_index.py with: 1) Term query tests: search phase=PHASE2, overall_status=NOT_YET_RECRUITING, nct_id exact match. 2) Nested query tests: find trials by sponsor name (AstraZeneca), filter by facility country (United States), search design_outcomes by outcome_type=primary. 3) Range query tests: filter by enrollment >= 100, date range query for start_date. 4) Full-text search tests: multi_match query on brief_title and official_title, search brief_summaries_description for medical terms. 5) Autocomplete test: search_as_you_type query on brief_title.suggest. 6) Aggregation test: get counts by phase, status distribution. Each test should print expected vs actual results and pass/fail status. Exit with non-zero code if any test fails.",
            "status": "done",
            "testStrategy": "Run verify_index.py after successful ingestion. All 6 query type tests should pass. Verify aggregations return expected phase distribution. Test should complete within 5 seconds. Manual spot-check results against raw JSON data to confirm accuracy.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:21:52.651Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down ES setup into: 1) Create create_index.py with complete field mapping including keyword fields (phase, overall_status, nct_id), text fields with clinical_analyzer, and search_as_you_type sub-fields for titles, 2) Define nested mappings for sponsors, facilities, design_outcomes, and age arrays with proper field types, 3) Implement ingest.py with document transformation (enrollment string-to-int, null handling, date parsing), 4) Add bulk indexing using elasticsearch-py helpers with error handling and progress reporting, 5) Create verification script with sample queries for each field type (term, nested, range). Each subtask should handle edge cases in the data.",
        "updatedAt": "2026-02-07T18:21:52.651Z"
      },
      {
        "id": 4,
        "title": "Claude API LLM Service for Entity Extraction",
        "description": "Implement the LLM service using Claude API (anthropic SDK) to extract structured entities from natural language queries, including domain synonym handling and clarification detection.",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "details": "1. Create `backend/app/services/llm_service.py`:\n   ```python\n   import anthropic\n   import json\n   from typing import Optional\n   from ..config import get_settings\n   from ..models.entities import ExtractedEntities, LocationFilter\n\n   SYSTEM_PROMPT = '''You are a clinical trials search assistant. Extract structured filters from natural language queries about clinical trials.\n\n   Available fields to extract:\n   - phase: One of NA, PHASE1, PHASE1/PHASE2, PHASE2, PHASE2/PHASE3, PHASE3, PHASE4, Phase NA\n   - condition: The medical condition or disease (e.g., \"Breast Cancer\", \"Diabetes\", \"Asthma\")\n   - status: One of ACTIVE_NOT_RECRUITING, COMPLETED, NOT_YET_RECRUITING, RECRUITING, SUSPENDED, TERMINATED, UNKNOWN, WITHDRAWN\n   - location: Object with city, state, and/or country fields\n   - sponsor: Organization name (e.g., \"AstraZeneca\", \"Pfizer\")\n   - keyword: Specific terms like gene names (BRCA1, EGFR), drug names, or technical terms\n   - age_group: One of \"adult\", \"older-adults\", \"child\", \"adolescent\", \"infant\", \"toddler\"\n   - enrollment_min: Minimum number of participants\n   - enrollment_max: Maximum number of participants\n\n   Domain synonym mappings (translate these automatically):\n   - \"open\", \"recruiting\", \"active\", \"enrolling\" -> status: RECRUITING\n   - \"closed\", \"finished\", \"completed\", \"done\" -> status: COMPLETED\n   - \"upcoming\", \"not started\", \"planned\" -> status: NOT_YET_RECRUITING\n   - \"running\", \"ongoing\" -> status: RECRUITING or ACTIVE_NOT_RECRUITING\n   - \"paused\", \"halted\" -> status: SUSPENDED\n   - \"stopped\", \"ended early\" -> status: TERMINATED\n   - \"phase 1\", \"phase I\", \"P1\" -> phase: PHASE1\n   - \"phase 1/2\", \"phase I/II\" -> phase: PHASE1/PHASE2\n   - \"phase 2\", \"phase II\", \"P2\" -> phase: PHASE2\n   - \"phase 2/3\", \"phase II/III\" -> phase: PHASE2/PHASE3\n   - \"phase 3\", \"phase III\", \"P3\" -> phase: PHASE3\n   - \"phase 4\", \"phase IV\", \"P4\" -> phase: PHASE4\n   - \"USA\", \"US\", \"United States\", \"America\" -> location.country: \"United States\"\n   - \"large trials\", \"big studies\" -> enrollment_min: 500\n   - \"pediatric\", \"children\", \"kids\" -> age_group: child\n   - \"elderly\", \"seniors\" -> age_group: older-adults\n   - \"teens\", \"teenagers\" -> age_group: adolescent\n   - \"babies\" -> age_group: infant\n\n   Output JSON format:\n   {\n     \"phase\": \"PHASE2\" or null,\n     \"condition\": \"disease name\" or null,\n     \"status\": \"RECRUITING\" or null,\n     \"location\": {\"city\": \"\", \"state\": \"\", \"country\": \"\"} or null,\n     \"sponsor\": \"company name\" or null,\n     \"keyword\": \"gene/drug name\" or null,\n     \"age_group\": \"adult\" or null,\n     \"enrollment_min\": 500 or null,\n     \"enrollment_max\": null,\n     \"confidence\": 0.0-1.0,\n     \"clarification\": \"question to ask user\" or null\n   }\n\n   Rules:\n   1. Only extract entities that are clearly stated or strongly implied\n   2. Set confidence based on how clear the query is (1.0 = very clear, 0.5 = ambiguous)\n   3. If the query is ambiguous, misspelled, or too broad, set clarification with a helpful question\n   4. Return null for fields not mentioned in the query\n   5. Always respond with valid JSON only, no explanations'''\n\n   async def extract_entities(query: str) -> ExtractedEntities:\n       \"\"\"Extract structured entities from natural language query using Claude API\"\"\"\n       settings = get_settings()\n       client = anthropic.Anthropic(api_key=settings.anthropic_api_key)\n       \n       try:\n           message = client.messages.create(\n               model=\"claude-sonnet-4-20250514\",\n               max_tokens=1024,\n               system=SYSTEM_PROMPT,\n               messages=[\n                   {\"role\": \"user\", \"content\": f\"Extract entities from this clinical trials search query: \\\"{query}\\\"\"}\n               ]\n           )\n           \n           response_text = message.content[0].text\n           # Parse JSON response\n           data = json.loads(response_text)\n           \n           # Convert location dict to LocationFilter if present\n           if data.get('location'):\n               data['location'] = LocationFilter(**data['location'])\n           \n           return ExtractedEntities(**data)\n           \n       except json.JSONDecodeError:\n           # Fallback if LLM returns invalid JSON\n           return ExtractedEntities(\n               confidence=0.3,\n               clarification=\"I had trouble understanding your query. Could you rephrase it?\"\n           )\n       except Exception as e:\n           return ExtractedEntities(\n               confidence=0.0,\n               clarification=f\"An error occurred. Please try again.\"\n           )\n   ```\n\n2. Add domain constants in `backend/app/utils/synonyms.py` for reference (used in prompt):\n   ```python\n   STATUS_SYNONYMS = {\n       \"open\": \"RECRUITING\",\n       \"recruiting\": \"RECRUITING\",\n       \"closed\": \"COMPLETED\",\n       \"finished\": \"COMPLETED\",\n       \"upcoming\": \"NOT_YET_RECRUITING\",\n       \"running\": \"RECRUITING\",\n       \"paused\": \"SUSPENDED\",\n       \"halted\": \"SUSPENDED\",\n       \"stopped\": \"TERMINATED\",\n   }\n\n   PHASE_MAPPINGS = {\n       \"phase 1\": \"PHASE1\",\n       \"phase i\": \"PHASE1\",\n       \"phase 1/2\": \"PHASE1/PHASE2\",\n       \"phase i/ii\": \"PHASE1/PHASE2\",\n       \"phase 2\": \"PHASE2\",\n       \"phase ii\": \"PHASE2\",\n       \"phase 2/3\": \"PHASE2/PHASE3\",\n       \"phase ii/iii\": \"PHASE2/PHASE3\",\n       \"phase 3\": \"PHASE3\",\n       \"phase iii\": \"PHASE3\",\n       \"phase 4\": \"PHASE4\",\n       \"phase iv\": \"PHASE4\",\n   }\n\n   AGE_GROUP_SYNONYMS = {\n       \"pediatric\": \"child\",\n       \"children\": \"child\",\n       \"kids\": \"child\",\n       \"elderly\": \"older-adults\",\n       \"seniors\": \"older-adults\",\n       \"teens\": \"adolescent\",\n       \"teenagers\": \"adolescent\",\n       \"babies\": \"infant\",\n   }\n   ```\n\n**IMPORTANT ENUM VALUES (from backend/app/models/entities.py):**\n- PhaseEnum: NA, PHASE1, PHASE1/PHASE2, PHASE2, PHASE2/PHASE3, PHASE3, PHASE4, Phase NA (8 values)\n- StatusEnum: ACTIVE_NOT_RECRUITING, COMPLETED, NOT_YET_RECRUITING, RECRUITING, SUSPENDED, TERMINATED, UNKNOWN, WITHDRAWN (8 values)\n- AgeCategoryEnum: adult, older-adults, child, adolescent, infant, toddler (6 values)",
        "testStrategy": "1. Test with various query types:\n   - \"Phase 3 lung cancer trials in the USA\" -> should extract phase=PHASE3, condition=lung cancer, location.country=United States\n   - \"recruiting diabetes trials\" -> status=RECRUITING, condition=diabetes\n   - \"open melanoma trials\" -> status=RECRUITING (synonym), condition=melanoma\n   - \"List all Phase 2 trials for Breast Cancer associated with BRCA1\" -> phase=PHASE2, condition=Breast Cancer, keyword=BRCA1\n   - \"Phase 1/2 studies\" -> phase=PHASE1/PHASE2 (combined phase)\n   - \"pediatric asthma trials\" -> age_group=child (synonym), condition=asthma\n   - \"paused cancer studies\" -> status=SUSPENDED (synonym)\n2. Test confidence scoring with clear vs ambiguous queries\n3. Test clarification generation for misspelled conditions\n4. Test edge cases: empty query, gibberish input, only stop words\n5. Verify JSON parsing error handling\n6. Verify all 8 phase values, 8 status values, and 6 age categories are handled correctly",
        "subtasks": [
          {
            "id": 1,
            "title": "Create LLM Service Module with Claude API Client Setup",
            "description": "Create the backend/app/services/llm_service.py module with anthropic SDK client initialization, async patterns, and configuration integration using the Pydantic Settings from config.py.",
            "dependencies": [],
            "details": "Create the llm_service.py file with proper imports (anthropic, json, typing). Initialize the Anthropic client using settings.anthropic_api_key from get_settings(). Implement the async extract_entities() function signature that accepts a query string and returns ExtractedEntities. Use proper async/await patterns for non-blocking I/O. Handle client initialization failures gracefully with appropriate error logging. Ensure the client is created fresh per request or use connection pooling best practices for the anthropic SDK.",
            "status": "done",
            "testStrategy": "Test client initialization with valid API key from environment. Verify get_settings() is called correctly. Test that missing API key raises appropriate error. Mock the anthropic client to verify proper instantiation parameters. Test async function signature is properly awaitable.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:42:51.931Z"
          },
          {
            "id": 2,
            "title": "Design Comprehensive System Prompt with Correct Field Definitions and JSON Schema",
            "description": "Create the SYSTEM_PROMPT constant with complete field definitions for all extractable entities using the CORRECT enum values from backend/app/models/entities.py: phase (8 values including combined phases), status (8 values including UNKNOWN), age_group (6 values), and expected JSON output schema.",
            "dependencies": [
              1
            ],
            "details": "Define the SYSTEM_PROMPT as a multi-line string with: 1) Role definition as clinical trials search assistant, 2) Complete list of extractable fields with their types and valid enum values:\n   - Phase: NA, PHASE1, PHASE1/PHASE2, PHASE2, PHASE2/PHASE3, PHASE3, PHASE4, Phase NA (NOTE: EARLY_PHASE1 does NOT exist)\n   - Status: ACTIVE_NOT_RECRUITING, COMPLETED, NOT_YET_RECRUITING, RECRUITING, SUSPENDED, TERMINATED, UNKNOWN, WITHDRAWN (NOTE: UNKNOWN is included)\n   - Age categories: adult, older-adults, child, adolescent, infant, toddler\n3) LocationFilter structure with city/state/country fields, 4) Confidence scoring rules (1.0 = very clear, 0.5 = ambiguous, lower for unclear), 5) JSON output schema with all fields including optional clarification field, 6) Clear rules about only extracting clearly stated entities and returning null for unmentioned fields. Include example output format in the prompt.",
            "status": "done",
            "testStrategy": "Verify prompt is valid string with no syntax errors. Manually test prompt with Claude API playground to ensure it produces valid JSON. Verify all enum values match the ExtractedEntities model in backend/app/models/entities.py. Test prompt with combined phases like 'phase 1/2' to ensure PHASE1/PHASE2 is returned. Test that UNKNOWN status and all 6 age categories are recognized.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:42:51.944Z"
          },
          {
            "id": 3,
            "title": "Implement Domain Synonym Mappings in System Prompt",
            "description": "Add comprehensive domain synonym mappings to the system prompt including status synonyms (open->RECRUITING, paused->SUSPENDED), phase variations including combined phases (phase I/II->PHASE1/PHASE2), location normalizations, age group synonyms (pediatric->child, elderly->older-adults), and enrollment interpretations.",
            "dependencies": [
              2
            ],
            "details": "Extend SYSTEM_PROMPT with detailed synonym mappings section: 1) Status synonyms: open/recruiting/active/enrolling->RECRUITING, closed/finished/completed/done->COMPLETED, upcoming/not started/planned->NOT_YET_RECRUITING, running/ongoing->RECRUITING or ACTIVE_NOT_RECRUITING, paused/halted->SUSPENDED, stopped/ended early->TERMINATED, 2) Phase mappings including combined phases: phase 1/phase I/P1->PHASE1, phase 1/2/phase I/II->PHASE1/PHASE2, phase 2/phase II/P2->PHASE2, phase 2/3/phase II/III->PHASE2/PHASE3, phase 3/phase III/P3->PHASE3, phase 4/phase IV/P4->PHASE4, 3) Location normalization: USA/US/United States/America->location.country: United States, UK/Britain/England->United Kingdom, 4) Age group synonyms: pediatric/children/kids->child, elderly/seniors->older-adults, teens/teenagers->adolescent, babies->infant, 5) Enrollment interpretations: large trials/big studies->enrollment_min: 500, small studies->enrollment_max: 100. Also create backend/app/utils/synonyms.py with STATUS_SYNONYMS, PHASE_MAPPINGS, and AGE_GROUP_SYNONYMS dictionaries for reference and potential server-side validation.",
            "status": "done",
            "testStrategy": "Test each synonym category with sample queries: 'open cancer trials' should map to status=RECRUITING, 'phase I/II studies' to phase=PHASE1/PHASE2, 'trials in the US' to location.country='United States', 'pediatric trials' to age_group=child, 'paused studies' to status=SUSPENDED. Verify both common and edge case synonyms work correctly. Test that original enum values still work (RECRUITING should still work directly).",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:42:51.953Z"
          },
          {
            "id": 4,
            "title": "Add Clarification Detection Logic for Ambiguous Queries",
            "description": "Implement clarification detection within the system prompt for ambiguous, misspelled, overly broad, or gibberish queries, including confidence scoring logic and helpful clarification question generation.",
            "dependencies": [
              2,
              3
            ],
            "details": "Enhance SYSTEM_PROMPT with clarification rules: 1) Set confidence based on query clarity (1.0 = all terms recognized and unambiguous, 0.7-0.9 = mostly clear with minor uncertainty, 0.5-0.7 = some ambiguity, below 0.5 = significant issues), 2) Trigger clarification for: misspelled medical terms that can't be auto-corrected, overly broad queries like just 'trials' or 'medicine', gibberish or unrelated queries, conflicting filters (e.g., completed AND recruiting), 3) Generate helpful clarification questions: 'Did you mean [suggestion]?', 'Which condition are you interested in?', 'Could you specify a phase or status?', 4) Handle edge cases: empty queries, single-word queries, queries with only stop words. The clarification field should be null when query is clear enough (confidence >= 0.7).",
            "status": "done",
            "testStrategy": "Test with ambiguous queries: 'trials' should return low confidence with clarification asking for condition. Test misspellings: 'diabeties' should still extract diabetes with slight confidence reduction. Test gibberish: 'asdfasdf' should return confidence near 0 with clarification. Test conflicting: 'completed recruiting trials' should ask for clarification. Verify clear queries have null clarification.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:42:51.955Z"
          },
          {
            "id": 5,
            "title": "Implement JSON Response Parsing with Robust Error Handling",
            "description": "Implement the complete extract_entities() function with Claude API message creation, JSON response parsing, LocationFilter conversion, and comprehensive error handling for malformed LLM output, API failures, and edge cases.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Complete the extract_entities() async function: 1) Call client.messages.create() with model='claude-sonnet-4-20250514', max_tokens=1024, system=SYSTEM_PROMPT, and user message with query, 2) Extract response text from message.content[0].text, 3) Parse JSON with json.loads() wrapped in try/except, 4) Convert location dict to LocationFilter object if present, 5) Construct and return ExtractedEntities using **data unpacking, 6) Handle JSONDecodeError with fallback ExtractedEntities(confidence=0.3, clarification='I had trouble understanding your query...'), 7) Handle anthropic.APIError with appropriate fallback and logging, 8) Handle unexpected exceptions with generic fallback, 9) Add input validation for empty/whitespace-only queries returning immediate fallback. Consider using regex to extract JSON from response if LLM includes extra text.",
            "status": "done",
            "testStrategy": "Test successful parsing with mock valid JSON response. Test JSONDecodeError handling by mocking malformed response. Test API error handling by mocking anthropic.APIError. Test empty query returns appropriate fallback. Test location dict conversion to LocationFilter. Verify all ExtractedEntities fields are properly populated. Test response with extra text around JSON is handled gracefully.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:42:51.958Z"
          },
          {
            "id": 6,
            "title": "Create Unit Tests with Diverse Query Types",
            "description": "Create comprehensive unit tests in backend/tests/test_llm_service.py covering simple queries, complex multi-filter queries, ambiguous queries, misspelled queries, gibberish input, combined phases, all age categories, and edge cases with proper mocking of the Claude API.",
            "dependencies": [
              5
            ],
            "details": "Create test file with pytest fixtures for mocking anthropic client. Test categories: 1) Simple queries: 'Phase 3 cancer trials' -> phase=PHASE3, condition=cancer; 'recruiting diabetes studies' -> status=RECRUITING, condition=diabetes, 2) Combined phase queries: 'phase 1/2 trials' -> phase=PHASE1/PHASE2; 'phase 2/3 studies' -> phase=PHASE2/PHASE3, 3) Complex queries: 'Phase 2 lung cancer trials in California sponsored by Pfizer' -> all fields extracted correctly, 4) Synonym handling: 'open melanoma trials' -> status=RECRUITING; 'P1 studies' -> phase=PHASE1; 'pediatric asthma' -> age_group=child; 'paused studies' -> status=SUSPENDED, 5) Age category tests: test all 6 values (adult, older-adults, child, adolescent, infant, toddler), 6) Ambiguous queries: 'trials' -> low confidence, has clarification; 'medicine studies' -> asks for specifics, 7) Misspellings: 'diabeties trials' -> still extracts diabetes with confidence < 1.0, 8) Gibberish: 'asdfghjkl' -> confidence near 0, has clarification, 9) Edge cases: empty string, whitespace only, very long query, SQL injection attempt, 10) Error handling: test JSONDecodeError fallback, API error fallback. Use unittest.mock.patch or pytest-mock to mock anthropic.Anthropic client.",
            "status": "done",
            "testStrategy": "Run pytest with coverage to ensure >90% code coverage on llm_service.py. Verify all test cases pass. Test isolation by ensuring no actual API calls are made (all mocked). Verify fixtures properly reset between tests. Run tests multiple times to ensure deterministic behavior. Check test execution time is under 5 seconds (no real API calls). Specifically verify tests cover all 8 phase values, 8 status values, and 6 age categories.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:42:51.964Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down LLM service into: 1) Create llm_service.py with Claude API client setup using anthropic SDK and proper async patterns, 2) Design comprehensive system prompt with field definitions, valid enum values, and expected JSON output schema, 3) Implement domain synonym mappings within the prompt (open->RECRUITING, phase variations, country normalizations), 4) Add clarification detection logic for ambiguous/misspelled/broad queries with confidence scoring, 5) Implement JSON response parsing with error handling for malformed LLM output, 6) Create unit tests with diverse query types (simple, complex, ambiguous, gibberish). Each subtask should handle edge cases and fallback scenarios.",
        "updatedAt": "2026-02-07T18:42:51.964Z"
      },
      {
        "id": 5,
        "title": "Elasticsearch Query Builder Service",
        "description": "Implement the service that converts extracted entities into optimized Elasticsearch Query DSL with proper handling of nested fields, term queries, and multi-match searches.",
        "status": "done",
        "dependencies": [
          "3",
          "4"
        ],
        "priority": "high",
        "details": "1. Create `backend/app/services/es_service.py`:\n   ```python\n   from elasticsearch import Elasticsearch\n   from typing import Optional, Dict, Any, List\n   from ..config import get_settings\n   from ..models.entities import ExtractedEntities\n   from ..models.schemas import TrialResult, Sponsor, Facility, AgeCategory\n\n   class ElasticsearchService:\n       def __init__(self):\n           settings = get_settings()\n           self.es = Elasticsearch([settings.es_url])\n           self.index = settings.es_index\n\n       def build_query(self, entities: ExtractedEntities) -> Dict[str, Any]:\n           \"\"\"Build Elasticsearch query DSL from extracted entities\"\"\"\n           must_clauses = []\n           filter_clauses = []\n           should_clauses = []\n\n           # Phase - exact match filter\n           if entities.phase:\n               filter_clauses.append({\"term\": {\"phase\": entities.phase}})\n\n           # Status - exact match filter\n           if entities.status:\n               filter_clauses.append({\"term\": {\"overall_status\": entities.status}})\n\n           # Condition - text match across title and description\n           if entities.condition:\n               must_clauses.append({\n                   \"multi_match\": {\n                       \"query\": entities.condition,\n                       \"fields\": [\"brief_title^3\", \"official_title^2\", \"brief_summaries_description\"],\n                       \"type\": \"best_fields\",\n                       \"fuzziness\": \"AUTO\"\n                   }\n               })\n\n           # Location - nested query on facilities\n           if entities.location:\n               location_filters = []\n               if entities.location.country:\n                   location_filters.append({\"term\": {\"facilities.country\": entities.location.country}})\n               if entities.location.state:\n                   location_filters.append({\"term\": {\"facilities.state\": entities.location.state}})\n               if entities.location.city:\n                   location_filters.append({\"term\": {\"facilities.city\": entities.location.city}})\n               \n               if location_filters:\n                   filter_clauses.append({\n                       \"nested\": {\n                           \"path\": \"facilities\",\n                           \"query\": {\"bool\": {\"must\": location_filters}}\n                       }\n                   })\n\n           # Sponsor - nested query\n           if entities.sponsor:\n               filter_clauses.append({\n                   \"nested\": {\n                       \"path\": \"sponsors\",\n                       \"query\": {\n                           \"match\": {\"sponsors.name\": entities.sponsor}\n                       }\n                   }\n               })\n\n           # Keyword/Gene - multi-match across all text fields\n           if entities.keyword:\n               must_clauses.append({\n                   \"multi_match\": {\n                       \"query\": entities.keyword,\n                       \"fields\": [\n                           \"brief_title^2\",\n                           \"official_title^2\",\n                           \"brief_summaries_description\",\n                           \"detailed_description\"\n                       ],\n                       \"type\": \"phrase_prefix\"\n                   }\n               })\n\n           # Age group - nested query on age array\n           if entities.age_group:\n               filter_clauses.append({\n                   \"nested\": {\n                       \"path\": \"age\",\n                       \"query\": {\"term\": {\"age.age_category\": entities.age_group}}\n                   }\n               })\n\n           # Enrollment range\n           if entities.enrollment_min or entities.enrollment_max:\n               range_query = {}\n               if entities.enrollment_min:\n                   range_query[\"gte\"] = entities.enrollment_min\n               if entities.enrollment_max:\n                   range_query[\"lte\"] = entities.enrollment_max\n               filter_clauses.append({\"range\": {\"enrollment\": range_query}})\n\n           # Build final query\n           query = {\"bool\": {}}\n           if must_clauses:\n               query[\"bool\"][\"must\"] = must_clauses\n           if filter_clauses:\n               query[\"bool\"][\"filter\"] = filter_clauses\n           if should_clauses:\n               query[\"bool\"][\"should\"] = should_clauses\n\n           # If no clauses, match all\n           if not must_clauses and not filter_clauses:\n               query = {\"match_all\": {}}\n\n           return query\n\n       async def search(self, entities: ExtractedEntities, page: int = 1, page_size: int = 10) -> tuple[List[TrialResult], int]:\n           \"\"\"Execute search and return results with total count\"\"\"\n           query = self.build_query(entities)\n           \n           response = self.es.search(\n               index=self.index,\n               body={\n                   \"query\": query,\n                   \"from\": (page - 1) * page_size,\n                   \"size\": page_size,\n                   \"sort\": [{\"_score\": \"desc\"}, {\"enrollment\": \"desc\"}],\n                   \"_source\": [\n                       \"nct_id\", \"brief_title\", \"official_title\", \"phase\",\n                       \"overall_status\", \"enrollment\", \"sponsors\", \"facilities\",\n                       \"conditions\", \"brief_summaries_description\", \"start_date\",\n                       \"completion_date\", \"age\", \"gender\", \"study_type\", \"source\"\n                   ]\n               }\n           )\n           \n           results = []\n           for hit in response[\"hits\"][\"hits\"]:\n               source = hit[\"_source\"]\n               results.append(TrialResult(\n                   nct_id=source[\"nct_id\"],\n                   brief_title=source[\"brief_title\"],\n                   official_title=source.get(\"official_title\"),\n                   phase=source.get(\"phase\"),\n                   overall_status=source.get(\"overall_status\"),\n                   enrollment=source.get(\"enrollment\"),\n                   sponsors=[Sponsor(**s) for s in source.get(\"sponsors\", [])],\n                   facilities=[Facility(**f) for f in source.get(\"facilities\", [])[:3]],\n                   conditions=source.get(\"conditions\", []),\n                   brief_summaries_description=source.get(\"brief_summaries_description\"),\n                   start_date=source.get(\"start_date\"),\n                   completion_date=source.get(\"completion_date\"),\n                   age=[AgeCategory(**a) for a in source.get(\"age\", [])],\n                   gender=source.get(\"gender\"),\n                   study_type=source.get(\"study_type\"),\n                   source=source.get(\"source\")\n               ))\n           \n           total = response[\"hits\"][\"total\"][\"value\"]\n           return results, total\n\n   es_service = ElasticsearchService()\n   ```\n\n**IMPORTANT UPDATES from Task 2:**\n- Import `AgeCategory` from `app.models.schemas` (along with TrialResult, Sponsor, Facility)\n- The `_source` list must include: `conditions`, `completion_date`, `gender`, `study_type`, `source`\n- Map `age` field using `AgeCategory` model objects: `age=[AgeCategory(**a) for a in source.get(\"age\", [])]`\n- Map `conditions` field directly as List[Dict[str, str]]: `conditions=source.get(\"conditions\", [])`\n- Facility model already supports `zip` and `status` fields via `**f` unpacking",
        "testStrategy": "1. Unit test query building with mock entities:\n   - Phase only -> term filter\n   - Condition only -> multi_match\n   - Location with nested query\n   - Combined filters\n2. Integration test against live ES:\n   - Search for \"Phase 2 Asthma\" and verify relevant results\n   - Verify pagination works correctly\n   - Test enrollment range queries\n3. Verify nested query syntax for facilities, sponsors, and age\n4. Test empty entities returns match_all query\n5. Benchmark query performance on full dataset\n6. **NEW**: Verify result mapping includes all new fields (conditions, completion_date, gender, study_type, source)\n7. **NEW**: Verify age field is mapped to List[AgeCategory] objects, not raw dicts\n8. **NEW**: Verify Facility objects include zip and status fields when present in ES response",
        "subtasks": [
          {
            "id": 1,
            "title": "Create es_service.py with Elasticsearch Client Initialization",
            "description": "Set up the ElasticsearchService class with proper client initialization, connection handling, and configuration loading from settings.",
            "dependencies": [],
            "details": "Create `backend/app/services/es_service.py` with the ElasticsearchService class. Initialize the Elasticsearch client using settings from `get_settings()` including `es_url` and `es_index`. Implement proper imports for Elasticsearch, typing modules, config, and model dependencies. **UPDATED IMPORTS**: Import ExtractedEntities from `app.models.entities`, and import TrialResult, Sponsor, Facility, AgeCategory from `app.models.schemas`. Add connection error handling and ensure the service can gracefully handle connection failures. Create a module-level singleton instance `es_service = ElasticsearchService()` for dependency injection.",
            "status": "done",
            "testStrategy": "Test client initialization with valid and invalid ES URLs. Verify connection handling by mocking Elasticsearch client. Test that settings are properly loaded and applied to the client configuration. Verify all required imports are available.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:53:51.232Z"
          },
          {
            "id": 2,
            "title": "Implement build_query Method with Bool Query Construction",
            "description": "Create the core build_query method that constructs Elasticsearch bool queries with must, filter, and should clause arrays.",
            "dependencies": [
              1
            ],
            "details": "Implement `build_query(self, entities: ExtractedEntities) -> Dict[str, Any]` method that initializes empty lists for must_clauses, filter_clauses, and should_clauses. Build the final bool query structure by conditionally adding these arrays to the query dict only when they contain clauses. Handle the edge case where no entities are provided by returning a `match_all` query. Ensure proper typing with Dict[str, Any] return type. The method should gracefully handle None/missing values for all entity fields.",
            "status": "done",
            "testStrategy": "Unit test with empty ExtractedEntities returns match_all query. Test that bool query structure is correctly formed with various clause combinations. Verify None values don't cause errors.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:53:51.257Z"
          },
          {
            "id": 3,
            "title": "Add Query Clause Builders for Simple Entity Types",
            "description": "Implement query clause builders for phase, status (term filters), condition/keyword (multi_match), and enrollment (range queries).",
            "dependencies": [
              2
            ],
            "details": "Within build_query, add clause builders: 1) Phase - term filter on 'phase' field added to filter_clauses, 2) Status - term filter on 'overall_status' field, 3) Condition - multi_match query on brief_title^3, official_title^2, brief_summaries_description with type='best_fields' and fuzziness='AUTO' added to must_clauses, 4) Keyword - multi_match with phrase_prefix type on title and description fields, 5) Enrollment range - range query with optional gte/lte bounds based on enrollment_min/enrollment_max. Each builder should check for None before adding clauses.",
            "status": "done",
            "testStrategy": "Test each clause builder independently: phase='PHASE2' produces correct term filter, condition='asthma' produces multi_match with boosted fields, enrollment range with min-only, max-only, and both bounds. Verify query structure matches expected Elasticsearch DSL format.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:53:51.260Z"
          },
          {
            "id": 4,
            "title": "Implement Nested Queries for Location, Sponsor, and Age Group",
            "description": "Create nested query builders for facilities (location), sponsors, and age arrays with proper path handling.",
            "dependencies": [
              2
            ],
            "details": "Implement nested queries: 1) Location - build nested query on 'facilities' path with bool/must containing term filters for country, state, city (only include filters for non-None values), 2) Sponsor - nested query on 'sponsors' path with match query on 'sponsors.name', 3) Age group - nested query on 'age' path with term filter on 'age.age_category'. Each nested query must specify the correct path and handle partial data (e.g., location with only country specified). Add location_filters list construction that only includes non-None location components.",
            "status": "done",
            "testStrategy": "Test location nested query with all combinations: country-only, state+country, city+state+country. Test sponsor nested query produces correct path and match structure. Test age_group nested query. Verify nested query structure matches ES nested query requirements.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:53:51.263Z"
          },
          {
            "id": 5,
            "title": "Create Search Method with Pagination and Updated Result Mapping",
            "description": "Implement the async search method with pagination, sorting, _source field selection including new fields (conditions, completion_date, gender, study_type, source), and result mapping to TrialResult models with AgeCategory objects.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement `async def search(self, entities: ExtractedEntities, page: int = 1, page_size: int = 10) -> tuple[List[TrialResult], int]`. Calculate 'from' offset as (page-1)*page_size. Execute search with: query from build_query, from/size for pagination, sort by _score desc then enrollment desc, _source limited to required fields. **UPDATED _source list**: nct_id, brief_title, official_title, phase, overall_status, enrollment, sponsors, facilities, conditions, brief_summaries_description, start_date, completion_date, age, gender, study_type, source. Map response hits to TrialResult objects with **UPDATED mapping**: sponsors to Sponsor models, facilities limited to first 3 as Facility models (supports zip/status), conditions as List[Dict[str, str]], **age mapped to List[AgeCategory] using `[AgeCategory(**a) for a in source.get(\"age\", [])]`**, completion_date, gender, study_type, source as Optional[str]. Return tuple of results list and total count from response['hits']['total']['value'].",
            "status": "done",
            "testStrategy": "Test pagination calculates correct from/size values. Mock ES response and verify result mapping to TrialResult is correct including all new fields. Test age field is mapped to AgeCategory objects (not raw dicts). Test conditions field is properly mapped as List[Dict[str, str]]. Test facilities are limited to 3 and include zip/status when present. Test empty response returns empty list with 0 total. Verify sorting parameters are correctly applied.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:53:51.267Z"
          },
          {
            "id": 6,
            "title": "Add Unit Tests for Query DSL Output and Updated Result Mapping",
            "description": "Create comprehensive unit tests for query building with various entity combinations, edge cases, and updated result mapping including new fields.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Create `backend/tests/test_es_service.py` with unit tests covering: 1) Empty entities -> match_all, 2) Single field extraction (phase only, condition only, location only), 3) Multiple combined fields, 4) All nested query types (location with partial data, sponsor, age_group), 5) Range queries with min-only, max-only, both bounds, 6) Verify multi_match field boosting and fuzziness settings, 7) Test search method pagination offset calculation, 8) Test result mapping with mock ES responses including **new fields**: conditions (List[Dict[str, str]]), completion_date, gender, study_type, source, 9) **NEW**: Verify age field maps to List[AgeCategory] objects not raw dicts, 10) **NEW**: Verify Facility mapping supports zip and status fields, 11) **NEW**: Test with ES responses containing partial data (some fields missing). Use pytest fixtures for ExtractedEntities with various configurations. Mock Elasticsearch client for search tests.",
            "status": "done",
            "testStrategy": "Run pytest on test_es_service.py. Verify 100% coverage of build_query paths. Test each query type produces valid Elasticsearch DSL that can be validated against ES query structure. Verify all TrialResult fields are correctly typed (especially age as List[AgeCategory]). Integration test against local ES instance if available.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T18:53:51.270Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down ES query builder into: 1) Create es_service.py with Elasticsearch client initialization and connection handling, 2) Implement build_query method with bool query construction (must/filter/should clauses), 3) Add query clause builders for each entity type: term filters for phase/status, multi_match for condition/keyword, range for enrollment, 4) Implement nested queries for location (facilities), sponsor, and age_group with proper path handling, 5) Create search method with pagination, sorting, and _source field selection, 6) Add unit tests for query DSL output with various entity combinations. Each subtask should handle null/missing entity values gracefully.",
        "updatedAt": "2026-02-07T18:53:51.270Z"
      },
      {
        "id": 6,
        "title": "Auto-Suggestion Service Implementation",
        "description": "Implement the suggestion service using Elasticsearch search_as_you_type fields to provide type-ahead suggestions as users type their queries.",
        "details": "1. Create `backend/app/services/suggestion.py`:\n   ```python\n   from elasticsearch import Elasticsearch\n   from typing import List\n   from ..config import get_settings\n\n   class SuggestionService:\n       def __init__(self):\n           settings = get_settings()\n           self.es = Elasticsearch([settings.es_url])\n           self.index = settings.es_index\n\n       async def get_suggestions(self, prefix: str, limit: int = 10) -> List[str]:\n           \"\"\"Get type-ahead suggestions using search_as_you_type\"\"\"\n           if not prefix or len(prefix) < 2:\n               return []\n\n           response = self.es.search(\n               index=self.index,\n               body={\n                   \"size\": 0,\n                   \"query\": {\n                       \"bool\": {\n                           \"should\": [\n                               {\n                                   \"multi_match\": {\n                                       \"query\": prefix,\n                                       \"type\": \"bool_prefix\",\n                                       \"fields\": [\n                                           \"brief_title.suggest\",\n                                           \"brief_title.suggest._2gram\",\n                                           \"brief_title.suggest._3gram\"\n                                       ]\n                                   }\n                               }\n                           ]\n                       }\n                   },\n                   \"aggs\": {\n                       \"unique_conditions\": {\n                           \"terms\": {\n                               \"field\": \"phase\",\n                               \"size\": 5\n                           }\n                       },\n                       \"title_suggestions\": {\n                           \"significant_text\": {\n                               \"field\": \"brief_title\",\n                               \"filter_duplicate_text\": True,\n                               \"size\": limit\n                           }\n                       }\n                   }\n               }\n           )\n\n           # Extract suggestions from aggregations\n           suggestions = []\n           \n           # Get significant terms from titles\n           if \"aggregations\" in response:\n               sig_terms = response[\"aggregations\"].get(\"title_suggestions\", {}).get(\"buckets\", [])\n               for bucket in sig_terms:\n                   suggestions.append(bucket[\"key\"])\n\n           # Fallback: simple prefix search on titles\n           if not suggestions:\n               prefix_response = self.es.search(\n                   index=self.index,\n                   body={\n                       \"size\": limit,\n                       \"query\": {\n                           \"multi_match\": {\n                               \"query\": prefix,\n                               \"type\": \"phrase_prefix\",\n                               \"fields\": [\"brief_title\", \"official_title\"]\n                           }\n                       },\n                       \"_source\": [\"brief_title\"]\n                   }\n               )\n               \n               seen = set()\n               for hit in prefix_response[\"hits\"][\"hits\"]:\n                   title = hit[\"_source\"].get(\"brief_title\", \"\")\n                   # Extract first few words as suggestion\n                   words = title.split()[:6]\n                   suggestion = \" \".join(words)\n                   if suggestion.lower() not in seen:\n                       seen.add(suggestion.lower())\n                       suggestions.append(suggestion)\n\n           return suggestions[:limit]\n\n   suggestion_service = SuggestionService()\n   ```\n\n2. Enhance for condition-specific suggestions:\n   ```python\n   async def get_condition_suggestions(self, prefix: str) -> List[str]:\n       \"\"\"Get common condition names matching prefix\"\"\"\n       # Pre-defined common conditions for fast suggestions\n       common_conditions = [\n           \"Breast Cancer\", \"Lung Cancer\", \"Diabetes\", \"Asthma\",\n           \"COVID-19\", \"Heart Disease\", \"Alzheimer's\", \"Melanoma\",\n           \"Leukemia\", \"Rheumatoid Arthritis\", \"Multiple Sclerosis\"\n       ]\n       \n       matching = [c for c in common_conditions \n                   if c.lower().startswith(prefix.lower())]\n       return matching[:5]\n   ```",
        "testStrategy": "1. Test with various prefixes: \"can\" -> Cancer suggestions, \"dia\" -> Diabetes\n2. Verify minimum character requirement (2 chars)\n3. Test response time is under 100ms for type-ahead UX\n4. Verify deduplication of similar suggestions\n5. Test empty prefix returns empty list\n6. Integration test with frontend debounced input",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create suggestion.py with Elasticsearch client and index configuration",
            "description": "Set up the base SuggestionService class with Elasticsearch connection, index configuration, and core initialization logic including settings integration.",
            "dependencies": [],
            "details": "Create `backend/app/services/suggestion.py` with the SuggestionService class. Initialize Elasticsearch client using settings from get_settings() (es_url and es_index). Include proper imports for elasticsearch, typing (List), and config module. Set up the singleton instance pattern with `suggestion_service = SuggestionService()`. Ensure the class follows the same patterns established in other services (es_service.py). Add minimum prefix length constant (MIN_PREFIX_LENGTH = 2) and default limit constant (DEFAULT_LIMIT = 10) for performance optimization.",
            "status": "done",
            "testStrategy": "Verify module imports correctly without errors. Test that SuggestionService initializes with valid Elasticsearch connection. Confirm settings are properly loaded from config. Test that the singleton instance is accessible from other modules.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:01:00.936Z"
          },
          {
            "id": 2,
            "title": "Implement get_suggestions method with search_as_you_type and bool_prefix multi_match",
            "description": "Implement the primary get_suggestions method using Elasticsearch search_as_you_type field type with bool_prefix multi_match query on brief_title.suggest fields including _2gram and _3gram analyzers.",
            "dependencies": [
              1
            ],
            "details": "Implement `async def get_suggestions(self, prefix: str, limit: int = 10) -> List[str]` method. Add early return for empty prefix or prefix < 2 characters to optimize performance. Build Elasticsearch query using multi_match with type='bool_prefix' targeting 'brief_title.suggest', 'brief_title.suggest._2gram', and 'brief_title.suggest._3gram' fields. Use aggregations with 'significant_text' on 'brief_title' field with filter_duplicate_text=True for deduplication. Set size=0 on main query since we only need aggregations. Extract suggestions from aggregations buckets. Apply limit parameter to final results.",
            "status": "done",
            "testStrategy": "Test with prefix 'can' returns Cancer-related suggestions. Test with prefix 'dia' returns Diabetes suggestions. Verify empty string returns empty list. Verify single character returns empty list. Test response time is under 100ms for acceptable type-ahead UX. Verify no duplicate suggestions in results.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:01:00.945Z"
          },
          {
            "id": 3,
            "title": "Add fallback logic with phrase_prefix query and title extraction",
            "description": "Implement fallback mechanism using phrase_prefix query when the primary search_as_you_type approach returns no results, including intelligent title word extraction and deduplication.",
            "dependencies": [
              1,
              2
            ],
            "details": "Extend get_suggestions method with fallback logic triggered when primary aggregation returns empty results. Implement secondary Elasticsearch query using multi_match with type='phrase_prefix' on 'brief_title' and 'official_title' fields. Set _source to only return 'brief_title' for performance. Extract first 6 words from matching titles as suggestion text. Implement case-insensitive deduplication using a seen set (convert to lowercase for comparison). Ensure fallback respects the same limit parameter. Add the fallback results to suggestions list only if primary approach yielded no results.",
            "status": "done",
            "testStrategy": "Test fallback triggers when primary query returns empty. Verify deduplication works (same title different case not duplicated). Test that fallback respects limit parameter. Verify extracted suggestions contain meaningful partial titles (first 6 words). Test edge cases like very short titles.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:01:00.949Z"
          },
          {
            "id": 4,
            "title": "Create get_condition_suggestions helper with common condition names",
            "description": "Implement a fast condition-specific suggestion helper method using a predefined list of common medical conditions for instant matching without Elasticsearch queries.",
            "dependencies": [
              1
            ],
            "details": "Implement `async def get_condition_suggestions(self, prefix: str) -> List[str]` method. Define a constant list of common clinical trial conditions: 'Breast Cancer', 'Lung Cancer', 'Diabetes', 'Asthma', 'COVID-19', 'Heart Disease', 'Alzheimer\\'s', 'Melanoma', 'Leukemia', 'Rheumatoid Arthritis', 'Multiple Sclerosis'. Use case-insensitive prefix matching with str.lower().startswith(). Return maximum 5 matching conditions for fast response. This provides instant suggestions without Elasticsearch latency for common conditions. Consider adding this list as a class constant for maintainability.",
            "status": "done",
            "testStrategy": "Test 'brea' returns 'Breast Cancer'. Test 'lung' returns 'Lung Cancer'. Test case insensitivity ('DIA' matches 'Diabetes'). Verify maximum 5 results returned. Test no matches returns empty list. Verify response time is near-instant (no ES query).",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:01:00.953Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down suggestion service into: 1) Create suggestion.py with ES client and index configuration, 2) Implement get_suggestions method using search_as_you_type with bool_prefix multi_match on title suggest fields, 3) Add fallback logic with phrase_prefix query and title extraction for when primary approach returns no results, 4) Create get_condition_suggestions helper with common condition names for fast matching. Each subtask should include deduplication and performance optimization (limit, minimum prefix length).",
        "updatedAt": "2026-02-07T19:01:00.953Z"
      },
      {
        "id": 7,
        "title": "FastAPI Search and Suggestion Endpoints",
        "description": "Implement the main FastAPI application with /search and /suggest endpoints, CORS configuration, error handling middleware, and proper dependency injection.",
        "details": "1. Create `backend/app/routers/search.py`:\n   ```python\n   from fastapi import APIRouter, Query, HTTPException\n   from typing import Optional\n   from ..services.llm_service import extract_entities\n   from ..services.es_service import es_service\n   from ..services.suggestion import suggestion_service\n   from ..models.schemas import SearchResponse, SuggestionResponse, ErrorResponse\n\n   router = APIRouter(prefix=\"/api\", tags=[\"search\"])\n\n   @router.get(\"/search/{query}\", response_model=SearchResponse)\n   async def search_trials(\n       query: str,\n       page: int = Query(default=1, ge=1),\n       page_size: int = Query(default=10, ge=1, le=100)\n   ):\n       \"\"\"Search clinical trials using natural language query\"\"\"\n       try:\n           # Extract entities using LLM\n           entities = await extract_entities(query)\n           \n           # Search Elasticsearch\n           results, total = await es_service.search(entities, page, page_size)\n           \n           return SearchResponse(\n               query_interpretation=entities,\n               results=results,\n               total=total,\n               page=page,\n               page_size=page_size,\n               clarification=entities.clarification\n           )\n       except Exception as e:\n           raise HTTPException(status_code=500, detail=str(e))\n\n   @router.get(\"/suggest\", response_model=SuggestionResponse)\n   async def get_suggestions(\n       q: str = Query(..., min_length=2, description=\"Partial query text\")\n   ):\n       \"\"\"Get type-ahead suggestions for partial query\"\"\"\n       try:\n           suggestions = await suggestion_service.get_suggestions(q)\n           return SuggestionResponse(suggestions=suggestions)\n       except Exception as e:\n           raise HTTPException(status_code=500, detail=str(e))\n   ```\n\n2. Create `backend/app/main.py`:\n   ```python\n   from fastapi import FastAPI, Request\n   from fastapi.middleware.cors import CORSMiddleware\n   from fastapi.responses import JSONResponse\n   from .routers import search\n   from .config import get_settings\n\n   app = FastAPI(\n       title=\"Clinical Trials Search API\",\n       description=\"Natural language search for clinical trials\",\n       version=\"1.0.0\"\n   )\n\n   # CORS middleware for frontend\n   app.add_middleware(\n       CORSMiddleware,\n       allow_origins=[\n           \"http://localhost:5173\",  # Vite dev server\n           \"http://localhost:3000\",\n           \"http://127.0.0.1:5173\"\n       ],\n       allow_credentials=True,\n       allow_methods=[\"*\"],\n       allow_headers=[\"*\"],\n   )\n\n   # Global exception handler\n   @app.exception_handler(Exception)\n   async def global_exception_handler(request: Request, exc: Exception):\n       return JSONResponse(\n           status_code=500,\n           content={\"error\": \"Internal server error\", \"detail\": str(exc)}\n       )\n\n   # Include routers\n   app.include_router(search.router)\n\n   @app.get(\"/health\")\n   async def health_check():\n       return {\"status\": \"healthy\"}\n\n   if __name__ == \"__main__\":\n       import uvicorn\n       uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n   ```\n\n3. Verify OpenAPI documentation at /docs endpoint",
        "testStrategy": "1. Manual API testing with curl:\n   - `curl 'http://localhost:8000/api/search/Phase%203%20lung%20cancer'`\n   - `curl 'http://localhost:8000/api/suggest?q=can'`\n2. Test CORS headers are present in response\n3. Test pagination: page=2, page_size=5\n4. Test error handling with invalid queries\n5. Verify health endpoint returns 200\n6. Test OpenAPI docs at /docs\n7. Load test with multiple concurrent requests",
        "priority": "high",
        "dependencies": [
          "4",
          "5",
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create main.py with FastAPI App Initialization and CORS Configuration",
            "description": "Implement the main FastAPI application entry point with proper app initialization, CORS middleware configured for Vite dev server origins, and global exception handler for consistent error responses.",
            "dependencies": [],
            "details": "Create `backend/app/main.py` with FastAPI app instance configured with title='Clinical Trials Search API', description, and version. Add CORSMiddleware with allow_origins for localhost:5173, localhost:3000, and 127.0.0.1:5173. Set allow_credentials=True, allow_methods=['*'], allow_headers=['*']. Implement global exception handler using @app.exception_handler(Exception) that returns JSONResponse with status_code=500 and structured error content including 'error' and 'detail' fields. Add uvicorn runner in __main__ block with host='0.0.0.0' and port=8000. Import get_settings from config for environment-based configuration.",
            "status": "done",
            "testStrategy": "Test CORS headers by making requests from different origins using curl with -H 'Origin: http://localhost:5173'. Verify Access-Control-Allow-Origin header in response. Test global exception handler by triggering an error and verifying JSON error response format with correct status code.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:09:47.133Z"
          },
          {
            "id": 2,
            "title": "Create Search Router with /api/search/{query} Endpoint and Pagination",
            "description": "Implement the search.py router file with the /api/search/{query} GET endpoint that accepts pagination parameters with proper validation constraints.",
            "dependencies": [
              1
            ],
            "details": "Create `backend/app/routers/search.py` with APIRouter configured with prefix='/api' and tags=['search']. Define the search_trials endpoint at GET '/search/{query}' with path parameter query (str) and Query parameters: page (int, default=1, ge=1) and page_size (int, default=10, ge=1, le=100). Set response_model=SearchResponse. Add proper docstring explaining the endpoint purpose. Import required dependencies: APIRouter, Query, HTTPException from fastapi, and the service modules (llm_service, es_service) and schema models (SearchResponse). Include the router in main.py using app.include_router(search.router).",
            "status": "done",
            "testStrategy": "Test endpoint with curl: GET /api/search/cancer?page=1&page_size=10. Verify pagination validation by testing page=0 (should fail), page_size=101 (should fail), and valid values. Check OpenAPI schema at /docs shows correct parameter constraints.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:09:47.369Z"
          },
          {
            "id": 3,
            "title": "Implement Search Endpoint Logic with Entity Extraction and ES Query Pipeline",
            "description": "Complete the search endpoint implementation by wiring together the LLM entity extraction, Elasticsearch query building, and result formatting into a coherent pipeline.",
            "dependencies": [
              2
            ],
            "details": "Inside the search_trials endpoint function: 1) Call await extract_entities(query) from llm_service to get ExtractedEntities object, 2) Pass entities to await es_service.search(entities, page, page_size) which returns (results, total) tuple, 3) Construct and return SearchResponse with query_interpretation=entities, results=results, total=total, page=page, page_size=page_size, clarification=entities.clarification. Wrap entire logic in try/except block, catching Exception and raising HTTPException(status_code=500, detail=str(e)). Add logging using Python logging module to log incoming queries and any errors for debugging purposes.",
            "status": "done",
            "testStrategy": "Test full pipeline with curl: GET /api/search/Phase%203%20lung%20cancer. Verify response contains query_interpretation with extracted entities, results array, total count, and pagination info. Test error handling by mocking service failures and verifying 500 response with error details.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:09:47.593Z"
          },
          {
            "id": 4,
            "title": "Add /api/suggest Endpoint with Query Validation",
            "description": "Implement the suggestion endpoint that provides type-ahead suggestions for partial query text with proper input validation.",
            "dependencies": [
              1
            ],
            "details": "Add get_suggestions endpoint to search.py router at GET '/suggest' with response_model=SuggestionResponse. Accept query parameter q using Query(..., min_length=2, description='Partial query text') where ... makes it required. Call await suggestion_service.get_suggestions(q) to fetch suggestions. Return SuggestionResponse(suggestions=suggestions). Implement try/except block with HTTPException(status_code=500, detail=str(e)) for error handling. Import suggestion_service from services and SuggestionResponse from schemas. Add logging for suggestion requests.",
            "status": "done",
            "testStrategy": "Test with curl: GET /api/suggest?q=can and verify suggestions returned. Test min_length validation with q=a (should fail with 422). Test empty query parameter (should fail). Verify response time is acceptable for type-ahead UX (<100ms target).",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:09:47.836Z"
          },
          {
            "id": 5,
            "title": "Add Health Check Endpoint and OpenAPI Documentation Configuration",
            "description": "Implement the health check endpoint for service monitoring and configure OpenAPI documentation with proper metadata and examples.",
            "dependencies": [
              1
            ],
            "details": "Add health_check endpoint at GET '/health' in main.py that returns {'status': 'healthy'}. This endpoint should be simple and not include complex logic to ensure reliable health checking. Enhance FastAPI app initialization with additional OpenAPI metadata: contact info, license, terms_of_service if applicable. Add response examples to endpoints using response_model_examples or OpenAPI extra schema. Verify /docs (Swagger UI) and /redoc endpoints are accessible and display correct API documentation. Add tags_metadata to describe the 'search' tag. Consider adding a /ready endpoint that checks ES connectivity for Kubernetes-style readiness probes.",
            "status": "done",
            "testStrategy": "Verify health endpoint: curl http://localhost:8000/health returns {\"status\": \"healthy\"}. Access /docs in browser and verify Swagger UI loads with correct API title, description, and version. Test all endpoints appear with proper documentation including parameters, response schemas, and examples.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:09:48.058Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down FastAPI endpoints into: 1) Create main.py with FastAPI app initialization, CORS middleware configuration for Vite dev server origins, and global exception handler, 2) Create search.py router with /api/search/{query} endpoint accepting pagination params (page, page_size with validation), 3) Implement search endpoint logic: call extract_entities -> build_query -> search -> return SearchResponse, 4) Add /api/suggest endpoint with query param validation (min_length=2) calling suggestion_service, 5) Add health check endpoint and OpenAPI documentation configuration. Each subtask should include proper error handling and logging.",
        "updatedAt": "2026-02-07T19:09:48.058Z"
      },
      {
        "id": 8,
        "title": "Frontend API Client and Core Components",
        "description": "Implement the React frontend API client service and core UI components including SearchBar with debounced suggestions, QueryInterpretation display, and result card components.",
        "status": "done",
        "dependencies": [
          "2",
          "7"
        ],
        "priority": "high",
        "details": "1. Create `frontend/src/services/api.ts`:\n   ```typescript\n   import type { SearchResponse, SuggestionResponse } from '../types';\n\n   // Use relative path since Vite proxy is configured at /api -> localhost:8000\n   const API_BASE = '/api';\n\n   export async function searchTrials(\n     query: string,\n     page: number = 1,\n     pageSize: number = 10\n   ): Promise<SearchResponse> {\n     const response = await fetch(\n       `${API_BASE}/search/${encodeURIComponent(query)}?page=${page}&page_size=${pageSize}`\n     );\n     if (!response.ok) {\n       throw new Error(`Search failed: ${response.statusText}`);\n     }\n     return response.json();\n   }\n\n   export async function getSuggestions(prefix: string): Promise<string[]> {\n     if (prefix.length < 2) return [];\n     const response = await fetch(\n       `${API_BASE}/suggest?q=${encodeURIComponent(prefix)}`\n     );\n     if (!response.ok) return [];\n     const data: SuggestionResponse = await response.json();\n     return data.suggestions;\n   }\n   ```\n\n2. Create `frontend/src/components/SearchBar.tsx`:\n   - Import `getSuggestions` from `../services/api`\n   - Use debounced input with 300ms delay\n   - Cycle through example placeholders every 4 seconds\n   - Show suggestions dropdown with click-to-select\n   - Style with Tailwind using CSS variables: `bg-[var(--color-bg)]`, `text-[var(--color-primary)]`, `bg-[var(--color-accent)]`\n   - Use `font-display` class for serif placeholder styling\n\n3. Create `frontend/src/components/QueryInterpretation.tsx`:\n   - Import `ExtractedEntities` from `../types` (NOT Location - use LocationFilter if needed)\n   - Access location via `entities.location?.city`, `entities.location?.state`, `entities.location?.country`\n   - Display entity chips with color coding for phase, condition, status, location, keyword, sponsor, age_group\n   - Use staggered fadeIn animations\n\n4. Create `frontend/src/components/ResultCard.tsx`:\n   - Import `TrialResult`, `STATUS_COLORS`, `StatusValue` from `../types`\n   - Use the existing `STATUS_COLORS` mapping from types file (values are color names: 'emerald', 'amber', 'blue', etc.)\n   - Build Tailwind classes dynamically: `bg-${STATUS_COLORS[status]}-100`, `text-${STATUS_COLORS[status]}-800`\n   - Note: `trial.conditions` is `Record<string, string>[]` - extract condition names appropriately\n   - Access sponsor via `trial.sponsors[0]?.name || 'Unknown'`\n   - Show expandable details with `brief_summaries_description` and facilities list",
        "testStrategy": "1. Test SearchBar debouncing - verify suggestions API called after 300ms delay\n2. Test placeholder cycling animation\n3. Test QueryInterpretation renders all entity types with correct colors\n4. Test ResultCard expansion toggle\n5. Test status color mapping using STATUS_COLORS from types file\n6. Verify animations render smoothly\n7. Test mobile responsive behavior\n8. Test keyboard navigation in suggestions dropdown\n9. Verify API calls use correct proxy path (/api not localhost:8000)\n10. Verify ExtractedEntities uses query_interpretation field from SearchResponse",
        "subtasks": [
          {
            "id": 1,
            "title": "Create API Client Service with Type-Safe Fetch Functions",
            "description": "Implement frontend/src/services/api.ts with searchTrials and getSuggestions functions using the Fetch API with proper error handling, TypeScript generics, and response type validation.",
            "dependencies": [],
            "details": "Create the API client module at frontend/src/services/api.ts. Use relative API_BASE = '/api' since Vite proxy is configured to forward /api to localhost:8000. Import types from '../types' including SearchResponse and SuggestionResponse. Implement searchTrials function that accepts query string, optional page (default 1), and optional pageSize (default 10) parameters, returning Promise<SearchResponse>. Note that SearchResponse includes query_interpretation (ExtractedEntities), results (TrialResult[]), total, page, page_size, and optional clarification fields. Use encodeURIComponent for query parameter encoding. Implement getSuggestions function that returns empty array for prefixes under 2 characters, otherwise fetches from /api/suggest endpoint and returns string array from SuggestionResponse.suggestions. Add proper error handling with descriptive error messages for failed requests.",
            "status": "done",
            "testStrategy": "Unit test searchTrials with mocked fetch responses for success and error cases. Test getSuggestions returns empty array for short prefixes. Test URL encoding works correctly for special characters in queries. Verify TypeScript types match SearchResponse and SuggestionResponse from types/index.ts.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:20:38.445Z"
          },
          {
            "id": 2,
            "title": "Build SearchBar Component with Debounced Input and Cycling Placeholders",
            "description": "Create the SearchBar component with debounced suggestion fetching (300ms), cycling example placeholder text animation (4s interval), and focus styling using CSS variables.",
            "dependencies": [
              1
            ],
            "details": "Create frontend/src/components/SearchBar.tsx with useState hooks for query, suggestions, showSuggestions, and placeholderIndex. Define EXAMPLE_QUERIES array with 4 example queries (Phase 3 lung cancer, recruiting diabetes, BRCA1 breast cancer, open melanoma). Implement useEffect with setInterval for 4-second placeholder cycling. Create handleInputChange with useRef for debounce timer, clearing previous timeout and setting new 300ms delayed suggestion fetch using getSuggestions from ../services/api. Implement handleSubmit preventing default, validating non-empty query, calling onSearch prop, and hiding suggestions. Style input with Tailwind using CSS variables: bg-[var(--color-bg-card)], focus:border-[var(--color-accent)], focus:ring-[var(--color-accent)]. Use font-display class for italic serif placeholder styling. Add disabled submit button styling with bg-[var(--color-accent)] and opacity-50 when isLoading. Ensure mobile responsiveness with proper max-width constraints.",
            "status": "done",
            "testStrategy": "Test debounce timing with jest.useFakeTimers - verify getSuggestions not called until 300ms after typing stops. Test placeholder cycling changes text every 4 seconds. Test form submission calls onSearch with trimmed query. Verify focus states apply correct accent color styling.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:20:38.448Z"
          },
          {
            "id": 3,
            "title": "Implement Suggestion Dropdown with Animations and Click Handling",
            "description": "Add the suggestions dropdown to SearchBar with smooth slideDown animation, click-to-select functionality, hover states, and outside-click dismissal behavior.",
            "dependencies": [
              2
            ],
            "details": "Extend SearchBar component to render suggestion dropdown conditionally when showSuggestions is true and suggestions array is not empty. Style dropdown ul with absolute positioning, z-10, full width, mt-2, bg-[var(--color-bg-card)], rounded-lg, shadow-lg, border border-gray-200, and animate-slideDown class. Render each suggestion as li with px-4 py-3 padding, cursor-pointer, hover:bg-[var(--color-primary)]/10 hover state, border-b border-gray-100 dividers (except last item). Implement onClick handler that sets query value, calls onSearch, and hides suggestions. Add useEffect with click event listener on document to detect outside clicks and close dropdown. Add keyboard navigation support with arrow keys for accessibility - track selectedIndex state, handle ArrowUp/ArrowDown to change selection, Enter to select. Ensure dropdown is mobile-friendly with touch-friendly tap targets (minimum 44px height).",
            "status": "done",
            "testStrategy": "Test dropdown appears when suggestions array populated and showSuggestions true. Test clicking suggestion updates query and triggers search. Test clicking outside dropdown closes it. Test keyboard navigation with arrow keys changes highlighted item. Test Enter key selects highlighted suggestion.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:20:38.451Z"
          },
          {
            "id": 4,
            "title": "Create QueryInterpretation Component with Color-Coded Entity Chips",
            "description": "Implement QueryInterpretation component displaying extracted entities as color-coded chips with sequential fade-in animations and proper label formatting.",
            "dependencies": [],
            "details": "Create frontend/src/components/QueryInterpretation.tsx accepting entities prop of type ExtractedEntities (imported from '../types'). Define ENTITY_COLORS mapping object with Tailwind classes: phase (indigo-100/800/200), condition (teal-100/800/200), status (emerald-100/800/200), location (slate-100/800/200), keyword (amber-100/800/200), sponsor (purple-100/800/200), age_group (rose-100/800/200). Build chips array by checking each entity property. For location, use entities.location which is of type LocationFilter (not Location) with optional city, state, country fields - format as comma-separated string. Replace underscores in status with spaces. Return null if no chips. Render container div with py-4 px-6, bg-[var(--color-bg)], border-y border-gray-200. Add 'We understood:' prefix span with text-sm text-[var(--color-text-muted)] mr-3. Map chips with inline-flex flex-wrap gap-2 container, each chip as span with px-3 py-1 rounded-full text-sm font-medium border, dynamic color class, and animate-fadeIn with staggered animationDelay (i * 100ms). Use font-semibold for label portion.",
            "status": "done",
            "testStrategy": "Test component renders null when no entities present. Test each entity type renders with correct color class. Test location formatting combines city/state/country correctly using LocationFilter interface. Test status underscore replacement works. Test animation delays are staggered correctly (0ms, 100ms, 200ms, etc.).",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:20:38.453Z"
          },
          {
            "id": 5,
            "title": "Build ResultCard Component with Expandable Details and Status Styling",
            "description": "Create ResultCard component with status-colored left border using STATUS_COLORS from types, serif title styling, expandable summary section, and metadata display for phase/sponsor/enrollment.",
            "dependencies": [],
            "details": "Create frontend/src/components/ResultCard.tsx accepting trial (TrialResult) and index props. Import STATUS_COLORS and StatusValue from '../types' - STATUS_COLORS maps status values to color names ('emerald', 'amber', 'blue', 'gray', 'red', 'orange', 'slate'). Build dynamic Tailwind classes using the color names: `bg-${colorName}-100`, `text-${colorName}-800`, `border-l-${colorName}-500`. Handle StatusValue type properly - use type assertion or fallback for unknown statuses. Add useState for expanded boolean. Render card div with bg-[var(--color-bg-card)] rounded-lg shadow-sm border border-gray-200 border-l-4 with dynamic borderColor, p-5, hover:shadow-md transition-shadow, cursor-pointer, animate-fadeIn with staggered delay (index * 50ms). Add onClick toggling expanded state. Display flex header with brief_title in font-display text-lg font-semibold text-[var(--color-text)], nct_id in text-xs text-[var(--color-text-muted)] font-mono, and status badge with dynamic colors. Show metadata row with phase (formatted without 'PHASE' prefix), sponsor (trial.sponsors[0]?.name or 'Unknown'), and enrollment with toLocaleString formatting. Note: trial.conditions is Record<string, string>[] - may need to extract condition names. Conditionally render expanded section with border-t, brief_summaries_description, and facilities list formatted as city/state/country joined by pipes.",
            "status": "done",
            "testStrategy": "Test card renders with correct status border color using STATUS_COLORS mapping. Test clicking card toggles expanded state. Test expanded section shows summary and facilities. Test sponsor falls back to 'Unknown' when empty. Test enrollment number formats with commas. Test animation delay based on index prop. Verify dynamic Tailwind classes work with STATUS_COLORS values.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:20:38.456Z"
          },
          {
            "id": 6,
            "title": "Verify TypeScript Types and Update Components to Match",
            "description": "Verify all components correctly use the existing TypeScript types from frontend/src/types/index.ts, ensuring proper field names and interface usage.",
            "dependencies": [
              1,
              4,
              5
            ],
            "details": "Types already exist at frontend/src/types/index.ts. This subtask is to verify all components use the correct types: 1) SearchResponse uses query_interpretation (not entities) for ExtractedEntities, 2) SearchResponse uses clarification (not clarification_needed), 3) SearchResponse does not have total_pages field - calculate from total/page_size, 4) LocationFilter is the type for location (not Location), 5) TrialResult.conditions is Record<string, string>[] not string[], 6) STATUS_COLORS is already exported from types file - use it instead of defining locally, 7) Facility has zip and status fields in addition to name/city/state/country, 8) AgeCategory interface has age_category string field, 9) ExtractedEntities has confidence number and optional clarification string. Update all component imports and usages to match these exact types.",
            "status": "done",
            "testStrategy": "Run tsc --noEmit to validate all type usages. Verify SearchResponse.query_interpretation is accessed (not .entities). Verify LocationFilter is used for location type references. Test that STATUS_COLORS import works correctly. Verify conditions array handling accounts for Record<string, string>[] type.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:20:38.458Z"
          },
          {
            "id": 7,
            "title": "Create CSS Animations in index.css",
            "description": "Add fadeIn and slideDown keyframe animations to frontend/src/index.css for use with animate-fadeIn and animate-slideDown utility classes.",
            "dependencies": [],
            "details": "Update frontend/src/index.css (which already has Tailwind import and CSS variables configured). Add @keyframes fadeIn animation from opacity 0 to 1 with transform translateY(8px) to translateY(0) over 0.3s ease-out. Add @keyframes slideDown from opacity 0, transform translateY(-10px) to opacity 1, translateY(0) over 0.2s ease-out. Define utility classes .animate-fadeIn and .animate-slideDown applying the respective animations with animation-fill-mode: both for proper initial state handling. Note: The file already imports Tailwind via @import 'tailwindcss' and has CSS variables for colors defined. Add animations after the existing styles. Ensure animations work with prefers-reduced-motion media query by adding @media (prefers-reduced-motion: reduce) rules that disable or reduce animation duration.",
            "status": "done",
            "testStrategy": "Verify animations play correctly by inspecting elements in browser DevTools. Test fadeIn applies to ResultCard components with visible opacity/transform transition. Test slideDown applies to suggestion dropdown. Verify prefers-reduced-motion is respected.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:20:38.461Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Break down frontend core components into: 1) Create api.ts with searchTrials and getSuggestions functions using fetch API with proper error handling and type safety, 2) Build SearchBar component with debounced input (300ms), cycling placeholder animation, amber focus glow, and suggestion dropdown with keyboard navigation, 3) Implement suggestion dropdown with smooth slide animation, click handling, and outside-click dismissal, 4) Create QueryInterpretation component with color-coded entity chips (indigo/teal/emerald/slate/amber), sequential entrance animation, and 'We understood:' prefix, 5) Build ResultCard component with status-colored left border, expandable details section, serif title, and metadata display, 6) Add proper TypeScript types throughout matching backend schemas, 7) Create CSS animations in index.css (fadeIn, slideDown) and configure Tailwind theme. Each subtask should be mobile-responsive.",
        "updatedAt": "2026-02-07T19:20:38.461Z"
      },
      {
        "id": 9,
        "title": "Frontend Results List, Pagination, and State Management",
        "description": "Implement the ResultsList component with staggered animations, Pagination controls, ClarificationBanner for ambiguous queries, EmptyState for no results, and wire up the complete App component with state management.",
        "details": "1. Create `frontend/src/components/Pagination.tsx`:\n   ```tsx\n   interface Props {\n     currentPage: number;\n     totalPages: number;\n     onPageChange: (page: number) => void;\n   }\n\n   export function Pagination({ currentPage, totalPages, onPageChange }: Props) {\n     if (totalPages <= 1) return null;\n\n     const pages = Array.from({ length: Math.min(totalPages, 5) }, (_, i) => {\n       if (totalPages <= 5) return i + 1;\n       if (currentPage <= 3) return i + 1;\n       if (currentPage >= totalPages - 2) return totalPages - 4 + i;\n       return currentPage - 2 + i;\n     });\n\n     return (\n       <div className=\"flex items-center justify-center gap-2 mt-8\">\n         <button\n           onClick={() => onPageChange(currentPage - 1)}\n           disabled={currentPage === 1}\n           className=\"px-3 py-2 rounded-lg border border-gray-300 disabled:opacity-50\n                      hover:bg-gray-50 transition-colors\"\n         >\n           Previous\n         </button>\n         {pages.map((page) => (\n           <button\n             key={page}\n             onClick={() => onPageChange(page)}\n             className={`w-10 h-10 rounded-lg border transition-colors\n                        ${page === currentPage\n                          ? 'bg-teal-700 text-white border-teal-700'\n                          : 'border-gray-300 hover:bg-gray-50'}`}\n           >\n             {page}\n           </button>\n         ))}\n         <button\n           onClick={() => onPageChange(currentPage + 1)}\n           disabled={currentPage === totalPages}\n           className=\"px-3 py-2 rounded-lg border border-gray-300 disabled:opacity-50\n                      hover:bg-gray-50 transition-colors\"\n         >\n           Next\n         </button>\n       </div>\n     );\n   }\n   ```\n\n2. Create `frontend/src/components/ClarificationBanner.tsx`:\n   ```tsx\n   interface Props {\n     question: string;\n     onSelection: (choice: string) => void;\n   }\n\n   export function ClarificationBanner({ question, onSelection }: Props) {\n     // Extract potential options from the question (simplified)\n     const options = extractOptions(question);\n\n     return (\n       <div className=\"w-full py-4 px-6 bg-amber-50 border-y border-amber-200\n                       animate-slideDown\">\n         <p className=\"text-amber-800 font-medium mb-3\">{question}</p>\n         {options.length > 0 && (\n           <div className=\"flex flex-wrap gap-2\">\n             {options.map((opt, i) => (\n               <button\n                 key={i}\n                 onClick={() => onSelection(opt)}\n                 className=\"px-4 py-2 rounded-full bg-white border border-amber-300\n                            text-amber-800 hover:bg-amber-100 transition-colors\"\n               >\n                 {opt}\n               </button>\n             ))}\n           </div>\n         )}\n       </div>\n     );\n   }\n\n   function extractOptions(question: string): string[] {\n     // Simple extraction - could be enhanced\n     const matches = question.match(/'([^']+)'/g);\n     return matches ? matches.map(m => m.replace(/'/g, '')) : [];\n   }\n   ```\n\n3. Create `frontend/src/components/EmptyState.tsx`:\n   ```tsx\n   interface Props {\n     type: 'no-results' | 'error';\n     message?: string;\n     onRetry?: () => void;\n     onSuggestionClick?: (query: string) => void;\n   }\n\n   const SUGGESTED_QUERIES = [\n     \"Phase 3 cancer trials\",\n     \"Recruiting diabetes studies\",\n     \"COVID-19 vaccine trials\"\n   ];\n\n   export function EmptyState({ type, message, onRetry, onSuggestionClick }: Props) {\n     return (\n       <div className=\"flex flex-col items-center justify-center py-16 px-4\">\n         <div className=\"w-24 h-24 mb-6 rounded-full bg-gray-100 flex items-center justify-center\">\n           {type === 'no-results' ? (\n             <svg className=\"w-12 h-12 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n               <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={1.5}\n                     d=\"M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z\" />\n             </svg>\n           ) : (\n             <svg className=\"w-12 h-12 text-red-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n               <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={1.5}\n                     d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z\" />\n             </svg>\n           )}\n         </div>\n         \n         <h2 className=\"font-serif text-2xl text-gray-700 mb-2\">\n           {type === 'no-results' ? 'No trials found' : 'Something went wrong'}\n         </h2>\n         <p className=\"text-gray-500 text-center max-w-md mb-6\">\n           {message || (type === 'no-results'\n             ? \"We couldn't find any clinical trials matching your search criteria.\"\n             : \"There was an error processing your request. Please try again.\")}\n         </p>\n\n         {type === 'error' && onRetry && (\n           <button\n             onClick={onRetry}\n             className=\"px-6 py-2 bg-teal-700 text-white rounded-lg hover:bg-teal-800\n                        transition-colors mb-6\"\n           >\n             Try Again\n           </button>\n         )}\n\n         {type === 'no-results' && onSuggestionClick && (\n           <div className=\"text-center\">\n             <p className=\"text-sm text-gray-500 mb-3\">Try one of these searches:</p>\n             <div className=\"flex flex-wrap justify-center gap-2\">\n               {SUGGESTED_QUERIES.map((q, i) => (\n                 <button\n                   key={i}\n                   onClick={() => onSuggestionClick(q)}\n                   className=\"px-4 py-2 rounded-full border border-teal-300 text-teal-700\n                              hover:bg-teal-50 transition-colors text-sm\"\n                 >\n                   {q}\n                 </button>\n               ))}\n             </div>\n           </div>\n         )}\n       </div>\n     );\n   }\n   ```\n\n4. Create `frontend/src/components/ResultsList.tsx`:\n   ```tsx\n   import type { TrialResult } from '../types';\n   import { ResultCard } from './ResultCard';\n   import { Pagination } from './Pagination';\n\n   interface Props {\n     results: TrialResult[];\n     total: number;\n     page: number;\n     pageSize: number;\n     onPageChange: (page: number) => void;\n   }\n\n   export function ResultsList({ results, total, page, pageSize, onPageChange }: Props) {\n     const totalPages = Math.ceil(total / pageSize);\n\n     return (\n       <div className=\"w-full max-w-4xl mx-auto\">\n         <p className=\"text-sm text-gray-500 mb-4\">\n           Showing {results.length} of {total.toLocaleString()} trials\n         </p>\n         <div className=\"space-y-4\">\n           {results.map((trial, index) => (\n             <ResultCard key={trial.nct_id} trial={trial} index={index} />\n           ))}\n         </div>\n         <Pagination\n           currentPage={page}\n           totalPages={totalPages}\n           onPageChange={onPageChange}\n         />\n       </div>\n     );\n   }\n   ```\n\n5. Update `frontend/src/App.tsx` with complete state management:\n   ```tsx\n   import { useState, useCallback } from 'react';\n   import { SearchBar } from './components/SearchBar';\n   import { QueryInterpretation } from './components/QueryInterpretation';\n   import { ResultsList } from './components/ResultsList';\n   import { ClarificationBanner } from './components/ClarificationBanner';\n   import { EmptyState } from './components/EmptyState';\n   import { searchTrials } from './services/api';\n   import type { SearchResponse } from './types';\n\n   type AppState = 'idle' | 'loading' | 'results' | 'no-results' | 'error';\n\n   export default function App() {\n     const [state, setState] = useState<AppState>('idle');\n     const [response, setResponse] = useState<SearchResponse | null>(null);\n     const [currentQuery, setCurrentQuery] = useState('');\n     const [error, setError] = useState<string | null>(null);\n\n     const handleSearch = useCallback(async (query: string, page = 1) => {\n       setCurrentQuery(query);\n       setState('loading');\n       setError(null);\n\n       try {\n         const result = await searchTrials(query, page);\n         setResponse(result);\n         setState(result.results.length > 0 ? 'results' : 'no-results');\n       } catch (err) {\n         setError(err instanceof Error ? err.message : 'Unknown error');\n         setState('error');\n       }\n     }, []);\n\n     const handlePageChange = useCallback((page: number) => {\n       handleSearch(currentQuery, page);\n       window.scrollTo({ top: 0, behavior: 'smooth' });\n     }, [currentQuery, handleSearch]);\n\n     const handleClarification = useCallback((choice: string) => {\n       handleSearch(`${currentQuery} ${choice}`);\n     }, [currentQuery, handleSearch]);\n\n     return (\n       <div className=\"min-h-screen bg-[#F8F6F3]\">\n         {/* Hero/Header section */}\n         <header className={`transition-all duration-300 ${state === 'idle' ? 'py-32' : 'py-8'}`}>\n           <div className=\"max-w-4xl mx-auto px-4 text-center\">\n             {state === 'idle' && (\n               <>\n                 <h1 className=\"font-serif text-5xl font-bold text-teal-900 mb-4\">\n                   Clinical Trials Search\n                 </h1>\n                 <p className=\"text-gray-600 text-lg mb-8\">\n                   Find clinical trials using natural language\n                 </p>\n               </>\n             )}\n             <SearchBar onSearch={handleSearch} isLoading={state === 'loading'} />\n           </div>\n         </header>\n\n         {/* Query interpretation */}\n         {response && state !== 'idle' && (\n           <QueryInterpretation entities={response.query_interpretation} />\n         )}\n\n         {/* Clarification banner */}\n         {response?.clarification && (\n           <ClarificationBanner\n             question={response.clarification}\n             onSelection={handleClarification}\n           />\n         )}\n\n         {/* Main content */}\n         <main className=\"px-4 py-8\">\n           {state === 'loading' && (\n             <div className=\"max-w-4xl mx-auto space-y-4\">\n               {[...Array(3)].map((_, i) => (\n                 <div key={i} className=\"h-32 bg-white rounded-lg animate-pulse\" />\n               ))}\n             </div>\n           )}\n\n           {state === 'results' && response && (\n             <ResultsList\n               results={response.results}\n               total={response.total}\n               page={response.page}\n               pageSize={response.page_size}\n               onPageChange={handlePageChange}\n             />\n           )}\n\n           {state === 'no-results' && (\n             <EmptyState\n               type=\"no-results\"\n               onSuggestionClick={handleSearch}\n             />\n           )}\n\n           {state === 'error' && (\n             <EmptyState\n               type=\"error\"\n               message={error || undefined}\n               onRetry={() => handleSearch(currentQuery)}\n             />\n           )}\n         </main>\n       </div>\n     );\n   }\n   ```",
        "testStrategy": "1. Test pagination navigation with multi-page results\n2. Test clarification banner rendering and selection\n3. Test empty state with suggestion clicks\n4. Test error state retry functionality\n5. Test loading skeleton display\n6. Test header transition from hero to compact\n7. Test smooth scroll on page change\n8. Test all state transitions: idle -> loading -> results/no-results/error\n9. Mobile responsive testing for all components",
        "priority": "high",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Pagination Component with Dynamic Page Number Generation",
            "description": "Implement the Pagination.tsx component with intelligent page number generation that handles edge cases for first/last pages, ellipsis display for large page counts, and proper disabled states for navigation buttons.",
            "dependencies": [],
            "details": "Create `frontend/src/components/Pagination.tsx` with the following features:\n\n1. **Props interface**: Accept `currentPage`, `totalPages`, and `onPageChange` callback\n2. **Early return**: Return null when `totalPages <= 1` (no pagination needed)\n3. **Dynamic page array generation**:\n   - For 5 or fewer pages: show all pages [1, 2, 3, 4, 5]\n   - When currentPage <= 3: show first 5 pages\n   - When currentPage >= totalPages - 2: show last 5 pages\n   - Otherwise: show currentPage centered with 2 pages on each side\n4. **Previous button**: Disabled when `currentPage === 1`, calls `onPageChange(currentPage - 1)`\n5. **Page number buttons**: Highlight current page with teal-700 background and white text, others have gray border with hover state\n6. **Next button**: Disabled when `currentPage === totalPages`, calls `onPageChange(currentPage + 1)`\n7. **Styling**: Use flex layout with gap-2, centered alignment, mt-8 margin top, rounded-lg buttons with transition-colors\n8. **Accessibility**: Ensure buttons have proper disabled states reflected visually (opacity-50)",
            "status": "done",
            "testStrategy": "1. Test with totalPages=1: component should return null\n2. Test with totalPages=5, currentPage=1: should show pages [1,2,3,4,5] with 1 highlighted\n3. Test with totalPages=10, currentPage=1: Previous should be disabled, should show [1,2,3,4,5]\n4. Test with totalPages=10, currentPage=10: Next should be disabled, should show [6,7,8,9,10]\n5. Test with totalPages=20, currentPage=10: should show [8,9,10,11,12]\n6. Verify onPageChange callback fires correctly on button clicks",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:30:17.147Z"
          },
          {
            "id": 2,
            "title": "Build ClarificationBanner with Question Parsing and Selection Handling",
            "description": "Create the ClarificationBanner.tsx component with amber styling that displays clarification questions, extracts potential options from the question text using regex, and triggers refined searches when users select an option.",
            "dependencies": [],
            "details": "Create `frontend/src/components/ClarificationBanner.tsx` with:\n\n1. **Props interface**: Accept `question` string and `onSelection` callback that receives the chosen option\n2. **extractOptions helper function**:\n   - Parse question string for quoted text using regex `/'([^']+)'/g`\n   - Return array of extracted strings with quotes removed\n   - Return empty array if no matches found\n3. **Banner styling**:\n   - Full width with py-4 px-6 padding\n   - Amber color scheme: bg-amber-50, border-y border-amber-200\n   - Add `animate-slideDown` class for entrance animation\n4. **Question display**: Show question text in text-amber-800 font-medium with mb-3 margin\n5. **Option buttons** (only render if options.length > 0):\n   - Wrap in flex container with flex-wrap gap-2\n   - Each button: px-4 py-2, rounded-full, bg-white, border border-amber-300\n   - Text in text-amber-800 with hover:bg-amber-100 transition\n   - onClick calls `onSelection(opt)` with the option text\n6. **Add slideDown animation to tailwind.config.js** if not already present:\n   ```js\n   animation: { slideDown: 'slideDown 0.3s ease-out' },\n   keyframes: { slideDown: { from: { opacity: 0, transform: 'translateY(-10px)' }, to: { opacity: 1, transform: 'translateY(0)' } } }\n   ```",
            "status": "done",
            "testStrategy": "1. Test with question containing quoted options: \"Did you mean 'diabetes' or 'diabetic'?\" should extract ['diabetes', 'diabetic']\n2. Test with question without quotes: should render question but no option buttons\n3. Verify onSelection callback is called with correct option text when button clicked\n4. Verify amber color scheme renders correctly\n5. Test slideDown animation triggers on component mount\n6. Test with multiple options (3+) to verify flex-wrap behavior",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:30:17.151Z"
          },
          {
            "id": 3,
            "title": "Create EmptyState Component with No-Results and Error Variants",
            "description": "Implement the EmptyState.tsx component with two distinct variants: 'no-results' showing suggested queries and 'error' showing retry functionality, each with appropriate icons, messaging, and interactive elements.",
            "dependencies": [],
            "details": "Create `frontend/src/components/EmptyState.tsx` with:\n\n1. **Props interface**: `type: 'no-results' | 'error'`, optional `message`, optional `onRetry` callback, optional `onSuggestionClick` callback\n2. **SUGGESTED_QUERIES constant**: Array of example searches like [\"Phase 3 cancer trials\", \"Recruiting diabetes studies\", \"COVID-19 vaccine trials\"]\n3. **Container styling**: Centered flex column with py-16 px-4\n4. **Icon container**: 24x24 (w-24 h-24) rounded-full bg-gray-100 with centered icon\n   - 'no-results': Search magnifying glass SVG in text-gray-400\n   - 'error': Warning triangle SVG in text-red-400\n5. **Heading**: font-serif text-2xl text-gray-700 mb-2\n   - 'no-results': \"No trials found\"\n   - 'error': \"Something went wrong\"\n6. **Description**: text-gray-500 centered max-w-md mb-6, use message prop or default text\n7. **Error retry button** (only for type='error' when onRetry provided):\n   - px-6 py-2, bg-teal-700 text-white, rounded-lg, hover:bg-teal-800 transition, mb-6\n8. **Suggested queries** (only for type='no-results' when onSuggestionClick provided):\n   - \"Try one of these searches:\" label in text-sm text-gray-500 mb-3\n   - Flex-wrap container with gap-2 and justify-center\n   - Each suggestion: px-4 py-2, rounded-full, border border-teal-300, text-teal-700, hover:bg-teal-50, text-sm",
            "status": "done",
            "testStrategy": "1. Test 'no-results' variant renders search icon, correct heading, and suggestions\n2. Test 'error' variant renders warning icon, correct heading, and retry button\n3. Test onRetry callback fires when retry button clicked\n4. Test onSuggestionClick callback fires with query text when suggestion clicked\n5. Test custom message prop overrides default text\n6. Test retry button only renders when onRetry is provided\n7. Test suggestions only render when onSuggestionClick is provided",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:30:17.153Z"
          },
          {
            "id": 4,
            "title": "Implement ResultsList Component with Staggered Animations",
            "description": "Create the ResultsList.tsx component that composes multiple ResultCard components with staggered entrance animations, displays result count information, and integrates the Pagination component for navigation.",
            "dependencies": [
              1
            ],
            "details": "Create `frontend/src/components/ResultsList.tsx` with:\n\n1. **Imports**: Import TrialResult type, ResultCard component, and Pagination component\n2. **Props interface**: `results: TrialResult[]`, `total: number`, `page: number`, `pageSize: number`, `onPageChange: (page: number) => void`\n3. **Calculate totalPages**: `Math.ceil(total / pageSize)`\n4. **Container**: `w-full max-w-4xl mx-auto`\n5. **Result count display**: \n   - `<p className=\"text-sm text-gray-500 mb-4\">`\n   - Text: \"Showing {results.length} of {total.toLocaleString()} trials\"\n6. **Results container**: `<div className=\"space-y-4\">`\n7. **Map ResultCards**: Pass `trial` and `index` to each ResultCard\n   - The index is used by ResultCard for staggered animation delay\n   - Key should be `trial.nct_id`\n8. **Pagination component**: Pass currentPage={page}, totalPages, onPageChange\n9. **Staggered animation in ResultCard** (verify/update ResultCard.tsx):\n   - Add animation delay based on index: `style={{ animationDelay: `${index * 100}ms` }}`\n   - Add CSS class `animate-fadeInUp` with animation-fill-mode: both\n10. **Add fadeInUp animation to tailwind config** if needed:\n    ```js\n    animation: { fadeInUp: 'fadeInUp 0.4s ease-out' },\n    keyframes: { fadeInUp: { from: { opacity: 0, transform: 'translateY(20px)' }, to: { opacity: 1, transform: 'translateY(0)' } } }\n    ```",
            "status": "done",
            "testStrategy": "1. Test ResultsList renders correct number of ResultCard components\n2. Test result count shows correct \"Showing X of Y trials\" text with proper formatting\n3. Test staggered animation - first card animates immediately, second after 100ms, etc.\n4. Test Pagination receives correct props (currentPage, totalPages)\n5. Test onPageChange callback propagates to Pagination correctly\n6. Test with empty results array - should render empty container with Pagination\n7. Test with large total (1000+) formats with toLocaleString()",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:30:17.156Z"
          },
          {
            "id": 5,
            "title": "Build App.tsx with Complete State Machine and Search Handler",
            "description": "Implement the main App.tsx component with a complete state machine managing idle, loading, results, no-results, and error states, including search functionality with pagination support, clarification handling, and smooth scroll behavior.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Update `frontend/src/App.tsx` with complete state management:\n\n1. **Imports**: useState, useCallback from React; all components (SearchBar, QueryInterpretation, ResultsList, ClarificationBanner, EmptyState); searchTrials from api service; SearchResponse type\n2. **AppState type**: `'idle' | 'loading' | 'results' | 'no-results' | 'error'`\n3. **State variables**:\n   - `state: AppState` initialized to 'idle'\n   - `response: SearchResponse | null` initialized to null\n   - `currentQuery: string` initialized to ''\n   - `error: string | null` initialized to null\n4. **handleSearch callback** (memoized with useCallback):\n   - Accept query string and optional page (default 1)\n   - Set currentQuery, setState to 'loading', clear error\n   - Try/catch block: call searchTrials, setResponse, setState based on results.length\n   - Catch: setError with message, setState to 'error'\n5. **handlePageChange callback**: Call handleSearch with currentQuery and page, then `window.scrollTo({ top: 0, behavior: 'smooth' })`\n6. **handleClarification callback**: Call handleSearch with `${currentQuery} ${choice}`\n7. **JSX structure**:\n   - Root: `min-h-screen bg-[#F8F6F3]`\n   - Header: Dynamic padding `py-32` for idle, `py-8` otherwise, with transition-all duration-300\n   - Conditionally render hero text only in idle state\n   - SearchBar always visible, pass isLoading prop\n   - QueryInterpretation when response exists and not idle\n   - ClarificationBanner when response?.clarification exists\n   - Main content: loading skeletons, ResultsList, or EmptyState based on state",
            "status": "done",
            "testStrategy": "1. Test initial state is 'idle' with hero text and expanded header\n2. Test search transitions: idle -> loading -> results (with data) or no-results (empty)\n3. Test error state: simulate API failure, verify error message displays\n4. Test header transition: verify py-32 becomes py-8 on search\n5. Test pagination: verify handlePageChange updates results and scrolls to top\n6. Test clarification: verify handleClarification appends choice to query\n7. Test retry from error state returns to loading then appropriate state\n8. Test suggestion click from EmptyState triggers new search",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:30:17.159Z"
          },
          {
            "id": 6,
            "title": "Add Skeleton Loading States with Shimmer Animation and Header Transition",
            "description": "Implement skeleton loading placeholders with shimmer animation effect during API calls, and ensure the header transition from hero (idle) to compact (active) state animates smoothly with proper CSS transitions.",
            "dependencies": [
              5
            ],
            "details": "Enhance loading states and header transitions in App.tsx and CSS:\n\n1. **Loading skeletons in App.tsx main content**:\n   - When state === 'loading', render 3 skeleton cards\n   - Each skeleton: `h-32 bg-white rounded-lg animate-pulse`\n   - Wrap in `max-w-4xl mx-auto space-y-4`\n\n2. **Enhanced shimmer animation** (update tailwind.config.js or index.css):\n   ```css\n   @keyframes shimmer {\n     0% { background-position: -200% 0; }\n     100% { background-position: 200% 0; }\n   }\n   .animate-shimmer {\n     background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);\n     background-size: 200% 100%;\n     animation: shimmer 1.5s infinite;\n   }\n   ```\n\n3. **Optional: Create SkeletonCard component** for reusability:\n   ```tsx\n   export function SkeletonCard() {\n     return (\n       <div className=\"bg-white rounded-lg p-6 animate-shimmer\">\n         <div className=\"h-4 bg-gray-200 rounded w-3/4 mb-4\" />\n         <div className=\"h-3 bg-gray-200 rounded w-1/2 mb-2\" />\n         <div className=\"h-3 bg-gray-200 rounded w-full\" />\n       </div>\n     );\n   }\n   ```\n\n4. **Header transition refinement**:\n   - Ensure `transition-all duration-300` on header element\n   - Hero content (h1, p) should fade out: add `transition-opacity duration-300` and conditional opacity-0\n   - Consider using `overflow-hidden` with dynamic max-height for smoother collapse\n\n5. **SearchBar position transition**:\n   - Ensure SearchBar smoothly moves from centered (hero) to top position\n   - Use transform or layout animations as needed\n\n6. **Add all required keyframe animations to tailwind.config.js**:\n   - slideDown (for ClarificationBanner)\n   - fadeInUp (for ResultCards)\n   - shimmer (for loading skeletons)",
            "status": "done",
            "testStrategy": "1. Test loading state displays 3 skeleton cards with shimmer animation\n2. Test shimmer animation runs continuously (infinite loop)\n3. Test header transition timing - should take 300ms to collapse\n4. Test hero text fades out when transitioning from idle state\n5. Test SearchBar position animates smoothly from center to top\n6. Verify no layout shift or jumpy behavior during state transitions\n7. Test rapid state changes (quick searches) don't cause animation glitches\n8. Verify all animations defined in tailwind.config.js compile correctly",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:30:17.161Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down results and state management into: 1) Create Pagination component with dynamic page number generation, edge-case handling (first/last page), and proper button states, 2) Build ClarificationBanner with amber styling, question parsing to extract options, and selection handling that triggers refined search, 3) Create EmptyState component with two variants (no-results, error), suggestion query buttons, and retry functionality, 4) Implement ResultsList component composing ResultCard with staggered animations and result count display, 5) Build App.tsx with complete state machine (idle/loading/results/no-results/error), search handler with pagination support, and smooth scroll on page change, 6) Add skeleton loading states with shimmer animation and header transition (hero to compact). Each subtask should handle all state transitions gracefully.",
        "updatedAt": "2026-02-07T19:30:17.161Z"
      },
      {
        "id": 10,
        "title": "Visual Polish, Animations, and End-to-End Testing",
        "description": "Apply final visual polish including custom animations, font styling, responsive design refinements, and comprehensive end-to-end testing across diverse query types.",
        "details": "1. Update `frontend/src/index.css` with complete styling:\n   ```css\n   @import url('https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,400;9..144,600;9..144,700&family=Outfit:wght@400;500;600&display=swap');\n   @import 'tailwindcss';\n\n   :root {\n     --color-primary: #0D4F4F;\n     --color-accent: #D4A843;\n     --color-bg: #F8F6F3;\n   }\n\n   body {\n     font-family: 'Outfit', sans-serif;\n     background-color: var(--color-bg);\n   }\n\n   .font-serif {\n     font-family: 'Fraunces', serif;\n   }\n\n   /* Custom animations */\n   @keyframes fadeIn {\n     from { opacity: 0; transform: translateY(8px); }\n     to { opacity: 1; transform: translateY(0); }\n   }\n\n   @keyframes slideDown {\n     from { opacity: 0; transform: translateY(-10px); }\n     to { opacity: 1; transform: translateY(0); }\n   }\n\n   @keyframes shimmer {\n     0% { background-position: -200% 0; }\n     100% { background-position: 200% 0; }\n   }\n\n   .animate-fadeIn {\n     animation: fadeIn 0.3s ease-out forwards;\n     opacity: 0;\n   }\n\n   .animate-slideDown {\n     animation: slideDown 0.2s ease-out forwards;\n   }\n\n   .animate-pulse {\n     background: linear-gradient(90deg, #e5e5e5 25%, #f5f5f5 50%, #e5e5e5 75%);\n     background-size: 200% 100%;\n     animation: shimmer 1.5s infinite;\n   }\n\n   /* Focus states */\n   input:focus {\n     box-shadow: 0 0 0 4px rgba(212, 168, 67, 0.2);\n   }\n\n   /* Scrollbar styling */\n   ::-webkit-scrollbar {\n     width: 8px;\n   }\n   ::-webkit-scrollbar-track {\n     background: #f1f1f1;\n   }\n   ::-webkit-scrollbar-thumb {\n     background: #c1c1c1;\n     border-radius: 4px;\n   }\n   ```\n\n2. Update `frontend/tailwind.config.ts`:\n   ```typescript\n   import type { Config } from 'tailwindcss'\n\n   export default {\n     content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],\n     theme: {\n       extend: {\n         colors: {\n           teal: {\n             50: '#f0fdfa',\n             100: '#ccfbf1',\n             200: '#99f6e4',\n             300: '#5eead4',\n             400: '#2dd4bf',\n             500: '#14b8a6',\n             600: '#0d9488',\n             700: '#0D4F4F',\n             800: '#0A3D3D',\n             900: '#082f2f',\n           },\n           amber: {\n             400: '#D4A843',\n             500: '#c99a3a',\n           }\n         },\n         fontFamily: {\n           serif: ['Fraunces', 'serif'],\n           sans: ['Outfit', 'sans-serif'],\n         },\n       },\n     },\n     plugins: [],\n   } satisfies Config\n   ```\n\n3. Update `frontend/index.html` with proper meta tags:\n   ```html\n   <!DOCTYPE html>\n   <html lang=\"en\">\n     <head>\n       <meta charset=\"UTF-8\" />\n       <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n       <meta name=\"description\" content=\"Search clinical trials using natural language\" />\n       <title>Clinical Trials Search</title>\n       <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n       <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n     </head>\n     <body>\n       <div id=\"root\"></div>\n       <script type=\"module\" src=\"/src/main.tsx\"></script>\n     </body>\n   </html>\n   ```\n\n4. End-to-end test scenarios to validate:\n   ```\n   Test Cases:\n   1. \"Phase 3 lung cancer trials in the USA\"\n      Expected: phase=PHASE3, condition=lung cancer, location.country=United States\n      Verify: Results show Phase 3 trials with lung cancer in title/description, US locations\n\n   2. \"recruiting diabetes trials near Boston\"\n      Expected: status=RECRUITING, condition=diabetes, location.city=Boston\n      Verify: All results have RECRUITING status, diabetes-related\n\n   3. \"List all Phase 2 trials for Breast Cancer associated with BRCA1 gene\"\n      Expected: phase=PHASE2, condition=Breast Cancer, keyword=BRCA1\n      Verify: Results mention BRCA1 in descriptions\n\n   4. \"open melanoma trials\" (synonym test)\n      Expected: status=RECRUITING (from \"open\" synonym), condition=melanoma\n      Verify: Synonym mapping works correctly\n\n   5. \"cancer\" (broad query - clarification test)\n      Expected: Low confidence, possibly clarification question\n      Verify: Clarification banner may appear or broad results returned\n\n   6. \"\" (empty query)\n      Expected: Error handling or prompt for input\n      Verify: Graceful handling without crash\n\n   7. \"asdfghjkl\" (gibberish)\n      Expected: No results or clarification\n      Verify: Empty state displayed with suggestions\n\n   8. Pagination test with broad query\n      Verify: Navigate between pages, results update correctly\n\n   9. Mobile responsive test\n      Verify: All components render correctly on mobile viewport\n   ```\n\n5. Performance optimizations:\n   - Verify debounce timing (300ms) provides good UX\n   - Test skeleton loading shows immediately\n   - Verify animations don't cause layout shift\n   - Check network waterfall for optimal loading",
        "testStrategy": "1. Execute all 9 end-to-end test scenarios documented above\n2. Record screenshots of each query result for verification\n3. Test on multiple browsers (Chrome, Firefox, Safari)\n4. Test responsive design at breakpoints: 320px, 768px, 1024px, 1440px\n5. Lighthouse audit for performance, accessibility, SEO\n6. Test with slow network throttling (3G simulation)\n7. Verify keyboard navigation works throughout app\n8. Test screen reader compatibility for accessibility\n9. Cross-browser animation rendering verification\n10. Final visual QA against design specifications",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Complete index.css with Google Fonts and Custom Animations",
            "description": "Create the complete frontend/src/index.css file with Google Fonts imports (Fraunces serif for headings, Outfit sans-serif for body), CSS custom properties for theme colors (teal primary #0D4F4F, amber accent #D4A843, warm gray background #F8F6F3), keyframe animations (fadeIn, slideDown, shimmer), custom scrollbar styling, and focus states with amber glow.",
            "dependencies": [],
            "details": "1. Add Google Fonts import for Fraunces (opsz,wght@9..144,400;600;700) and Outfit (wght@400;500;600) with display=swap for performance\n2. Configure Tailwind CSS import directive\n3. Define CSS custom properties in :root - --color-primary: #0D4F4F, --color-accent: #D4A843, --color-bg: #F8F6F3\n4. Set body font-family to Outfit with background-color using var(--color-bg)\n5. Create .font-serif class using Fraunces for editorial headings\n6. Implement @keyframes fadeIn animation (opacity 0→1, translateY 8px→0, duration 0.3s ease-out)\n7. Implement @keyframes slideDown animation (opacity 0→1, translateY -10px→0, duration 0.2s ease-out)\n8. Implement @keyframes shimmer animation for loading states (background-position -200%→200%, duration 1.5s infinite)\n9. Create utility classes: .animate-fadeIn, .animate-slideDown, .animate-pulse (using shimmer)\n10. Style input:focus with amber box-shadow (0 0 0 4px rgba(212, 168, 67, 0.2))\n11. Add webkit scrollbar styling (8px width, #f1f1f1 track, #c1c1c1 thumb with 4px border-radius)",
            "status": "done",
            "testStrategy": "Verify Google Fonts load correctly by inspecting network requests for fonts.googleapis.com. Test animations by adding test classes to elements and confirming smooth transitions. Check custom scrollbar appears in webkit browsers. Validate focus states trigger on input focus. Use Chrome DevTools to verify CSS custom properties are applied correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:47:39.716Z"
          },
          {
            "id": 2,
            "title": "Configure tailwind.config.ts with Extended Theme and Custom Fonts",
            "description": "Update frontend/tailwind.config.ts with extended color palette including custom teal shades (50-900 with 700 as primary #0D4F4F), amber accent colors (400 #D4A843, 500 #c99a3a), custom font families (Fraunces for serif, Outfit for sans-serif), and ensure content paths include all source files.",
            "dependencies": [
              1
            ],
            "details": "1. Import Config type from tailwindcss for TypeScript support\n2. Configure content array to include './index.html' and './src/**/*.{js,ts,jsx,tsx}'\n3. Extend theme.colors.teal with full palette: 50 #f0fdfa, 100 #ccfbf1, 200 #99f6e4, 300 #5eead4, 400 #2dd4bf, 500 #14b8a6, 600 #0d9488, 700 #0D4F4F (primary), 800 #0A3D3D, 900 #082f2f\n4. Extend theme.colors.amber with accent shades: 400 #D4A843, 500 #c99a3a\n5. Configure fontFamily.serif as ['Fraunces', 'serif'] for editorial headings\n6. Configure fontFamily.sans as ['Outfit', 'sans-serif'] for body/UI text\n7. Export configuration using 'satisfies Config' for type safety\n8. Verify plugins array is empty (no external dependencies needed)",
            "status": "done",
            "testStrategy": "Run Tailwind build and verify no configuration errors. Test that teal-700 class applies #0D4F4F correctly. Verify font-serif and font-sans classes apply correct font families. Use browser DevTools to inspect computed styles and confirm extended colors are available.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:47:39.718Z"
          },
          {
            "id": 3,
            "title": "Update index.html with Meta Tags and Font Preconnect Links",
            "description": "Update frontend/index.html with proper HTML5 doctype, language attribute, essential meta tags (charset UTF-8, viewport for responsive design, description for SEO), and font preconnect links to fonts.googleapis.com and fonts.gstatic.com for optimal font loading performance.",
            "dependencies": [],
            "details": "1. Ensure DOCTYPE html is present at the top\n2. Add lang=\"en\" attribute to html element\n3. Add meta charset=\"UTF-8\" in head section\n4. Add meta viewport with 'width=device-width, initial-scale=1.0' for responsive design\n5. Add meta description: 'Search clinical trials using natural language'\n6. Set page title to 'Clinical Trials Search'\n7. Add preconnect link for 'https://fonts.googleapis.com' to establish early connection\n8. Add preconnect link for 'https://fonts.gstatic.com' with crossorigin attribute for font files\n9. Ensure div#root is present in body for React mounting\n10. Verify script tag loads '/src/main.tsx' with type=\"module\"",
            "status": "done",
            "testStrategy": "Validate HTML using W3C validator. Check network waterfall in DevTools to confirm preconnect reduces font loading time. Verify meta viewport enables proper mobile scaling. Test that description appears in browser tab preview and search engine results simulation.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:47:39.721Z"
          },
          {
            "id": 4,
            "title": "Execute End-to-End Test Scenarios for Query Processing",
            "description": "Execute comprehensive end-to-end test scenarios covering multi-entity queries, synonym mapping, clarification triggers, empty/gibberish input handling, and pagination. Document results for each test case including expected vs actual behavior.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Test Case 1: 'Phase 3 lung cancer trials in the USA' - Verify phase=PHASE3, condition=lung cancer, location.country=United States are extracted and results contain Phase 3 lung cancer trials in US\nTest Case 2: 'recruiting diabetes trials near Boston' - Verify status=RECRUITING, condition=diabetes, location.city=Boston and all results show RECRUITING status\nTest Case 3: 'List all Phase 2 trials for Breast Cancer associated with BRCA1 gene' - Verify phase=PHASE2, condition=Breast Cancer, keyword=BRCA1 and results mention BRCA1\nTest Case 4: 'open melanoma trials' - Test synonym mapping 'open'->RECRUITING, verify status=RECRUITING for melanoma trials\nTest Case 5: 'cancer' - Test broad query handling, check if low confidence triggers clarification banner or returns broad results gracefully\nTest Case 6: '' (empty query) - Verify graceful error handling without crash, appropriate error message displayed\nTest Case 7: 'asdfghjkl' (gibberish) - Verify empty state with suggestions is displayed\nTest Case 8: Pagination - Submit broad query, navigate between pages, verify results update correctly and page indicators are accurate\nDocument all results with screenshots if applicable",
            "status": "done",
            "testStrategy": "Execute each test case manually in the browser. Record the query interpretation displayed in the UI and compare with expected entity extraction. Verify result cards match search criteria. Check browser console for JavaScript errors during each test. Document pass/fail status for each scenario.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:53:41.442Z"
          },
          {
            "id": 5,
            "title": "Test Responsive Design at Key Breakpoints and Fix Layout Issues",
            "description": "Test responsive design at critical breakpoints (320px mobile, 768px tablet, 1024px laptop, 1440px desktop) across all components. Identify and fix any layout issues including overflow, text truncation, spacing problems, and component stacking on narrow viewports.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "1. Test at 320px (small mobile): Verify search bar is full-width with adequate padding, result cards stack vertically, entity chips wrap properly, pagination controls remain accessible, no horizontal scrolling occurs, fonts remain readable at minimum sizes\n2. Test at 768px (tablet): Verify search section has appropriate margins, result cards may be 2-column if designed, query interpretation strip scales properly, clarification banner adapts to width\n3. Test at 1024px (laptop): Verify content is centered with max-width container, proper spacing between search/interpretation/results sections, hover states work correctly\n4. Test at 1440px (desktop): Verify layout uses available space without excessive stretching, typography hierarchy is maintained, generous whitespace as per PRD spec\n5. Fix any identified issues: Update Tailwind responsive classes (sm:, md:, lg:, xl:), adjust grid/flex layouts, ensure touch targets are minimum 44px on mobile, verify images/icons scale appropriately",
            "status": "done",
            "testStrategy": "Use Chrome DevTools device emulation to test each breakpoint. Test on actual mobile devices if available. Use responsive design mode in Firefox for cross-validation. Check that all interactive elements are accessible at each breakpoint. Verify no content is cut off or overlapping.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:54:37.468Z"
          },
          {
            "id": 6,
            "title": "Performance Optimization and Animation Quality Verification",
            "description": "Verify and optimize performance characteristics including debounce timing (300ms for search input), skeleton loading immediate display, animation smoothness without layout shift, and network waterfall efficiency. Conduct Lighthouse audits and address any performance issues.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "1. Verify debounce timing: Type in search bar and confirm suggestions API is called after 300ms pause, not on every keystroke. Test that typing continuously does not trigger multiple API calls\n2. Test skeleton loading: Submit search query and verify skeleton cards with shimmer animation appear immediately (within 100ms) before results load\n3. Check layout shift: Use Chrome DevTools Performance panel to record search flow, verify CLS (Cumulative Layout Shift) score is below 0.1, ensure animations don't cause content to jump\n4. Verify animation performance: Check that fadeIn, slideDown, and shimmer animations run at 60fps using DevTools Performance monitor, no jank during card reveal animations\n5. Network waterfall analysis: Check that fonts are loaded with preconnect optimization, API calls are not duplicated, responses are appropriately sized\n6. Run Lighthouse audit: Target Performance score >90, Accessibility score >90, Best Practices >90. Address any flagged issues\n7. Verify staggered card animation doesn't cause visible performance degradation with 10+ results",
            "status": "done",
            "testStrategy": "Use Chrome DevTools Performance panel to profile search interactions. Run Lighthouse in incognito mode for accurate scores. Test on throttled 3G network to verify skeleton loading behavior. Use requestAnimationFrame timing to verify animation performance. Document any CLS issues with before/after screenshots.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T19:58:06.493Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down visual polish and testing into: 1) Complete index.css with Google Fonts import (Fraunces, Outfit), CSS variables for theme colors, keyframe animations (fadeIn, slideDown, shimmer), and custom scrollbar styling, 2) Configure tailwind.config.ts with extended color palette (teal-700 as primary, amber-400 as accent), custom font families, and animation utilities, 3) Update index.html with proper meta tags, font preconnect links, and description, 4) Execute end-to-end test scenarios covering: synonym mapping, complex multi-entity queries, clarification triggers, empty/gibberish input, and pagination, 5) Test responsive design at key breakpoints (320px, 768px, 1024px, 1440px) and fix any layout issues, 6) Performance optimization: verify debounce timing, check animation performance, ensure no layout shift. Each subtask should include verification against the PRD design specs.",
        "updatedAt": "2026-02-07T19:58:06.493Z"
      },
      {
        "id": 11,
        "title": "AI-Generated Search Results Summary with Clickable Citations",
        "description": "Add an AI-powered summary section that appears above search results on page 1, synthesizing top results into 3-5 sentences with numbered citation markers that scroll to and highlight the corresponding result cards when clicked.",
        "details": "## Backend Implementation\n\n### 1. Create Summary Generation Service\nCreate `backend/app/services/summary_service.py`:\n```python\nimport anthropic\nimport logging\nfrom typing import List, Optional\nfrom ..config import get_settings\nfrom ..models.schemas import TrialResult\n\nlogger = logging.getLogger(__name__)\n\nSUMMARY_SYSTEM_PROMPT = \"\"\"You are a clinical trials research assistant. Synthesize the provided clinical trial results into a concise overview.\n\nRules:\n1. Write 3-5 sentences summarizing the key findings across the trials\n2. Include numbered citation markers [1], [2], etc. to reference specific trials\n3. Citation numbers correspond to the trial's position in the results (1-indexed)\n4. Focus on: trial phases, conditions being studied, recruiting status, sponsor patterns, and notable enrollment sizes\n5. Be objective and informative - help users quickly understand what types of trials match their search\n6. Only cite trials that you specifically mention details from\n7. Output plain text only - no markdown formatting\"\"\"\n\nasync def generate_summary(results: List[TrialResult], query: str) -> Optional[str]:\n    \"\"\"Generate an AI summary of search results with citations.\n    \n    Args:\n        results: List of trial results to summarize (typically first 10)\n        query: The original search query for context\n        \n    Returns:\n        Summary string with [n] citation markers, or None if generation fails\n    \"\"\"\n    if not results:\n        return None\n        \n    settings = get_settings()\n    if not settings.anthropic_api_key:\n        logger.warning(\"No Anthropic API key configured, skipping summary generation\")\n        return None\n    \n    # Build context from results\n    trials_context = []\n    for i, trial in enumerate(results[:10], start=1):  # Limit to top 10 for context\n        conditions = \", \".join(\n            val for c in trial.conditions for val in c.values() if val\n        )[:200]\n        sponsor = trial.sponsors[0].name if trial.sponsors else \"Unknown\"\n        trials_context.append(\n            f\"[{i}] {trial.brief_title}\\n\"\n            f\"    NCT ID: {trial.nct_id}\\n\"\n            f\"    Phase: {trial.phase or 'N/A'}\\n\"\n            f\"    Status: {trial.overall_status or 'N/A'}\\n\"\n            f\"    Conditions: {conditions or 'N/A'}\\n\"\n            f\"    Sponsor: {sponsor}\\n\"\n            f\"    Enrollment: {trial.enrollment or 'N/A'}\"\n        )\n    \n    context_text = \"\\n\\n\".join(trials_context)\n    \n    client = anthropic.AsyncAnthropic(api_key=settings.anthropic_api_key)\n    \n    try:\n        message = await client.messages.create(\n            model=settings.claude_model,\n            max_tokens=500,\n            system=SUMMARY_SYSTEM_PROMPT,\n            messages=[{\n                \"role\": \"user\",\n                \"content\": f\"Search query: \\\"{query}\\\"\\n\\nClinical trials found:\\n\\n{context_text}\\n\\nProvide a brief summary with citations.\"\n            }]\n        )\n        return message.content[0].text.strip()\n    except anthropic.APIError as exc:\n        logger.error(\"Summary generation API error: %s\", exc)\n        return None\n    except Exception as exc:\n        logger.error(\"Unexpected error generating summary: %s\", exc, exc_info=True)\n        return None\n```\n\n### 2. Update Search Response Schema\nModify `backend/app/models/schemas.py` to add the summary field:\n```python\nclass SearchResponse(BaseModel):\n    query_interpretation: ExtractedEntities\n    results: List[TrialResult]\n    total: int = Field(..., ge=0)\n    page: int = Field(..., ge=1)\n    page_size: int = Field(..., ge=1)\n    clarification: Optional[str] = None\n    summary: Optional[str] = None  # AI-generated summary with [n] citations\n```\n\n### 3. Update Search Endpoint\nModify `backend/app/routers/search.py`:\n```python\nfrom ..services.summary_service import generate_summary\n\n@router.get(\"/search/{query}\", response_model=SearchResponse)\nasync def search_trials(\n    query: str,\n    page: int = Query(default=1, ge=1),\n    page_size: int = Query(default=10, ge=1, le=100),\n) -> SearchResponse:\n    try:\n        entities = await extract_entities(query)\n        results, total = await es_service.search(entities, page, page_size)\n        \n        # Generate summary only for page 1 with results\n        summary = None\n        if page == 1 and results:\n            summary = await generate_summary(results, query)\n        \n        return SearchResponse(\n            query_interpretation=entities,\n            results=results,\n            total=total,\n            page=page,\n            page_size=page_size,\n            clarification=entities.clarification,\n            summary=summary,\n        )\n    except Exception as exc:\n        logger.error(\"Search failed for query '%s': %s\", query, exc, exc_info=True)\n        raise HTTPException(status_code=500, detail=str(exc))\n```\n\n## Frontend Implementation\n\n### 4. Update TypeScript Types\nAdd to `frontend/src/types/index.ts`:\n```typescript\nexport interface SearchResponse {\n  query_interpretation: ExtractedEntities;\n  results: TrialResult[];\n  total: number;\n  page: number;\n  page_size: number;\n  clarification?: string;\n  summary?: string;  // AI-generated summary with [n] citations\n}\n```\n\n### 5. Create AISummary Component\nCreate `frontend/src/components/AISummary.tsx`:\n```tsx\nimport { useCallback } from 'react';\n\ninterface AISummaryProps {\n  summary: string;\n  onCitationClick: (index: number) => void;\n}\n\nexport default function AISummary({ summary, onCitationClick }: AISummaryProps) {\n  const renderSummaryWithCitations = useCallback(() => {\n    // Parse [n] citation markers and make them clickable\n    const parts = summary.split(/(\\[\\d+\\])/g);\n    \n    return parts.map((part, i) => {\n      const citationMatch = part.match(/^\\[(\\d+)\\]$/);\n      if (citationMatch) {\n        const index = parseInt(citationMatch[1], 10);\n        return (\n          <button\n            key={i}\n            onClick={(e) => {\n              e.stopPropagation();\n              onCitationClick(index - 1); // Convert to 0-indexed\n            }}\n            className=\"inline-flex items-center justify-center w-5 h-5 mx-0.5 text-xs font-semibold text-[var(--color-primary)] bg-[var(--color-primary)]/10 rounded hover:bg-[var(--color-primary)]/20 transition-colors cursor-pointer\"\n            aria-label={`Jump to result ${index}`}\n          >\n            {index}\n          </button>\n        );\n      }\n      return <span key={i}>{part}</span>;\n    });\n  }, [summary, onCitationClick]);\n\n  return (\n    <div className=\"w-full max-w-3xl mx-auto mb-6 p-5 bg-gradient-to-r from-[var(--color-primary)]/5 to-[var(--color-accent)]/5 rounded-lg border border-[var(--color-primary)]/20 animate-fadeIn\">\n      <div className=\"flex items-start gap-3\">\n        <div className=\"shrink-0 w-8 h-8 flex items-center justify-center bg-[var(--color-primary)]/10 rounded-full\">\n          <svg className=\"w-4 h-4 text-[var(--color-primary)]\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13 10V3L4 14h7v7l9-11h-7z\" />\n          </svg>\n        </div>\n        <div className=\"flex-1\">\n          <h3 className=\"text-sm font-semibold text-[var(--color-primary)] mb-2\">AI Summary</h3>\n          <p className=\"text-sm text-[var(--color-text)] leading-relaxed\">\n            {renderSummaryWithCitations()}\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n### 6. Update ResultCard to Support Highlighting\nModify `frontend/src/components/ResultCard.tsx` to accept highlight state via ref:\n```tsx\nimport { useState, useEffect, forwardRef } from 'react';\n\ninterface ResultCardProps {\n  trial: TrialResult;\n  index: number;\n  isHighlighted?: boolean;\n}\n\nconst ResultCard = forwardRef<HTMLDivElement, ResultCardProps>(\n  ({ trial, index, isHighlighted = false }, ref) => {\n    const [expanded, setExpanded] = useState(false);\n    const [showHighlight, setShowHighlight] = useState(false);\n    \n    useEffect(() => {\n      if (isHighlighted) {\n        setShowHighlight(true);\n        const timer = setTimeout(() => setShowHighlight(false), 2000);\n        return () => clearTimeout(timer);\n      }\n    }, [isHighlighted]);\n    \n    // ... rest of component with added highlight ring class:\n    return (\n      <div\n        ref={ref}\n        onClick={() => setExpanded(!expanded)}\n        className={`bg-[var(--color-bg-card)] rounded-lg shadow-sm border border-gray-200 border-l-4 p-5 hover:shadow-md transition-all cursor-pointer animate-fadeIn ${\n          showHighlight ? 'ring-2 ring-[var(--color-accent)] ring-offset-2' : ''\n        }`}\n        // ...\n      >\n        {/* existing content */}\n      </div>\n    );\n  }\n);\n```\n\n### 7. Update ResultsList to Handle Citation Scrolling\nModify `frontend/src/components/ResultsList.tsx`:\n```tsx\nimport { useRef, useState, useCallback, useImperativeHandle, forwardRef } from 'react';\nimport type { TrialResult } from '../types';\nimport ResultCard from './ResultCard';\nimport Pagination from './Pagination';\n\ninterface ResultsListProps {\n  results: TrialResult[];\n  total: number;\n  page: number;\n  pageSize: number;\n  onPageChange: (page: number) => void;\n}\n\nexport interface ResultsListHandle {\n  scrollToResult: (index: number) => void;\n}\n\nconst ResultsList = forwardRef<ResultsListHandle, ResultsListProps>(\n  ({ results, total, page, pageSize, onPageChange }, ref) => {\n    const cardRefs = useRef<(HTMLDivElement | null)[]>([]);\n    const [highlightedIndex, setHighlightedIndex] = useState<number | null>(null);\n    \n    const scrollToResult = useCallback((index: number) => {\n      const card = cardRefs.current[index];\n      if (card) {\n        card.scrollIntoView({ behavior: 'smooth', block: 'center' });\n        setHighlightedIndex(index);\n        setTimeout(() => setHighlightedIndex(null), 2000);\n      }\n    }, []);\n    \n    useImperativeHandle(ref, () => ({ scrollToResult }), [scrollToResult]);\n    \n    return (\n      <div className=\"w-full max-w-3xl mx-auto\">\n        <p className=\"text-sm text-[var(--color-text-muted)] mb-4\">\n          {total} result{total !== 1 ? 's' : ''} found\n        </p>\n        <div className=\"space-y-4\">\n          {results.map((trial, i) => (\n            <ResultCard\n              key={trial.nct_id}\n              ref={(el) => { cardRefs.current[i] = el; }}\n              trial={trial}\n              index={i}\n              isHighlighted={highlightedIndex === i}\n            />\n          ))}\n        </div>\n        <Pagination currentPage={page} totalPages={Math.ceil(total / pageSize)} onPageChange={onPageChange} />\n      </div>\n    );\n  }\n);\n\nexport default ResultsList;\n```\n\n### 8. Update App.tsx to Wire Summary and Citation Clicks\n```tsx\nimport AISummary from './components/AISummary';\nimport ResultsList, { ResultsListHandle } from './components/ResultsList';\n\nexport default function App() {\n  // ... existing state\n  const resultsListRef = useRef<ResultsListHandle>(null);\n  \n  const handleCitationClick = useCallback((index: number) => {\n    resultsListRef.current?.scrollToResult(index);\n  }, []);\n  \n  return (\n    // ... in the results section:\n    {appState === 'results' && response && (\n      <>\n        {response.summary && response.page === 1 && (\n          <AISummary \n            summary={response.summary} \n            onCitationClick={handleCitationClick} \n          />\n        )}\n        <ResultsList\n          ref={resultsListRef}\n          results={response.results}\n          total={response.total}\n          page={response.page}\n          pageSize={response.page_size}\n          onPageChange={handlePageChange}\n        />\n      </>\n    )}\n  );\n}\n```\n\n## Key Implementation Notes\n\n1. **Graceful Degradation**: If the Claude API call fails, returns `None` for summary and search results display normally\n2. **Page 1 Only**: Summary generation is conditionally triggered only when `page == 1`\n3. **Citation Parsing**: Uses regex `/(\\[\\d+\\])/g` to split and identify citation markers\n4. **Smooth Scroll**: Uses `scrollIntoView({ behavior: 'smooth', block: 'center' })` for smooth scrolling\n5. **Highlight Animation**: 2-second ring highlight using Tailwind's `ring-2 ring-[var(--color-accent)]`\n6. **Ref Forwarding**: Uses `forwardRef` and `useImperativeHandle` for parent-to-child communication\n7. **Performance**: Summary uses max 10 results and max 500 tokens to keep API costs low",
        "testStrategy": "## Backend Tests\n\n### 1. Unit Tests for Summary Service\nCreate `backend/tests/test_summary_service.py`:\n```python\nimport pytest\nfrom unittest.mock import AsyncMock, patch\nfrom app.services.summary_service import generate_summary\nfrom app.models.schemas import TrialResult, Sponsor\n\n@pytest.fixture\ndef mock_results():\n    return [\n        TrialResult(\n            nct_id=\"NCT001\",\n            brief_title=\"Phase 3 Lung Cancer Trial\",\n            phase=\"PHASE3\",\n            overall_status=\"RECRUITING\",\n            sponsors=[Sponsor(name=\"Pfizer\")],\n            conditions=[{\"condition\": \"Lung Cancer\"}],\n            facilities=[],\n            age=[],\n        ),\n        TrialResult(\n            nct_id=\"NCT002\",\n            brief_title=\"Phase 2 Breast Cancer Study\",\n            phase=\"PHASE2\",\n            overall_status=\"ACTIVE_NOT_RECRUITING\",\n            sponsors=[Sponsor(name=\"AstraZeneca\")],\n            conditions=[{\"condition\": \"Breast Cancer\"}],\n            facilities=[],\n            age=[],\n        ),\n    ]\n\n@pytest.mark.asyncio\nasync def test_generate_summary_returns_string_with_citations(mock_results):\n    with patch('app.services.summary_service.anthropic.AsyncAnthropic') as mock_client:\n        mock_message = AsyncMock()\n        mock_message.content = [AsyncMock(text=\"This search found lung cancer trials [1] and breast cancer studies [2].\")]\n        mock_client.return_value.messages.create = AsyncMock(return_value=mock_message)\n        \n        result = await generate_summary(mock_results, \"cancer trials\")\n        \n        assert result is not None\n        assert \"[1]\" in result\n        assert \"[2]\" in result\n\n@pytest.mark.asyncio\nasync def test_generate_summary_returns_none_on_empty_results():\n    result = await generate_summary([], \"test query\")\n    assert result is None\n\n@pytest.mark.asyncio\nasync def test_generate_summary_handles_api_error(mock_results):\n    with patch('app.services.summary_service.anthropic.AsyncAnthropic') as mock_client:\n        mock_client.return_value.messages.create = AsyncMock(\n            side_effect=Exception(\"API Error\")\n        )\n        result = await generate_summary(mock_results, \"test\")\n        assert result is None  # Graceful degradation\n```\n\n### 2. Integration Test for Search Endpoint with Summary\n```python\n@pytest.mark.asyncio\nasync def test_search_returns_summary_on_page_1(async_client):\n    response = await async_client.get(\"/api/search/lung%20cancer?page=1\")\n    assert response.status_code == 200\n    data = response.json()\n    # Summary may or may not be present depending on API availability\n    assert \"summary\" in data\n\n@pytest.mark.asyncio\nasync def test_search_no_summary_on_page_2(async_client):\n    response = await async_client.get(\"/api/search/lung%20cancer?page=2\")\n    assert response.status_code == 200\n    data = response.json()\n    assert data.get(\"summary\") is None\n```\n\n## Frontend Tests\n\n### 3. AISummary Component Tests\n```typescript\n// frontend/src/__tests__/AISummary.test.tsx\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport AISummary from '../components/AISummary';\n\ndescribe('AISummary', () => {\n  it('renders summary text correctly', () => {\n    render(\n      <AISummary \n        summary=\"This is a test summary.\" \n        onCitationClick={() => {}} \n      />\n    );\n    expect(screen.getByText(/This is a test summary/)).toBeInTheDocument();\n  });\n\n  it('renders clickable citation markers', () => {\n    render(\n      <AISummary \n        summary=\"Found trials [1] and [2] related to cancer.\" \n        onCitationClick={() => {}} \n      />\n    );\n    expect(screen.getByRole('button', { name: /Jump to result 1/ })).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: /Jump to result 2/ })).toBeInTheDocument();\n  });\n\n  it('calls onCitationClick with correct 0-indexed value', () => {\n    const handleClick = jest.fn();\n    render(\n      <AISummary \n        summary=\"See trial [1] for details.\" \n        onCitationClick={handleClick} \n      />\n    );\n    fireEvent.click(screen.getByRole('button', { name: /Jump to result 1/ }));\n    expect(handleClick).toHaveBeenCalledWith(0); // 0-indexed\n  });\n});\n```\n\n### 4. ResultCard Highlight Tests\n```typescript\nit('shows highlight ring when isHighlighted is true', () => {\n  const { container } = render(\n    <ResultCard trial={mockTrial} index={0} isHighlighted={true} />\n  );\n  expect(container.firstChild).toHaveClass('ring-2');\n});\n\nit('removes highlight after 2 seconds', async () => {\n  jest.useFakeTimers();\n  const { container, rerender } = render(\n    <ResultCard trial={mockTrial} index={0} isHighlighted={true} />\n  );\n  expect(container.firstChild).toHaveClass('ring-2');\n  jest.advanceTimersByTime(2000);\n  rerender(<ResultCard trial={mockTrial} index={0} isHighlighted={false} />);\n  expect(container.firstChild).not.toHaveClass('ring-2');\n  jest.useRealTimers();\n});\n```\n\n## Manual E2E Testing Checklist\n\n1. **Summary Appears on Page 1**\n   - Search for \"lung cancer trials\"\n   - Verify AI Summary section appears above results\n   - Verify summary contains 3-5 sentences\n\n2. **Summary Not Present on Page 2+**\n   - Navigate to page 2\n   - Verify summary section is not displayed\n\n3. **Citation Markers are Clickable**\n   - Click on [1] citation in summary\n   - Verify page smoothly scrolls to first result\n   - Verify first result card briefly highlights with ring\n\n4. **Highlight Animation**\n   - Click citation marker\n   - Observe 2-second highlight animation\n   - Verify highlight fades after timeout\n\n5. **Graceful Degradation**\n   - Disable ANTHROPIC_API_KEY temporarily\n   - Perform search\n   - Verify results still display without summary\n   - Verify no error is shown to user\n\n6. **Multiple Citations**\n   - Search for query returning 5+ results\n   - Verify multiple citations [1], [2], [3] etc. work correctly\n   - Click each and verify correct card is scrolled to\n\n7. **Responsive Design**\n   - Test on mobile viewport (375px)\n   - Verify summary section is readable\n   - Verify citation buttons are tappable",
        "status": "done",
        "dependencies": [
          "4",
          "7",
          "9"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Backend Summary Generation Service",
            "description": "Create a new summary_service.py file in backend/app/services/ that uses the Anthropic Claude API to generate AI-powered summaries of search results with citation markers.",
            "dependencies": [],
            "details": "Create `backend/app/services/summary_service.py` with an async `generate_summary(results: List[TrialResult], query: str) -> Optional[str]` function. The service should: 1) Use the existing config pattern from `config.py` to access `anthropic_api_key` and `claude_model` settings, 2) Build context from the first 10 trial results including NCT ID, phase, status, conditions, sponsor, and enrollment, 3) Define a `SUMMARY_SYSTEM_PROMPT` instructing Claude to write 3-5 sentences with numbered [1], [2] citation markers, 4) Call the Anthropic async API with max_tokens=500, 5) Return None gracefully if no API key is configured or if the API call fails, 6) Include proper logging for errors. Follow the existing llm_service.py patterns for error handling and API usage.",
            "status": "done",
            "testStrategy": "Create `backend/tests/test_summary_service.py` with unit tests: 1) Test generate_summary returns None for empty results list, 2) Test generate_summary returns None when no API key is configured (mock get_settings), 3) Test successful summary generation with mocked Anthropic client returning a valid response with citations, 4) Test graceful handling of Anthropic API errors (APIError exception), 5) Test graceful handling of unexpected exceptions. Use the same mocking patterns established in test_llm_service.py.",
            "updatedAt": "2026-02-07T22:02:47.927Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Update Backend Search Schema and Endpoint",
            "description": "Modify the SearchResponse Pydantic model to include an optional summary field and update the search endpoint to call the summary service for page 1 results.",
            "dependencies": [
              1
            ],
            "details": "In `backend/app/models/schemas.py`, add `summary: Optional[str] = None` field to SearchResponse model after the clarification field. In `backend/app/routers/search.py`: 1) Import `generate_summary` from `..services.summary_service`, 2) After the existing search logic, conditionally call `summary = await generate_summary(results, query)` only when `page == 1 and results`, 3) Pass the summary to the SearchResponse constructor. The summary generation should not block or fail the search - if it fails, summary should simply be None.",
            "status": "done",
            "testStrategy": "Add tests to `backend/tests/test_endpoints.py`: 1) Test that /search/{query} returns summary field in response JSON, 2) Test that summary is only present on page 1 (mock summary service to return a value), 3) Test that summary is None for page > 1, 4) Test that search still works when summary generation fails (mock summary service to raise exception). Integration test: verify summary field appears in actual API response structure.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T22:02:47.935Z"
          },
          {
            "id": 3,
            "title": "Update Frontend Types and Create AISummary Component",
            "description": "Add the summary field to TypeScript types and create a new AISummary component that renders the summary with clickable citation buttons.",
            "dependencies": [],
            "details": "In `frontend/src/types/index.ts`, add `summary?: string;` to the SearchResponse interface. Create `frontend/src/components/AISummary.tsx` with: 1) Props interface `{ summary: string; onCitationClick: (index: number) => void }`, 2) A `renderSummaryWithCitations` callback using `summary.split(/(\\[\\d+\\])/g)` regex to parse citation markers, 3) Render citation markers as clickable buttons with styling: inline-flex, small size, primary color with opacity background, hover effect, 4) The button onClick should call `onCitationClick(index - 1)` to convert to 0-indexed, 5) Wrapper div with gradient background, rounded corners, border, and icon indicating AI-generated content. Use existing CSS variable patterns (--color-primary, --color-text, etc.).",
            "status": "done",
            "testStrategy": "Manual testing: 1) Verify component renders summary text correctly, 2) Verify [1], [2], [3] markers are converted to clickable buttons, 3) Verify clicking a citation button calls onCitationClick with correct 0-indexed value, 4) Verify styling matches design system (gradient background, proper spacing, icon). Optional: Add unit tests with React Testing Library to verify citation parsing and click handlers.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T22:02:47.938Z"
          },
          {
            "id": 4,
            "title": "Update ResultCard and ResultsList for Highlight and Scroll Support",
            "description": "Modify ResultCard to support highlight state with forwardRef, and update ResultsList to expose a scrollToResult method using useImperativeHandle.",
            "dependencies": [
              3
            ],
            "details": "In `frontend/src/components/ResultCard.tsx`: 1) Convert to forwardRef component, 2) Add `isHighlighted?: boolean` to props, 3) Add local `showHighlight` state with useEffect that sets true when isHighlighted changes to true, then resets after 2000ms (cleanup timer on unmount), 4) Add ring-2 ring-[var(--color-accent)] ring-offset-2 classes conditionally when showHighlight is true. In `frontend/src/components/ResultsList.tsx`: 1) Convert to forwardRef, 2) Export `ResultsListHandle` interface with `scrollToResult: (index: number) => void`, 3) Add `cardRefs = useRef<(HTMLDivElement | null)[]>([])` to store refs for each card, 4) Add `highlightedIndex` state, 5) Implement scrollToResult callback using `scrollIntoView({ behavior: 'smooth', block: 'center' })` and setting highlightedIndex, 6) Use useImperativeHandle to expose scrollToResult, 7) Pass ref and isHighlighted prop to each ResultCard.",
            "status": "done",
            "testStrategy": "Manual testing: 1) Verify ResultCard accepts ref and forwards to DOM element, 2) Verify highlight ring appears when isHighlighted is true, 3) Verify highlight ring disappears after 2 seconds, 4) Verify ResultsList.scrollToResult scrolls the specified card into view smoothly, 5) Verify scrolled card receives highlight animation. Test edge cases: calling scrollToResult for invalid index should not crash.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T22:02:47.941Z"
          },
          {
            "id": 5,
            "title": "Wire AISummary Component in App.tsx",
            "description": "Integrate the AISummary component into App.tsx, connecting citation clicks to the ResultsList scroll functionality.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "In `frontend/src/App.tsx`: 1) Import AISummary and ResultsListHandle type, 2) Add `resultsListRef = useRef<ResultsListHandle>(null)`, 3) Create `handleCitationClick = useCallback((index: number) => { resultsListRef.current?.scrollToResult(index); }, [])`, 4) In the results rendering section (appState === 'results'), add the AISummary component before ResultsList: render `<AISummary summary={response.summary} onCitationClick={handleCitationClick} />` only when `response.summary && response.page === 1`, 5) Pass `ref={resultsListRef}` to the ResultsList component. Ensure the summary only displays on page 1 and smoothly transitions when navigating pages.",
            "status": "done",
            "testStrategy": "End-to-end testing: 1) Perform a search and verify AI summary appears above results on page 1, 2) Click citation buttons [1], [2], etc. and verify page scrolls to corresponding result card, 3) Verify highlighted card has visible ring animation for 2 seconds, 4) Navigate to page 2 and verify summary disappears, 5) Navigate back to page 1 and verify summary reappears with new search, 6) Test with search that returns no results - verify no summary displayed, 7) Test with API key not configured - verify search works without summary.",
            "parentId": "undefined",
            "updatedAt": "2026-02-07T22:02:47.943Z"
          }
        ],
        "updatedAt": "2026-02-07T22:02:47.943Z"
      },
      {
        "id": 12,
        "title": "Manual Filter UI Panel for Clinical Trial Search",
        "description": "Implement a collapsible filter panel component that provides interactive UI controls (dropdowns, sliders, checkboxes, text inputs) for all 9 filter types, syncs bidirectionally with QueryInterpretation chips, and sends filter parameters directly to the backend without requiring natural language processing.",
        "details": "## Frontend Implementation\n\n### 1. Create Filter Types and State Management\nCreate `frontend/src/types/filters.ts`:\n```typescript\nimport type { ExtractedEntities, LocationFilter, PhaseValue, StatusValue, AgeCategoryValue } from './index';\n\nexport interface FilterState {\n  phase: PhaseValue | null;\n  status: StatusValue | null;\n  condition: string;\n  location: LocationFilter;\n  sponsor: string;\n  keyword: string;\n  ageGroups: AgeCategoryValue[];\n  enrollmentMin: number | null;\n  enrollmentMax: number | null;\n}\n\nexport const INITIAL_FILTER_STATE: FilterState = {\n  phase: null,\n  status: null,\n  condition: '',\n  location: { city: '', state: '', country: '' },\n  sponsor: '',\n  keyword: '',\n  ageGroups: [],\n  enrollmentMin: null,\n  enrollmentMax: null,\n};\n\nexport function filtersToEntities(filters: FilterState): Partial<ExtractedEntities> {\n  return {\n    phase: filters.phase || undefined,\n    status: filters.status || undefined,\n    condition: filters.condition || undefined,\n    location: (filters.location.city || filters.location.state || filters.location.country) \n      ? filters.location : undefined,\n    sponsor: filters.sponsor || undefined,\n    keyword: filters.keyword || undefined,\n    age_group: filters.ageGroups[0] || undefined,\n    enrollment_min: filters.enrollmentMin ?? undefined,\n    enrollment_max: filters.enrollmentMax ?? undefined,\n  };\n}\n\nexport function entitiesToFilters(entities: ExtractedEntities): FilterState {\n  return {\n    phase: (entities.phase as PhaseValue) || null,\n    status: (entities.status as StatusValue) || null,\n    condition: entities.condition || '',\n    location: entities.location || { city: '', state: '', country: '' },\n    sponsor: entities.sponsor || '',\n    keyword: entities.keyword || '',\n    ageGroups: entities.age_group ? [entities.age_group as AgeCategoryValue] : [],\n    enrollmentMin: entities.enrollment_min ?? null,\n    enrollmentMax: entities.enrollment_max ?? null,\n  };\n}\n```\n\n### 2. Create FilterPanel Component\nCreate `frontend/src/components/FilterPanel.tsx`:\n```tsx\nimport { useState, useEffect } from 'react';\nimport type { FilterState } from '../types/filters';\nimport { INITIAL_FILTER_STATE } from '../types/filters';\nimport { PHASE_VALUES, STATUS_VALUES, AGE_CATEGORIES } from '../types';\nimport type { PhaseValue, StatusValue, AgeCategoryValue } from '../types';\nimport { getSuggestions } from '../services/api';\n\ninterface FilterPanelProps {\n  filters: FilterState;\n  onFiltersChange: (filters: FilterState) => void;\n  onApply: () => void;\n  onClear: () => void;\n  isCollapsed: boolean;\n  onToggleCollapse: () => void;\n}\n\nexport default function FilterPanel({\n  filters,\n  onFiltersChange,\n  onApply,\n  onClear,\n  isCollapsed,\n  onToggleCollapse,\n}: FilterPanelProps) {\n  const [conditionSuggestions, setConditionSuggestions] = useState<string[]>([]);\n  const [sponsorSuggestions, setSponsorSuggestions] = useState<string[]>([]);\n\n  const updateFilter = <K extends keyof FilterState>(key: K, value: FilterState[K]) => {\n    onFiltersChange({ ...filters, [key]: value });\n  };\n\n  const updateLocation = (field: 'city' | 'state' | 'country', value: string) => {\n    onFiltersChange({\n      ...filters,\n      location: { ...filters.location, [field]: value },\n    });\n  };\n\n  const toggleAgeGroup = (age: AgeCategoryValue) => {\n    const newAgeGroups = filters.ageGroups.includes(age)\n      ? filters.ageGroups.filter((a) => a !== age)\n      : [...filters.ageGroups, age];\n    updateFilter('ageGroups', newAgeGroups);\n  };\n\n  const hasActiveFilters = filters.phase || filters.status || filters.condition ||\n    filters.location.city || filters.location.state || filters.location.country ||\n    filters.sponsor || filters.keyword || filters.ageGroups.length > 0 ||\n    filters.enrollmentMin !== null || filters.enrollmentMax !== null;\n\n  return (\n    <aside className={`bg-[var(--color-bg-card)] border-r border-gray-200 transition-all duration-300 ${\n      isCollapsed ? 'w-12' : 'w-80'\n    }`}>\n      <button onClick={onToggleCollapse} className=\"p-3 w-full flex items-center justify-between\">\n        <span className={isCollapsed ? 'hidden' : 'font-medium'}>Filters</span>\n        <svg className={`w-5 h-5 transition-transform ${isCollapsed ? 'rotate-180' : ''}`}>\n          {/* Chevron icon */}\n        </svg>\n      </button>\n\n      {!isCollapsed && (\n        <div className=\"p-4 space-y-6 overflow-y-auto max-h-[calc(100vh-200px)]\">\n          {/* Phase Dropdown */}\n          <div>\n            <label className=\"block text-sm font-medium mb-2\">Phase</label>\n            <select\n              value={filters.phase || ''}\n              onChange={(e) => updateFilter('phase', (e.target.value as PhaseValue) || null)}\n              className=\"w-full p-2 border rounded-lg\"\n            >\n              <option value=\"\">Any Phase</option>\n              {PHASE_VALUES.map((phase) => (\n                <option key={phase} value={phase}>{phase}</option>\n              ))}\n            </select>\n          </div>\n\n          {/* Status Dropdown */}\n          <div>\n            <label className=\"block text-sm font-medium mb-2\">Status</label>\n            <select\n              value={filters.status || ''}\n              onChange={(e) => updateFilter('status', (e.target.value as StatusValue) || null)}\n              className=\"w-full p-2 border rounded-lg\"\n            >\n              <option value=\"\">Any Status</option>\n              {STATUS_VALUES.map((status) => (\n                <option key={status} value={status}>{status.replace(/_/g, ' ')}</option>\n              ))}\n            </select>\n          </div>\n\n          {/* Condition with Autocomplete */}\n          <AutocompleteInput\n            label=\"Condition\"\n            value={filters.condition}\n            onChange={(v) => updateFilter('condition', v)}\n            placeholder=\"e.g., Lung Cancer\"\n          />\n\n          {/* Location Inputs */}\n          <div>\n            <label className=\"block text-sm font-medium mb-2\">Location</label>\n            <div className=\"space-y-2\">\n              <input type=\"text\" placeholder=\"City\" value={filters.location.city || ''}\n                onChange={(e) => updateLocation('city', e.target.value)} className=\"w-full p-2 border rounded-lg\" />\n              <input type=\"text\" placeholder=\"State\" value={filters.location.state || ''}\n                onChange={(e) => updateLocation('state', e.target.value)} className=\"w-full p-2 border rounded-lg\" />\n              <input type=\"text\" placeholder=\"Country\" value={filters.location.country || ''}\n                onChange={(e) => updateLocation('country', e.target.value)} className=\"w-full p-2 border rounded-lg\" />\n            </div>\n          </div>\n\n          {/* Sponsor with Autocomplete */}\n          <AutocompleteInput\n            label=\"Sponsor\"\n            value={filters.sponsor}\n            onChange={(v) => updateFilter('sponsor', v)}\n            placeholder=\"e.g., Pfizer\"\n          />\n\n          {/* Keyword Input */}\n          <div>\n            <label className=\"block text-sm font-medium mb-2\">Keyword</label>\n            <input type=\"text\" value={filters.keyword}\n              onChange={(e) => updateFilter('keyword', e.target.value)}\n              placeholder=\"Gene, drug, or term\" className=\"w-full p-2 border rounded-lg\" />\n          </div>\n\n          {/* Age Group Checkboxes */}\n          <div>\n            <label className=\"block text-sm font-medium mb-2\">Age Group</label>\n            <div className=\"grid grid-cols-2 gap-2\">\n              {AGE_CATEGORIES.map((age) => (\n                <label key={age} className=\"flex items-center gap-2 text-sm\">\n                  <input type=\"checkbox\" checked={filters.ageGroups.includes(age)}\n                    onChange={() => toggleAgeGroup(age)} className=\"rounded\" />\n                  {age.charAt(0).toUpperCase() + age.slice(1).replace('-', ' ')}\n                </label>\n              ))}\n            </div>\n          </div>\n\n          {/* Enrollment Range */}\n          <div>\n            <label className=\"block text-sm font-medium mb-2\">Enrollment Range</label>\n            <div className=\"flex gap-2\">\n              <input type=\"number\" placeholder=\"Min\" value={filters.enrollmentMin ?? ''}\n                onChange={(e) => updateFilter('enrollmentMin', e.target.value ? parseInt(e.target.value) : null)}\n                className=\"w-1/2 p-2 border rounded-lg\" min=\"0\" />\n              <input type=\"number\" placeholder=\"Max\" value={filters.enrollmentMax ?? ''}\n                onChange={(e) => updateFilter('enrollmentMax', e.target.value ? parseInt(e.target.value) : null)}\n                className=\"w-1/2 p-2 border rounded-lg\" min=\"0\" />\n            </div>\n          </div>\n\n          {/* Action Buttons */}\n          <div className=\"flex gap-2 pt-4 border-t\">\n            <button onClick={onApply}\n              className=\"flex-1 py-2 bg-[var(--color-accent)] text-white rounded-lg hover:bg-[var(--color-accent-dark)]\">\n              Apply Filters\n            </button>\n            <button onClick={onClear} disabled={!hasActiveFilters}\n              className=\"px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 disabled:opacity-50\">\n              Clear\n            </button>\n          </div>\n        </div>\n      )}\n    </aside>\n  );\n}\n```\n\n### 3. Create AutocompleteInput Component\nCreate `frontend/src/components/AutocompleteInput.tsx` for condition/sponsor fields with debounced suggestions using the existing `/api/suggest` endpoint.\n\n### 4. Update API Service\nAdd to `frontend/src/services/api.ts`:\n```typescript\nexport async function searchWithFilters(\n  filters: Partial<ExtractedEntities>,\n  page: number = 1,\n  pageSize: number = 10\n): Promise<SearchResponse> {\n  const params = new URLSearchParams({ page: String(page), page_size: String(pageSize) });\n  \n  // Add non-null filter values to query params\n  Object.entries(filters).forEach(([key, value]) => {\n    if (value !== undefined && value !== null && value !== '') {\n      if (typeof value === 'object') {\n        params.set(key, JSON.stringify(value));\n      } else {\n        params.set(key, String(value));\n      }\n    }\n  });\n\n  const response = await fetch(`${API_BASE}/filter?${params.toString()}`);\n  if (!response.ok) throw new Error(`Filter search failed: ${response.statusText}`);\n  return response.json();\n}\n```\n\n### 5. Backend Filter Endpoint\nAdd to `backend/app/routers/search.py`:\n```python\n@router.get(\"/filter\", response_model=SearchResponse)\nasync def filter_trials(\n    page: int = Query(default=1, ge=1),\n    page_size: int = Query(default=10, ge=1, le=100),\n    phase: Optional[str] = None,\n    status: Optional[str] = None,\n    condition: Optional[str] = None,\n    location: Optional[str] = None,  # JSON string\n    sponsor: Optional[str] = None,\n    keyword: Optional[str] = None,\n    age_group: Optional[str] = None,\n    enrollment_min: Optional[int] = None,\n    enrollment_max: Optional[int] = None,\n) -> SearchResponse:\n    \"\"\"Search clinical trials using explicit filter parameters.\"\"\"\n    import json\n    location_filter = None\n    if location:\n        loc_data = json.loads(location)\n        location_filter = LocationFilter(**loc_data)\n    \n    entities = ExtractedEntities(\n        phase=phase,\n        status=status,\n        condition=condition,\n        location=location_filter,\n        sponsor=sponsor,\n        keyword=keyword,\n        age_group=age_group,\n        enrollment_min=enrollment_min,\n        enrollment_max=enrollment_max,\n        confidence=1.0,  # Manual filters have full confidence\n    )\n    results, total = await es_service.search(entities, page, page_size)\n    return SearchResponse(\n        query_interpretation=entities,\n        results=results,\n        total=total,\n        page=page,\n        page_size=page_size,\n    )\n```\n\n### 6. Update App.tsx Layout\nModify `frontend/src/App.tsx` to include the FilterPanel in a sidebar layout alongside results, managing bidirectional sync between filters and query interpretation.\n\n### 7. Sync QueryInterpretation with Filters\nUpdate QueryInterpretation.tsx to make chips clickable/removable, allowing users to toggle filters by clicking on chips. When a chip is clicked, it should update the FilterPanel state and trigger a new search.\n\n### Key Considerations:\n- Use controlled components for all form inputs\n- Implement debounce for autocomplete inputs (300ms)\n- Add visual indicators for active filters (badge count, highlighted chips)\n- Ensure mobile responsiveness with a slide-out drawer pattern\n- Match existing color scheme from index.css (--color-primary, --color-accent)\n- Follow existing component patterns from SearchBar.tsx and QueryInterpretation.tsx",
        "testStrategy": "## Unit Tests\n\n### 1. FilterPanel Component Tests\nCreate `frontend/src/components/__tests__/FilterPanel.test.tsx`:\n- Test each filter control renders correctly\n- Test dropdown selection updates filter state\n- Test checkbox toggle for age groups\n- Test enrollment range inputs accept valid numbers\n- Test Clear button resets all filters to initial state\n- Test Apply button triggers onApply callback\n- Test collapsed state hides filter controls\n\n### 2. Filter State Conversion Tests\n- Test `filtersToEntities()` converts all fields correctly\n- Test `entitiesToFilters()` handles null/undefined values\n- Test round-trip conversion maintains data integrity\n\n### 3. AutocompleteInput Tests\n- Test debounced API calls (verify 300ms delay)\n- Test suggestions display on focus with valid input\n- Test suggestion selection updates input value\n- Test keyboard navigation (arrow up/down, enter)\n\n## Integration Tests\n\n### 4. Filter + Search Flow\n- Apply Phase=PHASE3 filter → verify API call includes phase parameter\n- Apply multiple filters → verify all parameters sent to /api/filter\n- Clear filters → verify search returns to unfiltered state\n- Apply filters → verify QueryInterpretation shows matching chips\n\n### 5. Bidirectional Sync Tests\n- Set filters via FilterPanel → verify chips appear in QueryInterpretation\n- Parse natural language query → verify FilterPanel updates to match\n- Remove chip from QueryInterpretation → verify FilterPanel updates\n\n### 6. Backend /api/filter Endpoint Tests\nCreate `backend/tests/test_filter_endpoint.py`:\n```python\ndef test_filter_by_phase():\n    response = client.get(\"/api/filter?phase=PHASE3\")\n    assert response.status_code == 200\n    data = response.json()\n    assert all(r[\"phase\"] == \"PHASE3\" for r in data[\"results\"] if r[\"phase\"])\n\ndef test_filter_by_multiple_params():\n    response = client.get(\"/api/filter?phase=PHASE2&status=RECRUITING\")\n    assert response.status_code == 200\n\ndef test_filter_by_location_json():\n    loc = json.dumps({\"country\": \"United States\"})\n    response = client.get(f\"/api/filter?location={loc}\")\n    assert response.status_code == 200\n\ndef test_filter_enrollment_range():\n    response = client.get(\"/api/filter?enrollment_min=100&enrollment_max=500\")\n    assert response.status_code == 200\n```\n\n## E2E Tests\n\n### 7. User Workflow Tests\n1. Open filter panel → select Phase 3 → click Apply → verify results show only Phase 3 trials\n2. Enter \"cancer\" in condition field → verify autocomplete suggestions appear\n3. Select \"Recruiting\" status + enter \"California\" in state → Apply → verify combined filtering\n4. Click on a chip in QueryInterpretation → verify filter panel updates and filters apply\n5. Use natural language search → verify filter panel reflects extracted entities\n6. Clear all filters → verify full result set returns\n\n### 8. Responsive Design Tests\n- Test filter panel collapse/expand on desktop\n- Test slide-out drawer behavior on mobile (< 768px)\n- Verify filter controls remain accessible at all breakpoints\n\n### 9. Performance Tests\n- Verify filter apply takes < 500ms for response\n- Verify autocomplete suggestions appear within 400ms of typing pause\n- Test with all 9 filters active simultaneously",
        "status": "pending",
        "dependencies": [
          5,
          7,
          8,
          9
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-07T22:02:47.943Z",
      "taskCount": 11,
      "completedCount": 11,
      "tags": [
        "master"
      ],
      "created": "2026-02-07T22:22:31.471Z",
      "description": "Tasks for master context",
      "updated": "2026-02-07T22:23:58.723Z"
    }
  }
}